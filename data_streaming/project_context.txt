
    Just use v2 for templates.
    
<project_structure>
    <[CMakeLists.txt]>
        cmake_minimum_required(VERSION 3.24)
        project(data_streaming)
        
        # Set C++ standard
        set(CMAKE_CXX_STANDARD 17)
        set(CMAKE_CXX_STANDARD_REQUIRED ON)
        
        # Find FastDDS and FastCDR packages
        find_package(fastcdr REQUIRED)
        find_package(fastdds REQUIRED)
        
        # Include directories
        include_directories(
            ${FASTRTPS_INCLUDE_DIRS}
            ${FASTCDR_INCLUDE_DIRS}
            ${CMAKE_SOURCE_DIR}/include  # <-- headers here
            ${CMAKE_SOURCE_DIR}/src
        )
        
        # Add executable with source files
        add_executable(data_streaming
            src/main.cpp
            src/MBOPublisher.cpp
        )
        
        # Link FastDDS and FastCDR libraries
        target_link_libraries(data_streaming
            ${FASTRTPS_LIBRARIES}
            ${FASTCDR_LIBRARIES}
        )
        
        # Set output directory
        set_target_properties(data_streaming PROPERTIES
            RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}
        )
    </[CMakeLists.txt]>
    <[Makefile]>
        # Compiler and flags
        CXX = g++
        CXXFLAGS = -Wall -std=c++17 -Iinclude -pthread
        
        # FastRTPS and FastCDR libraries (Ubuntu package names)
        # Note: libfastdds is not available, use libfastrtps instead
        LIBS = -lfastrtps -lfastcdr
        
        # Directories
        BUILD_DIR = build
        SRC_DIR   = src
        
        # Target executable
        TARGET = $(BUILD_DIR)/data_streaming
        
        # Source files
        SRC = $(SRC_DIR)/main.cpp $(SRC_DIR)/MBOPublisher.cpp
        
        # Default target
        all: $(BUILD_DIR) $(TARGET)
        
        # Create build directory
        $(BUILD_DIR):
        	mkdir -p $(BUILD_DIR)
        
        # Build the executable
        $(TARGET): $(BUILD_DIR) $(SRC)
        	$(CXX) $(CXXFLAGS) $(SRC) -o $(TARGET) $(LIBS)
        
        # Run the program
        run: $(TARGET)
        	./$(TARGET)
        
        # Clean build
        clean:
        	rm -rf $(BUILD_DIR)
        
        .PHONY: all run clean
    </[Makefile]>
<include>
    <[MBOPublisher.hpp]>
        #include "MBOPublisher.hpp"
        #include <fastdds/dds/topic/TopicDataType.hpp>
        #include <iostream>
        #include <sstream>
        
        // Simple string type for FastDDS
        class StringType : public eprosima::fastdds::dds::TopicDataType {
        public:
            StringType() {
                setName("StringType");
                m_typeSize = 4096;  // max string size
                m_isGetKeyDefined = false;
            }
        
            bool serialize(void* data, eprosima::fastrtps::rtps::SerializedPayload_t* payload) override {
                std::string* str = static_cast<std::string*>(data);
                payload->length = static_cast<uint32_t>(str->size());
                memcpy(payload->data, str->data(), str->size());
                return true;
            }
        
            bool deserialize(eprosima::fastrtps::rtps::SerializedPayload_t* payload, void* data) override {
                std::string* str = static_cast<std::string*>(data);
                str->assign(reinterpret_cast<char*>(payload->data), payload->length);
                return true;
            }
        
            std::function<uint32_t()> getSerializedSizeProvider(void* data) override {
                return [data]() -> uint32_t {
                    return static_cast<uint32_t>(static_cast<std::string*>(data)->size());
                };
            }
        
            void* createData() override {
                return new std::string();
            }
        
            void deleteData(void* data) override {
                delete static_cast<std::string*>(data);
            }
        
            bool getKey(void*, eprosima::fastrtps::rtps::InstanceHandle_t*, bool) override {
                return false;
            }
        };
        
        MBOPublisher::MBOPublisher(const std::string& topic_name)
            : participant(nullptr), publisher(nullptr), topic(nullptr), writer(nullptr) 
        {
            type.reset(new StringType());
        }
        
        MBOPublisher::~MBOPublisher() {
            if (writer) publisher->delete_datawriter(writer);
            if (topic) participant->delete_topic(topic);
            if (publisher) participant->delete_publisher(publisher);
            if (participant) {
                eprosima::fastdds::dds::DomainParticipantFactory::get_instance()->delete_participant(participant);
            }
        }
        
        bool MBOPublisher::init() {
            using namespace eprosima::fastdds::dds;
        
            DomainParticipantQos pqos;
            pqos.name("MBOPublisher_Participant");
            
            participant = DomainParticipantFactory::get_instance()->create_participant(0, pqos);
            if (!participant) {
                std::cerr << "Failed to create participant" << std::endl;
                return false;
            }
        
            // Register the type
            type.register_type(participant);
        
            publisher = participant->create_publisher(PUBLISHER_QOS_DEFAULT, nullptr);
            if (!publisher) {
                std::cerr << "Failed to create publisher" << std::endl;
                return false;
            }
        
            TopicQos tqos = TOPIC_QOS_DEFAULT;
            topic = participant->create_topic("MBOTopic", type.get_type_name(), tqos);
            if (!topic) {
                std::cerr << "Failed to create topic" << std::endl;
                return false;
            }
        
            DataWriterQos wqos = DATAWRITER_QOS_DEFAULT;
            wqos.reliability().kind = RELIABLE_RELIABILITY_QOS;
            
            writer = publisher->create_datawriter(topic, wqos, nullptr);
            if (!writer) {
                std::cerr << "Failed to create datawriter" << std::endl;
                return false;
            }
        
            std::cout << "DDS Publisher initialized successfully" << std::endl;
            return true;
        }
        
        void MBOPublisher::publish(const MBOParsed& record) {
            // Convert MBOParsed to string (CSV format)
            std::ostringstream oss;
            oss << record.ts_event_str << "," 
                << int(record.rtype) << "," 
                << record.publisher_id << "," 
                << record.instrument_id << "," 
                << record.action << "," 
                << record.side << "," 
                << record.price << "," 
                << record.size << "," 
                << int(record.channel_id) << "," 
                << record.order_id << "," 
                << int(record.flags) << "," 
                << record.ts_in_delta << "," 
                << record.sequence << "," 
                << record.symbol << "," 
                << record.datetime;
        
            std::string message = oss.str();
            writer->write(&message);
        }
    </[MBOPublisher.hpp]>
    <[MBOParsed.hpp]>
        #pragma once
        #include <string>
        #include <cstdint>
        
        struct MBOParsed {
            std::string ts_event_str;
            uint8_t  rtype;
            uint16_t publisher_id;
            uint32_t instrument_id;
            char     action;
            char     side;
            double   price;
            uint32_t size;
            uint8_t  channel_id;
            uint64_t order_id;
            uint8_t  flags;
            int32_t  ts_in_delta;
            uint32_t sequence;
            std::string symbol;
            std::string datetime;
        };
    </[MBOParsed.hpp]>
</include>
<src>
    <[main.cpp]>
        #include <iostream>
        #include <fstream>
        #include <sstream>
        #include <iomanip>
        #include <string>
        #include <vector>
        #include <cstdint>
        #include <thread>
        #include <chrono>
        
        #include "MBOParsed.hpp"
        #include "MBOPublisher.hpp"
        
        MBOParsed parseCSVLine(const std::string& line) {
            MBOParsed record{};
            std::stringstream ss(line);
            std::string field;
            std::vector<std::string> fields;
            
            // Split by comma
            while (std::getline(ss, field, ',')) {
                fields.push_back(field);
            }
            
            if (fields.size() >= 15) {
                record.ts_event_str = fields[0];
                record.rtype = static_cast<uint8_t>(std::stoi(fields[1]));
                record.publisher_id = static_cast<uint16_t>(std::stoi(fields[2]));
                record.instrument_id = static_cast<uint32_t>(std::stoul(fields[3]));
                record.action = fields[4][0];
                record.side = fields[5][0];
                record.price = std::stod(fields[6]);
                record.size = static_cast<uint32_t>(std::stoul(fields[7]));
                record.channel_id = static_cast<uint8_t>(std::stoi(fields[8]));
                record.order_id = std::stoull(fields[9]);
                record.flags = static_cast<uint8_t>(std::stoi(fields[10]));
                record.ts_in_delta = std::stoi(fields[11]);
                record.sequence = static_cast<uint32_t>(std::stoul(fields[12]));
                record.symbol = fields[13];
                record.datetime = fields[14];
            }
            
            return record;
        }
        
        void printRecord(const MBOParsed& r) {
            std::cout << std::fixed << std::setprecision(2)
                      << "ts_event=" << r.ts_event_str
                      << " rtype=" << int(r.rtype)
                      << " publisher_id=" << r.publisher_id
                      << " instrument_id=" << r.instrument_id
                      << " action=" << r.action
                      << " side=" << r.side
                      << " price=" << r.price
                      << " size=" << r.size
                      << " channel_id=" << int(r.channel_id)
                      << " order_id=" << r.order_id
                      << " flags=" << int(r.flags)
                      << " ts_in_delta=" << r.ts_in_delta
                      << " sequence=" << r.sequence
                      << " symbol=" << r.symbol
                      << " datetime=" << r.datetime
                      << std::endl;
        }
        
        int main() {
            try {
                std::ifstream file("./data.csv");
                if (!file.is_open()) {
                    std::cerr << "Error: Could not open data.csv" << std::endl;
                    return 1;
                }
        
                std::string line;
                std::vector<MBOParsed> records;
        
                std::getline(file, line); // skip header
                while (std::getline(file, line)) {
                    if (!line.empty()) {
                        records.push_back(parseCSVLine(line));
                    }
                }
                file.close();
        
                std::cout << "Total records loaded: " << records.size() << std::endl;
        
                // Init DDS publisher
                MBOPublisher publisher;
                if (!publisher.init()) {
                    std::cerr << "Failed to initialize DDS publisher" << std::endl;
                    return 1;
                }
        
                for (size_t i = 0; i < records.size(); i++) {
                    if (records[i].ts_in_delta > 0)
                        std::this_thread::sleep_for(std::chrono::microseconds(records[i].ts_in_delta));
        
                    printRecord(records[i]);
        
                    // Publish via FastDDS
                    publisher.publish(records[i]);
                }
        
                std::cout << "\nReplay completed!" << std::endl;
        
            } catch (const std::exception& e) {
                std::cerr << "Error: " << e.what() << std::endl;
                return 1;
            }
        
            return 0;
        }
    </[main.cpp]>
    <[MBOPublisher.cpp]>
        #include "MBOPublisher.hpp"
        
        MBOPublisher::MBOPublisher(const std::string& topic_name)
            : participant(nullptr), publisher(nullptr), topic(nullptr), writer(nullptr) 
        {
            // Empty constructor
        }
        
        MBOPublisher::~MBOPublisher() {
            if (participant) {
                eprosima::fastdds::dds::DomainParticipantFactory::get_instance()->delete_participant(participant);
            }
        }
        
        bool MBOPublisher::init() {
            using namespace eprosima::fastdds::dds;
        
            DomainParticipantQos pqos;
            participant = DomainParticipantFactory::get_instance()->create_participant(0, pqos);
            if (!participant) return false;
        
            publisher = participant->create_publisher(PUBLISHER_QOS_DEFAULT, nullptr);
            if (!publisher) return false;
        
            TopicQos tqos = TOPIC_QOS_DEFAULT;
            topic = participant->create_topic("MBOTopic", "MBOParsed", tqos);
            if (!topic) return false;
        
            writer = publisher->create_datawriter(topic, DATAWRITER_QOS_DEFAULT, nullptr);
            if (!writer) return false;
        
            return true;
        }
        
        void MBOPublisher::publish(const MBOParsed& record) {
            // Convert MBOParsed to string message (simplest way)
            std::ostringstream oss;
            oss << record.ts_event_str << "," 
                << int(record.rtype) << "," 
                << record.publisher_id << "," 
                << record.instrument_id << "," 
                << record.action << "," 
                << record.side << "," 
                << record.price << "," 
                << record.size << "," 
                << int(record.channel_id) << "," 
                << record.order_id << "," 
                << int(record.flags) << "," 
                << record.ts_in_delta << "," 
                << record.sequence << "," 
                << record.symbol << "," 
                << record.datetime;
        
            std::string message = oss.str();
        
            // Send message as a string using FastDDS
            writer->write(&message);
        }
    </[MBOPublisher.cpp]>
</src>
</project_structure>
