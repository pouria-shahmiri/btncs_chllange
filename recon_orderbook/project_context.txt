
    Just use v2 for templates.
    
<project_structure>
    <[Makefile]>
        # Compiler and flags
        CXX = g++
        CXXFLAGS = -Wall -std=c++17 -Iinclude -Iexternal/liquibook/src -pthread
        
        # FastRTPS and FastCDR libraries
        LIBS = -lfastrtps -lfastcdr
        
        # Directories
        BUILD_DIR = build
        SRC_DIR   = src
        EXTERNAL_DIR = external
        
        # Target executable
        TARGET = $(BUILD_DIR)/recon_orderbook
        
        # Source files
        SRC = $(SRC_DIR)/main.cpp \
              $(SRC_DIR)/MBOSubscriber.cpp \
              $(SRC_DIR)/OrderBookManager.cpp
        
        # Default target
        all: check_liquibook $(BUILD_DIR) $(TARGET)
        
        # Check if Liquibook exists
        check_liquibook:
        	@if [ ! -d "$(EXTERNAL_DIR)/liquibook" ]; then \
        		echo "ERROR: Liquibook not found in $(EXTERNAL_DIR)/liquibook"; \
        		echo "Please run: git clone https://github.com/enewhuis/liquibook.git $(EXTERNAL_DIR)/liquibook"; \
        		exit 1; \
        	fi
        
        # Create build directory
        $(BUILD_DIR):
        	mkdir -p $(BUILD_DIR)
        
        # Build the executable
        $(TARGET): $(BUILD_DIR) $(SRC)
        	$(CXX) $(CXXFLAGS) $(SRC) -o $(TARGET) $(LIBS)
        
        # Run the program
        run: $(TARGET)
        	./$(TARGET)
        
        # Clean build
        clean:
        	rm -rf $(BUILD_DIR)
        
        # Setup Liquibook (helper target)
        setup:
        	@echo "Cloning Liquibook..."
        	@mkdir -p $(EXTERNAL_DIR)
        	@if [ ! -d "$(EXTERNAL_DIR)/liquibook" ]; then \
        		git clone https://github.com/enewhuis/liquibook.git $(EXTERNAL_DIR)/liquibook; \
        		echo "Liquibook cloned successfully"; \
        	else \
        		echo "Liquibook already exists"; \
        	fi
        
        .PHONY: all run clean check_liquibook setup
    </[Makefile]>
            <external/liquibook/src/simple>
                <[simple_order.cpp]>
                    // Copyright (c) 2012, 2013 Object Computing, Inc.
                    // All rights reserved.
                    // See the file license.txt for licensing information.
                    #include "simple_order.h"
                    
                    #include <iostream>
                    
                    namespace liquibook { namespace simple {
                    
                    uint32_t SimpleOrder::last_order_id_(0);
                    
                    SimpleOrder::SimpleOrder(
                      bool is_buy,
                      book::Price price,
                      book::Quantity qty,
                      book::Price stop_price,
                      book::OrderConditions conditions)
                    : state_(os_new),
                      is_buy_(is_buy),
                      order_qty_(qty),
                      price_(price),
                      stop_price_(stop_price),
                      conditions_(conditions),
                      filled_qty_(0),
                      filled_cost_(0),
                      order_id_(++last_order_id_)
                    {
                    }
                    
                    const OrderState&
                    SimpleOrder::state() const
                    {
                      return state_;
                    }
                    
                    bool 
                    SimpleOrder::is_buy() const
                    {
                      return is_buy_;
                    }
                    
                    book::Price
                    SimpleOrder::price() const
                    {
                      return price_;
                    }
                    
                    book::Price
                    SimpleOrder::stop_price() const
                    {
                      return stop_price_;
                    }
                    
                    book::OrderConditions
                    SimpleOrder::conditions() const
                    {
                      return conditions_;
                    }
                    
                    bool
                    SimpleOrder::all_or_none() const
                    {
                      return (conditions_ & book::OrderCondition::oc_all_or_none) != 0;
                    }
                    
                    bool
                    SimpleOrder::immediate_or_cancel() const
                    {
                      return (conditions_ & book::OrderCondition::oc_immediate_or_cancel) != 0;
                    }
                    book::Quantity
                    SimpleOrder::order_qty() const
                    {
                      return order_qty_;
                    }
                    
                    book::Quantity
                    SimpleOrder::open_qty() const
                    {
                      // If not completely filled, calculate
                      if (filled_qty_ < order_qty_) {
                        return order_qty_ - filled_qty_;
                      // Else prevent accidental overflow
                      } else {
                        return 0;
                      }
                    }
                    
                    const book::Quantity&
                    SimpleOrder::filled_qty() const
                    {
                      return filled_qty_;
                    }
                    
                    const book::Cost&
                    SimpleOrder::filled_cost() const
                    {
                      return filled_cost_;
                    }
                    
                    void
                    SimpleOrder::fill(book::Quantity fill_qty,
                                      book::Cost fill_cost,
                                      book::FillId /*fill_id*/)
                    {
                      filled_qty_ += fill_qty;
                      filled_cost_ += fill_cost;
                      if (!open_qty()) {
                        state_ = os_complete;
                      }
                    }
                    
                    void
                    SimpleOrder::accept()
                    {
                      if (os_new == state_) {
                        state_ = os_accepted;
                      }
                    }
                    
                    void
                    SimpleOrder::cancel()
                    {
                      if (os_complete != state_) {
                        state_ = os_cancelled;
                      }
                    }
                    
                    void
                    SimpleOrder::replace(book::Quantity size_delta, book::Price new_price)
                    {
                      if (os_accepted == state_) {
                        order_qty_ += size_delta;
                        price_ = new_price;
                      }
                    }
                    
                    } }
                    
                </[simple_order.cpp]>
            </external/liquibook/src/simple>
            <external/liquibook/src/book>
                <[main.cpp]>
                    #include <iostream>
                    #include "version.h"
                    
                    #include "depth_order_book.h"
                    #include "order.h"
                    
                    using namespace liquibook;
                    using namespace book;
                    namespace
                    {
                      // depth order book pulls in all the other header files.
                      // except order.h which is actually a concept.
                      DepthOrderBook<Order *, 5> unusedDepthOrderBook_;
                    }
                    
                    int main(int, const char**)
                    {
                        std::cout << "Liquibook version " << Version::MAJOR << '.' << Version::MINOR << '.' << Version::PATCH 
                          << " (" << Version::RELEASE_DATE << ")\n";
                        std::cout << "Liquibook is a header-only library.\n\n";
                        std::cout << "This executable is a placeholder to make the book header files visible in\n";
                        std::cout << "Visual Studio.  It also lets the compiler to do syntax checking of the header\n";
                        std::cout << "files at build time." << std::endl;
                        return 0;
                    }
                    
                </[main.cpp]>
            </external/liquibook/src/book>
            <external/liquibook/examples/depth_feed_publisher>
                <[depth_feed_publisher.cpp]>
                    #include <iomanip>
                    #include <fstream>
                    #include "depth_feed_publisher.h"
                    #include <Codecs/DataDestination.h>
                    #include <Codecs/XMLTemplateParser.h>
                    #include <Messages/FieldIdentity.h>
                    #include <Messages/FieldSet.h>
                    #include <Messages/FieldSequence.h>
                    #include <Messages/FieldString.h>
                    #include <Messages/FieldUInt8.h>
                    #include <Messages/FieldUInt32.h>
                    #include <Messages/Sequence.h>
                    
                    namespace liquibook { namespace examples { 
                    
                    using namespace QuickFAST::Messages;
                    
                    DepthFeedPublisher::DepthFeedPublisher()
                    : connection_(NULL)
                    {
                    }
                    
                    void
                    DepthFeedPublisher::set_connection(DepthFeedConnection* connection)
                    {
                      connection_ = connection;
                    }
                    
                    void
                    DepthFeedPublisher::on_trade(
                        const book::OrderBook<OrderPtr>* order_book,
                        book::Quantity qty,
                        book::Cost cost)
                    {
                      // Publish trade
                      QuickFAST::Messages::FieldSet message(20);
                      const ExampleOrderBook* exob = 
                              dynamic_cast<const ExampleOrderBook*>(order_book);
                      std::cout << "Got trade for " << exob->symbol() 
                                << " qty " << qty
                                << " cost " << cost << std::endl;
                      build_trade_message(message, exob->symbol(), qty, cost);
                      connection_->send_trade(message);
                    }
                    
                    void
                    DepthFeedPublisher::on_depth_change(
                        const book::DepthOrderBook<OrderPtr>* order_book,
                        const book::DepthOrderBook<OrderPtr>::DepthTracker* tracker)
                    {
                      // Publish changed levels of order book
                      QuickFAST::Messages::FieldSet message(20);
                      const ExampleOrderBook* exob = 
                              dynamic_cast<const ExampleOrderBook*>(order_book);
                      build_depth_message(message, exob->symbol(), tracker, false);
                      if (!connection_->send_incr_update(exob->symbol(), message)) {
                        // Publish all levels of order book
                        QuickFAST::Messages::FieldSet full_message(20);
                        build_depth_message(full_message, exob->symbol(), tracker, true);
                        connection_->send_full_update(exob->symbol(), full_message);
                      }
                    }
                     
                    void
                    DepthFeedPublisher::build_trade_message(
                        QuickFAST::Messages::FieldSet& message,
                        const std::string& symbol,
                        book::Quantity qty,
                        book::Cost cost)
                    {
                      message.addField(id_timestamp_, FieldUInt32::create(time_stamp()));
                      message.addField(id_symbol_, FieldString::create(symbol));
                      message.addField(id_qty_, FieldUInt32::create(qty));
                      message.addField(id_cost_, FieldUInt32::create(cost));
                    }
                    
                    void
                    DepthFeedPublisher::build_depth_message(
                        QuickFAST::Messages::FieldSet& message,
                        const std::string& symbol,
                        const book::DepthOrderBook<OrderPtr>::DepthTracker* tracker,
                        bool full_message)
                    {
                      size_t bid_count(0), ask_count(0);
                    
                      message.addField(id_timestamp_, FieldUInt32::create(time_stamp()));
                      message.addField(id_symbol_, FieldString::create(symbol));
                    
                      // Build the changed levels
                      book::ChangeId last_published_change = tracker->last_published_change();
                      
                      // Build changed bids
                      {
                        SequencePtr bids(new Sequence(id_bids_length_, 1));
                        int index = 0;
                        const book::DepthLevel* bid = tracker->bids();
                        // Create sequence of bids
                        while (true) {
                          if (full_message || bid->changed_since(last_published_change)) {
                            build_depth_level(bids, bid, index);
                            ++bid_count;
                          }
                          ++index;
                          if (bid == tracker->last_bid_level()) {
                            break;
                          } else {
                            ++bid;
                          }
                        }
                        message.addField(id_bids_, FieldSequence::create(bids));
                      }
                    
                      // Build changed asks
                      {
                        SequencePtr asks(new Sequence(id_asks_length_, 1));
                        int index = 0;
                        const book::DepthLevel* ask = tracker->asks();
                        // Create sequence of asks
                        while (true) {
                          if (full_message || ask->changed_since(last_published_change)) {
                            build_depth_level(asks, ask, index);
                            ++ask_count;
                          }
                          ++index;
                          if (ask == tracker->last_ask_level()) {
                            break;
                          } else {
                            ++ask;
                          }
                        }
                        message.addField(id_asks_, FieldSequence::create(asks));
                      }
                      std::cout << "Encoding " << (full_message ? "full" : "incr")
                                << " depth message for symbol " << symbol 
                                << " with " << bid_count << " bids, "
                                << ask_count << " asks" << std::endl;
                    }
                    
                    void
                    DepthFeedPublisher::build_depth_level(
                        QuickFAST::Messages::SequencePtr& level_seq,
                        const book::DepthLevel* level,
                        int level_index)
                    {
                      FieldSetPtr level_fields(new FieldSet(4));
                      level_fields->addField(id_level_num_, FieldUInt8::create(level_index));
                      level_fields->addField(id_order_count_, 
                                             FieldUInt32::create(level->order_count()));
                      level_fields->addField(id_price_,
                                             FieldUInt32::create(level->price()));
                      level_fields->addField(id_size_,
                                             FieldUInt32::create(level->aggregate_qty()));
                      level_seq->addEntry(level_fields);
                    }
                    
                    uint32_t
                    DepthFeedPublisher::time_stamp()
                    {
                      time_t now;
                      time(&now);
                      return (uint32_t) now;
                    }
                    
                    } } // End namespace
                </[depth_feed_publisher.cpp]>
                <[depth_feed_subscriber.cpp]>
                    
                    #include "order.h"
                    #include <boost/scoped_ptr.hpp>
                    #include "depth_feed_subscriber.h"
                    #include <Codecs/DataSourceBuffer.h>
                    #include <Codecs/GenericMessageBuilder.h>
                    #include <Codecs/SingleMessageConsumer.h>
                    #include <Messages/MessageAccessor.h>
                    
                    namespace liquibook { namespace examples {
                    
                    const uint64_t DepthFeedSubscriber::MSG_TYPE_DEPTH(11);
                    const uint64_t DepthFeedSubscriber::MSG_TYPE_TRADE(22);
                    
                    using QuickFAST::ValueType;
                    
                    DepthFeedSubscriber::DepthFeedSubscriber(
                            const QuickFAST::Codecs::TemplateRegistryPtr& templates)
                    : decoder_(templates),
                      expected_seq_(1)
                    {
                    }
                    
                    void
                    DepthFeedSubscriber::handle_reset()
                    {
                      expected_seq_ = 1;
                    }
                    
                    bool
                    DepthFeedSubscriber::handle_message(BufferPtr& bp, size_t bytes_transferred)
                    {
                      // Decode the message
                      QuickFAST::Codecs::DataSourceBuffer source(bp->c_array(), bytes_transferred);
                      QuickFAST::Codecs::SingleMessageConsumer consumer;
                      QuickFAST::Codecs::GenericMessageBuilder builder(consumer);
                      decoder_.decodeMessage(source, builder);
                      QuickFAST::Messages::Message& msg(consumer.message());
                    
                      // Examine message contents
                      uint64_t seq_num, msg_type, timestamp;
                      const QuickFAST::StringBuffer* string_buffer;
                      std::string symbol;
                      if (!msg.getUnsignedInteger(id_seq_num_, ValueType::UINT32, seq_num)) {
                        std::cout << "Could not get seq num from msg" << std::endl;
                        return false;
                      }
                      if (seq_num != expected_seq_) {
                        std::cout << "ERROR: Got Seq num " << seq_num << ", expected " 
                                  << expected_seq_ << std::endl;
                        return false;
                      }
                      if (!msg.getUnsignedInteger(id_msg_type_, ValueType::UINT32, msg_type)) {
                        std::cout << "Could not get msg type from msg" << std::endl;
                        return false;
                      }
                      if (!msg.getString(id_symbol_, ValueType::ASCII, string_buffer)) {
                        std::cout << "Could not get symbol from msg" << std::endl;
                        return false;
                      }
                      if (!msg.getUnsignedInteger(id_timestamp_, ValueType::UINT32, timestamp)) {
                        std::cout << "Could not get timestamp from msg" << std::endl;
                        return false;
                      }
                      bool result = false;
                      symbol = (std::string)*string_buffer;
                      switch (msg_type) {
                      case MSG_TYPE_DEPTH:
                        result = handle_depth_message(symbol, seq_num, timestamp, msg);
                        break;
                      case MSG_TYPE_TRADE:
                        result = handle_trade_message(symbol, seq_num, timestamp, msg);
                        break;
                      default:
                        std::cout << "ERROR: Unknown message type " << msg_type 
                                  << " seq num " << seq_num << std::endl;
                        return false;
                      }
                      ++expected_seq_;
                      return result;
                    }
                    
                    void
                    DepthFeedSubscriber::log_depth(book::Depth<5>& depth)
                    {
                      book::DepthLevel* bid = depth.bids();
                      book::DepthLevel* ask = depth.asks();
                      printf("----------BID----------    ----------ASK----------\n");
                      while (bid || ask) {
                        if (bid && bid->order_count()) {
                          printf("%8.2f %9d [%2d]", 
                                 (double)bid->price() / Order::precision_,
                                 bid->aggregate_qty(), bid->order_count());
                          if (bid == depth.last_bid_level()) {
                            bid = NULL;
                          } else {
                            ++bid;
                          }
                        } else {
                          // Blank lines
                          printf("                       ");
                          bid = NULL;
                        }
                    
                        if (ask && ask->order_count()) {
                          printf("    %8.2f %9d [%2d]\n",
                                 (double)ask->price() / Order::precision_,
                                 ask->aggregate_qty(), ask->order_count());
                          if (ask == depth.last_ask_level()) {
                            ask = NULL;
                          } else {
                            ++ask;
                          }
                        } else {
                          // Newline
                          printf("\n");
                          ask = NULL;
                        }
                      }
                    }
                    
                    bool
                    DepthFeedSubscriber::handle_depth_message(
                      const std::string& symbol,
                      uint64_t& seq_num,
                      uint64_t& timestamp,
                      QuickFAST::Messages::Message& msg)
                    {
                      size_t bids_length, asks_length;
                      std::cout << timestamp
                                << " Got depth msg " << seq_num 
                                << " for symbol " << symbol << std::endl;
                    
                      // Create or find depth
                      std::pair<DepthMap::iterator, bool> results = depth_map_.insert(
                          std::make_pair(symbol, book::Depth<5>()));
                      book::Depth<5>& depth = results.first->second;
                    
                      if (msg.getSequenceLength(id_bids_, bids_length)) {
                        for (size_t i = 0; i < bids_length; ++i) {
                          const QuickFAST::Messages::MessageAccessor* accessor;
                          if (msg.getSequenceEntry(id_bids_, i, accessor)) {
                            uint64_t level_num, price, order_count, aggregate_qty;
                            if (!accessor->getUnsignedInteger(id_level_num_, ValueType::UINT8,
                                                             level_num)) {
                              std::cout << "Could not get Bid level from depth msg" << std::endl;
                              return false;
                            }
                            if (!accessor->getUnsignedInteger(id_price_, ValueType::UINT32,
                                                             price)) {
                              std::cout << "Could not get Bid price from depth msg" << std::endl;
                              return false;
                            }
                            if (!accessor->getUnsignedInteger(id_order_count_, ValueType::UINT32,
                                                             order_count)) {
                              std::cout << "Could not get Bid count from depth msg" << std::endl;
                              return false;
                            }
                            if (!accessor->getUnsignedInteger(id_size_, ValueType::UINT32,
                                                             aggregate_qty)) {
                              std::cout << "Could not get Bid agg qty  from depth msg" << std::endl;
                              return false;
                            }
                    
                            book::DepthLevel& level = depth.bids()[level_num];
                            level.set(book::Price(price), book::Quantity(aggregate_qty), uint32_t(order_count));
                    
                          } else {
                            std::cout << "Failed to get bid " << i << std::endl;
                            return false;
                          }
                          msg.endSequenceEntry(id_bids_, i, accessor);
                        }
                      }
                      if (msg.getSequenceLength(id_asks_, asks_length)) {
                        for (size_t i = 0; i < asks_length; ++i) {
                          const QuickFAST::Messages::MessageAccessor* accessor;
                          if (msg.getSequenceEntry(id_asks_, i, accessor)) {
                            uint64_t level_num, price, order_count, aggregate_qty;
                            if (!accessor->getUnsignedInteger(id_level_num_, ValueType::UINT8,
                                                             level_num)) {
                              std::cout << "Could not get Ask level from depth msg " << std::endl;
                              return false;
                            }
                            if (!accessor->getUnsignedInteger(id_price_, ValueType::UINT32,
                                                             price)) {
                              std::cout << "Could not get Ask price  from depth msg" << std::endl;
                              return false;
                            }
                            if (!accessor->getUnsignedInteger(id_order_count_, ValueType::UINT32,
                                                             order_count)) {
                              std::cout << "Could not get Ask count from depth msg " << std::endl;
                              return false;
                            }
                            if (!accessor->getUnsignedInteger(id_size_, ValueType::UINT32,
                                                             aggregate_qty)) {
                              std::cout << "Could not get Ask agg qty from depth msg " << std::endl;
                              return false;
                            }
                    
                            book::DepthLevel& level = depth.asks()[level_num];
                            level.set(book::Price(price), book::Quantity(aggregate_qty), uint32_t(order_count));
                    
                          } else {
                            std::cout << "Failed to get ask " << i << std::endl;
                            return false;
                          }
                          msg.endSequenceEntry(id_asks_, i, accessor);
                        }
                      }
                      log_depth(depth);
                      return true;
                    }
                    
                    bool
                    DepthFeedSubscriber::handle_trade_message(
                      const std::string& symbol,
                      uint64_t& seq_num,
                      uint64_t& timestamp,
                      QuickFAST::Messages::Message& msg)
                    {
                      uint64_t qty, cost;
                      // Get trade fields
                      if (!msg.getUnsignedInteger(id_qty_, ValueType::UINT32, qty)) {
                        std::cout << "Could not qty from trade msg" << std::endl;
                        return false;
                      }
                      if (!msg.getUnsignedInteger(id_cost_, ValueType::UINT32, cost)) {
                        std::cout << "Could not get cost from trade msg" << std::endl;
                        return false;
                      }
                    
                      double price = (double) cost / (qty * Order::precision_);
                      std::cout << timestamp
                                << " Got trade msg " << seq_num 
                                << " for symbol " << symbol 
                                << ": " << qty << "@" << price
                                << std::endl;
                    
                      return true;
                    }
                    
                    } }
                </[depth_feed_subscriber.cpp]>
                <[template_consumer.cpp]>
                    
                    #include <boost/cstdint.hpp>
                    #include "template_consumer.h"
                    #include <fstream>
                    #include <Codecs/XMLTemplateParser.h>
                    
                    namespace liquibook { namespace examples {
                    
                    using namespace QuickFAST::Messages;
                    
                    const FieldIdentity TemplateConsumer::id_seq_num_("SequenceNumber");
                    
                    const FieldIdentity TemplateConsumer::id_msg_type_("MessageType");
                    
                    const FieldIdentity TemplateConsumer::id_timestamp_("Timestamp");
                    
                    const FieldIdentity TemplateConsumer::id_symbol_("Symbol");
                    
                    const FieldIdentity TemplateConsumer::id_bids_("Bids");
                    
                    const FieldIdentity TemplateConsumer::id_bids_length_("BidsLength");
                    
                    const FieldIdentity TemplateConsumer::id_asks_("Asks");
                    
                    const FieldIdentity TemplateConsumer::id_asks_length_("AsksLength");
                    
                    const FieldIdentity TemplateConsumer::id_level_num_("LevelNum");
                    
                    const FieldIdentity TemplateConsumer::id_order_count_("OrderCount");
                    
                    const FieldIdentity TemplateConsumer::id_size_("AggregateQty");
                    
                    const FieldIdentity TemplateConsumer::id_price_("Price");
                    
                    const FieldIdentity TemplateConsumer::id_qty_("Quantity");
                    
                    const FieldIdentity TemplateConsumer::id_cost_("Cost");
                    
                    QuickFAST::Codecs::TemplateRegistryPtr 
                    TemplateConsumer::parse_templates(const std::string& template_filename)
                    {
                      std::ifstream template_stream(template_filename.c_str());
                      QuickFAST::Codecs::XMLTemplateParser parser;
                      return parser.parse(template_stream);
                    }
                    
                    } } 
                </[template_consumer.cpp]>
                <[example_order_book.cpp]>
                    #include "example_order_book.h"
                    
                    namespace liquibook { namespace examples {
                    
                    ExampleOrderBook::ExampleOrderBook(const std::string& symbol)
                    : symbol_(symbol)
                    {
                    }
                    
                    const std::string&
                    ExampleOrderBook::symbol() const
                    {
                      return symbol_;
                    }
                    
                    } } // End namespace
                    
                </[example_order_book.cpp]>
                <[exchange.cpp]>
                    #include "exchange.h"
                    
                    namespace liquibook { namespace examples {
                    
                    Exchange::Exchange(ExampleOrderBook::TypedDepthListener* depth_listener,
                                       ExampleOrderBook::TypedTradeListener* trade_listener)
                    : depth_listener_(depth_listener),
                      trade_listener_(trade_listener)
                    {
                    }
                    
                    void
                    Exchange::add_order_book(const std::string& sym)
                    {
                      std::pair<OrderBookMap::iterator, bool> result;
                      result = order_books_.insert(std::make_pair(sym, ExampleOrderBook(sym)));
                      result.first->second.set_depth_listener(depth_listener_);
                      result.first->second.set_trade_listener(trade_listener_);
                    }
                    
                    void
                    Exchange::add_order(const std::string& symbol, OrderPtr& order)
                    {
                      OrderBookMap::iterator order_book = order_books_.find(symbol);
                      if (order_book != order_books_.end()) {
                        order_book->second.add(order);
                        order_book->second.perform_callbacks();
                      }
                    }
                    
                    } } // End namespace
                </[exchange.cpp]>
                <[order.cpp]>
                    #include "order.h"
                    
                    namespace liquibook { namespace examples {
                    
                    const uint8_t Order::precision_(100);
                    
                    Order::Order(bool buy, const double& price, book::Quantity qty)
                    : is_buy_(buy),
                      price_(price),
                      qty_(qty)
                    {
                    }
                    
                    bool
                    Order::is_buy() const
                    {
                      return is_buy_;
                    }
                    
                    book::Quantity
                    Order::order_qty() const
                    {
                      return qty_;
                    }
                    
                    book::Price
                    Order::price() const
                    {
                      return book::Price(price_ * precision_);
                    }
                    
                    } } // End namespace
                    
                </[order.cpp]>
                <[publisher_main.cpp]>
                    
                    #include <boost/thread.hpp>
                    #include "exchange.h"
                    #include "depth_feed_publisher.h"
                    #include "depth_feed_connection.h"
                    #include "order.h"
                    
                    #include <cstdlib>
                    #include <iostream>
                    
                    using namespace liquibook;
                    
                    struct SecurityInfo {
                      std::string symbol;
                      double ref_price;
                      SecurityInfo(const char* sym, double price)
                      : symbol(sym),
                        ref_price(price)
                      {
                      }
                    };
                    
                    typedef std::vector<SecurityInfo> SecurityVector;
                    
                    void create_securities(SecurityVector& securities);
                    void populate_exchange(examples::Exchange& exchange, 
                                           const SecurityVector& securities);
                    void generate_orders(examples::Exchange& exchange, 
                                         const SecurityVector& securities);
                    
                    int main(int argc, const char* argv[])
                    {
                      try
                      {
                        // Feed connection
                        examples::DepthFeedConnection connection(argc, argv);
                    
                        // Open connection in background thread
                        connection.accept();
                        boost::function<void ()> acceptor(
                            boost::bind(&examples::DepthFeedConnection::run, &connection));
                        boost::thread acceptor_thread(acceptor);
                      
                        // Create feed publisher
                        examples::DepthFeedPublisher feed;
                        feed.set_connection(&connection);
                    
                        // Create exchange
                        examples::Exchange exchange(&feed, &feed);
                    
                        // Create securities
                        SecurityVector securities;
                        create_securities(securities);
                    
                        // Populate exchange with securities
                        populate_exchange(exchange, securities);
                      
                        // Generate random orders
                        generate_orders(exchange, securities);
                      }
                      catch (const std::exception & ex)
                      {
                        std::cerr << "Exception caught at main level: " << ex.what() << std::endl;
                        return -1;
                      }
                    
                      return 0;
                    }
                    
                    void
                    create_securities(SecurityVector& securities) {
                      securities.push_back(SecurityInfo("AAPL", 436.36));
                      securities.push_back(SecurityInfo("ADBE", 45.06));
                      securities.push_back(SecurityInfo("ADI", 43.93));
                      securities.push_back(SecurityInfo("ADP", 67.09));
                      securities.push_back(SecurityInfo("ADSK", 38.34));
                      securities.push_back(SecurityInfo("AKAM", 43.65));
                      securities.push_back(SecurityInfo("ALTR", 31.90));
                      securities.push_back(SecurityInfo("ALXN", 96.28));
                      securities.push_back(SecurityInfo("AMAT", 14.623));
                      securities.push_back(SecurityInfo("AMGN", 104.88));
                      securities.push_back(SecurityInfo("AMZN", 247.74));
                      securities.push_back(SecurityInfo("ATVI", 14.69));
                      securities.push_back(SecurityInfo("AVGO", 31.38));
                      securities.push_back(SecurityInfo("BBBY", 68.81));
                      securities.push_back(SecurityInfo("BIDU", 85.09));
                      securities.push_back(SecurityInfo("BIIB", 214.89));
                      securities.push_back(SecurityInfo("BMC", 45.325));
                      securities.push_back(SecurityInfo("BRCM", 35.60));
                      securities.push_back(SecurityInfo("CA", 26.97));
                      securities.push_back(SecurityInfo("CELG", 116.901));
                      securities.push_back(SecurityInfo("CERN", 95.24));
                      securities.push_back(SecurityInfo("CHKP", 46.43));
                      securities.push_back(SecurityInfo("CHRW", 58.89));
                      securities.push_back(SecurityInfo("CMCSA", 41.99));
                      securities.push_back(SecurityInfo("COST", 108.16));
                      securities.push_back(SecurityInfo("CSCO", 20.425));
                      securities.push_back(SecurityInfo("CTRX", 57.419));
                      securities.push_back(SecurityInfo("CTSH", 63.62));
                      securities.push_back(SecurityInfo("CTXS", 62.38));
                      securities.push_back(SecurityInfo("DELL", 13.33));
                      securities.push_back(SecurityInfo("DISCA", 78.18));
                      securities.push_back(SecurityInfo("DLTR", 47.91));
                      securities.push_back(SecurityInfo("DTV", 56.56));
                      securities.push_back(SecurityInfo("EBAY", 52.215));
                      securities.push_back(SecurityInfo("EQIX", 217.015));
                      securities.push_back(SecurityInfo("ESRX", 59.26));
                      securities.push_back(SecurityInfo("EXPD", 35.03));
                      securities.push_back(SecurityInfo("EXPE", 55.15));
                      securities.push_back(SecurityInfo("FAST", 48.13));
                      securities.push_back(SecurityInfo("FB", 27.52));
                      securities.push_back(SecurityInfo("FFIV", 74.11));
                      securities.push_back(SecurityInfo("FISV", 87.58));
                      securities.push_back(SecurityInfo("FOSL", 95.09));
                      securities.push_back(SecurityInfo("GILD", 50.06));
                      securities.push_back(SecurityInfo("GOLD", 78.681));
                      securities.push_back(SecurityInfo("GOOG", 817.08));
                      securities.push_back(SecurityInfo("GRMN", 33.33));
                      securities.push_back(SecurityInfo("HSIC", 89.44));
                      securities.push_back(SecurityInfo("INTC", 23.9673));
                      securities.push_back(SecurityInfo("INTU", 60.15));
                      securities.push_back(SecurityInfo("ISRG", 492.3358));
                      securities.push_back(SecurityInfo("KLAC", 53.83));
                      securities.push_back(SecurityInfo("KRFT", 50.9001));
                      securities.push_back(SecurityInfo("LBTYA", 73.99));
                      securities.push_back(SecurityInfo("LIFE", 73.59));
                      securities.push_back(SecurityInfo("LINTA", 21.44));
                      securities.push_back(SecurityInfo("LLTC", 36.25));
                      securities.push_back(SecurityInfo("MAT", 44.99));
                      securities.push_back(SecurityInfo("MCHP", 36.1877));
                      securities.push_back(SecurityInfo("MDLZ", 31.58));
                      securities.push_back(SecurityInfo("MNST", 55.75));
                      securities.push_back(SecurityInfo("MSFT", 32.75));
                      securities.push_back(SecurityInfo("MU", 9.19));
                      securities.push_back(SecurityInfo("MXIM", 30.59));
                      securities.push_back(SecurityInfo("MYL", 28.90));
                      securities.push_back(SecurityInfo("NTAP", 34.17));
                      securities.push_back(SecurityInfo("NUAN", 18.89));
                      securities.push_back(SecurityInfo("NVDA", 13.7761));
                      securities.push_back(SecurityInfo("NWSA", 31.12));
                      securities.push_back(SecurityInfo("ORCL", 33.19));
                      securities.push_back(SecurityInfo("ORLY", 107.58));
                      securities.push_back(SecurityInfo("PAYX", 36.32));
                      securities.push_back(SecurityInfo("PCAR", 49.52));
                      securities.push_back(SecurityInfo("PCLN", 697.62));
                      securities.push_back(SecurityInfo("PRGO", 119.00));
                      securities.push_back(SecurityInfo("QCOM", 61.925));
                      securities.push_back(SecurityInfo("REGN", 242.49));
                      securities.push_back(SecurityInfo("ROST", 65.20));
                      securities.push_back(SecurityInfo("SBAC", 78.76));
                      securities.push_back(SecurityInfo("SBUX", 60.07));
                      securities.push_back(SecurityInfo("SHLD", 49.989));
                      securities.push_back(SecurityInfo("SIAL", 77.95));
                      securities.push_back(SecurityInfo("SIRI", 3.36));
                      securities.push_back(SecurityInfo("SNDK", 51.23));
                      securities.push_back(SecurityInfo("SPLS", 13.07));
                      securities.push_back(SecurityInfo("SRCL", 108.15));
                      securities.push_back(SecurityInfo("STX", 36.82));
                      securities.push_back(SecurityInfo("SYMC", 24.325));
                      securities.push_back(SecurityInfo("TXN", 36.28));
                      securities.push_back(SecurityInfo("VIAB", 66.295));
                      securities.push_back(SecurityInfo("VMED", 49.56));
                      securities.push_back(SecurityInfo("VOD", 30.49));
                      securities.push_back(SecurityInfo("VRSK", 61.1728));
                      securities.push_back(SecurityInfo("VRTX", 77.255));
                      securities.push_back(SecurityInfo("WDC", 54.76));
                      securities.push_back(SecurityInfo("WFM", 89.35));
                      securities.push_back(SecurityInfo("WYNN", 136.33));
                      securities.push_back(SecurityInfo("XLNX", 37.59));
                      securities.push_back(SecurityInfo("XRAY", 42.26));
                      securities.push_back(SecurityInfo("YHOO", 24.32));
                    }
                    
                    void
                    populate_exchange(examples::Exchange& exchange, const SecurityVector& securities) {
                      SecurityVector::const_iterator sec;
                      for (sec = securities.begin(); sec != securities.end(); ++sec) {
                        exchange.add_order_book(sec->symbol);
                      }
                    }
                    
                    void
                    generate_orders(examples::Exchange& exchange, const SecurityVector& securities) {
                      time_t now;
                      time(&now);
                      std::srand(uint32_t(now));
                    
                      size_t num_securities = securities.size();
                      while (true) {
                        // which security
                        size_t index = std::rand() % num_securities;
                        const SecurityInfo& sec = securities[index];
                        // side
                        bool is_buy = (std::rand() % 2) != 0;
                        // price
                        uint32_t price_base = uint32_t(sec.ref_price * 100);
                        uint32_t delta_range = price_base / 50;  // +/- 2% of base
                        int32_t delta = std::rand() % delta_range;
                        delta -= (delta_range / 2);
                        double price = double (price_base + delta) / 100;
                    
                        // qty
                        book::Quantity qty = (std::rand() % 10 + 1) * 100;
                    
                        // order
                        examples::OrderPtr order(new examples::Order(is_buy, price, qty));
                    
                        // add order
                        exchange.add_order(sec.symbol, order);
                    
                        // Wait for eyes to read
                        sleep(1);
                      }
                    }
                </[publisher_main.cpp]>
                <[subscriber_main.cpp]>
                    
                    #include <boost/bind.hpp>
                    #include "depth_feed_connection.h"
                    #include "depth_feed_subscriber.h"
                    
                    int main(int argc, const char* argv[])
                    {
                      try
                      {
                        // Create the connection
                        liquibook::examples::DepthFeedConnection connection(argc, argv);
                    
                        // Create feed subscriber
                        liquibook::examples::DepthFeedSubscriber feed(connection.get_templates());
                    
                        // Set up handlers
                        liquibook::examples::MessageHandler msg_handler =
                            boost::bind(&liquibook::examples::DepthFeedSubscriber::handle_message,
                                        &feed, _1, _2);
                        liquibook::examples::ResetHandler reset_handler =
                            boost::bind(&liquibook::examples::DepthFeedSubscriber::handle_reset,
                                        &feed);
                        connection.set_message_handler(msg_handler);
                        connection.set_reset_handler(reset_handler);
                    
                        // Connect to server
                        connection.connect();
                        connection.run();
                      }
                      catch (const std::exception & ex)
                      {
                        std::cerr << "Exception caught at main level: " << ex.what() << std::endl;
                        return -1;
                      }
                      return 0;
                    }
                </[subscriber_main.cpp]>
                <[depth_feed_connection.cpp]>
                    #include "depth_feed_connection.h"
                    #include <iomanip>
                    #include <boost/bind.hpp>
                    #include "template_consumer.h"
                    #include <Codecs/DataDestination.h>
                    #include <Messages/FieldSet.h>
                    #include <Messages/FieldUInt32.h>
                    
                    using namespace boost::asio::ip;
                    
                    namespace liquibook { namespace examples {
                    
                    QuickFAST::template_id_t DepthFeedSession::TID_TRADE_MESSAGE(1);
                    QuickFAST::template_id_t DepthFeedSession::TID_DEPTH_MESSAGE(2);
                    
                    DepthFeedSession::DepthFeedSession(
                        boost::asio::io_service& ios,
                        DepthFeedConnection* connection,
                        QuickFAST::Codecs::TemplateRegistryPtr& templates)
                    : connected_(false),
                      seq_num_(0),
                      ios_(ios),
                      socket_(ios),
                      connection_(connection),
                      encoder_(templates)
                    {
                    }
                    
                    void
                    DepthFeedSession::send_trade(QuickFAST::Messages::FieldSet& message)
                    {
                      // Add or update sequence number in message
                      set_sequence_num(message);
                                                
                      std::cout << "sending trade message with " << message.size() << " fields" << std::endl;
                    
                      QuickFAST::Codecs::DataDestination dest;
                      encoder_.encodeMessage(dest, TID_TRADE_MESSAGE, message);
                      WorkingBufferPtr wb = connection_->reserve_send_buffer();
                      dest.toWorkingBuffer(*wb);
                    
                      // Perform the send
                      SendHandler send_handler = boost::bind(&DepthFeedSession::on_send,
                                                             this, wb, _1, _2);
                      boost::asio::const_buffers_1 buffer(
                          boost::asio::buffer(wb->begin(), wb->size()));
                      socket_.async_send(buffer, 0, send_handler);
                    }
                    
                    bool
                    DepthFeedSession::send_incr_update(const std::string& symbol,
                                                       QuickFAST::Messages::FieldSet& message)
                    {
                      bool sent = false;
                      // If the session has been started for this symbol
                      if (sent_symbols_.find(symbol) != sent_symbols_.end()) {
                        QuickFAST::Codecs::DataDestination dest;
                        // Add or update sequence number in message
                        set_sequence_num(message);
                        encoder_.encodeMessage(dest, TID_DEPTH_MESSAGE, message);
                        WorkingBufferPtr wb = connection_->reserve_send_buffer();
                        dest.toWorkingBuffer(*wb);
                        SendHandler send_handler = boost::bind(&DepthFeedSession::on_send,
                                                               this, wb, _1, _2);
                        boost::asio::const_buffers_1 buffer(
                            boost::asio::buffer(wb->begin(), wb->size()));
                        socket_.async_send(buffer, 0, send_handler);
                        sent = true;
                      }
                      return sent;
                    }
                    
                    void
                    DepthFeedSession::send_full_update(const std::string& symbol,
                                                       QuickFAST::Messages::FieldSet& message)
                    {
                      // Mark this symbols as sent
                      std::pair<StringSet::iterator, bool> result = sent_symbols_.insert(symbol);
                    
                      // If this symbol is new for the session
                      if (result.second) {
                        QuickFAST::Codecs::DataDestination dest;
                        // Add or update sequence number in message
                        set_sequence_num(message);
                        encoder_.encodeMessage(dest, TID_DEPTH_MESSAGE, message);
                        WorkingBufferPtr wb = connection_->reserve_send_buffer();
                        dest.toWorkingBuffer(*wb);
                    
                        // Perform the send
                        SendHandler send_handler = boost::bind(&DepthFeedSession::on_send,
                                                               this, wb, _1, _2);
                        boost::asio::const_buffers_1 buffer(
                            boost::asio::buffer(wb->begin(), wb->size()));
                        socket_.async_send(buffer, 0, send_handler);
                      }
                    }
                    
                    void
                    DepthFeedSession::set_sequence_num(QuickFAST::Messages::FieldSet& message)
                    {
                      // Create the field
                      QuickFAST::Messages::FieldCPtr value = 
                          QuickFAST::Messages::FieldUInt32::create(++seq_num_);
                      // Update the sequence number
                      if (!message.replaceField(TemplateConsumer::id_seq_num_, value)) {
                        // Not found, add the sequence number
                        message.addField(TemplateConsumer::id_seq_num_, value);
                      }
                    }
                    
                    void
                    DepthFeedSession::on_send(WorkingBufferPtr wb,
                                              const boost::system::error_code& error,
                                              std::size_t bytes_transferred)
                    {
                      if (error) {
                        std::cout << "Error " << error << " sending message" << std::endl;
                        connected_ = false;
                      }
                    
                      // Keep buffer for later
                      connection_->on_send(wb, error, bytes_transferred);
                    }
                    
                    DepthFeedConnection::DepthFeedConnection(int argc, const char* argv[])
                    : template_filename_(template_file_from_args(argc, argv)),
                      host_(host_from_args(argc, argv)),
                      port_(port_from_args(argc, argv)),
                      templates_(TemplateConsumer::parse_templates(template_filename_)),
                      socket_(ios_)
                    {
                    }
                    
                    void
                    DepthFeedConnection::connect()
                    {
                      std::cout << "Connecting to feed" << std::endl;
                      tcp::endpoint endpoint(address::from_string(host_), port_);
                      socket_.async_connect(endpoint, boost::bind(&DepthFeedConnection::on_connect,
                                                                  this, _1));
                    }
                    
                    void
                    DepthFeedConnection::accept()
                    {
                      if (!acceptor_) {
                        acceptor_.reset(new tcp::acceptor(ios_));
                        tcp::endpoint endpoint(tcp::v4(), port_);
                        acceptor_->open(endpoint.protocol());
                        boost::system::error_code ec;
                        acceptor_->set_option(boost::asio::socket_base::reuse_address(true), ec);
                        acceptor_->bind(endpoint);
                        acceptor_->listen();
                      }
                      SessionPtr session(new DepthFeedSession(ios_, this, templates_));
                      acceptor_->async_accept(
                          session->socket(), 
                          boost::bind(&DepthFeedConnection::on_accept, this, session, _1));
                    }
                    
                    void
                    DepthFeedConnection::run()
                    {
                    std::cout << "DepthFeedConnection::run()" << std::endl;
                      // Keep on running
                      work_ptr_.reset(new boost::asio::io_service::work(ios_));
                      ios_.run();
                    }
                    
                    void
                    DepthFeedConnection::set_message_handler(MessageHandler handler)
                    {
                      msg_handler_ = handler;
                    }
                    
                    void
                    DepthFeedConnection::set_reset_handler(ResetHandler handler)
                    {
                      reset_handler_ = handler;
                    }
                    
                    BufferPtr
                    DepthFeedConnection::reserve_recv_buffer()
                    {
                      if (unused_recv_buffers_.empty()) {
                        return BufferPtr(new Buffer());
                      } else {
                        BufferPtr bp = unused_recv_buffers_.front();
                        unused_recv_buffers_.pop_front();
                        return bp;
                      }
                    }
                    
                    WorkingBufferPtr
                    DepthFeedConnection::reserve_send_buffer()
                    {
                      if (unused_send_buffers_.empty()) {
                        return WorkingBufferPtr(new QuickFAST::WorkingBuffer());
                      } else {
                        WorkingBufferPtr wb = unused_send_buffers_.front();
                        unused_send_buffers_.pop_front();
                        return wb;
                      }
                    }
                    
                    void
                    DepthFeedConnection::send_trade(QuickFAST::Messages::FieldSet& message)
                    {
                      // For each session
                      Sessions::iterator session;
                      for (session = sessions_.begin(); session != sessions_.end(); ) {
                        // If the session is connected
                        if ((*session)->connected()) {
                          // conditionally send on that session
                          (*session)->send_trade(message);
                          ++session;
                        } else {
                          // Remove the session
                          session = sessions_.erase(session);
                        }
                      }
                    }
                    
                    bool
                    DepthFeedConnection::send_incr_update(const std::string& symbol,
                                                          QuickFAST::Messages::FieldSet& message)
                    {
                      bool none_new = true;
                      // For each session
                      Sessions::iterator session;
                      for (session = sessions_.begin(); session != sessions_.end(); ) {
                        // If the session is connected
                        if ((*session)->connected()) {
                          // send on that session
                          if (!(*session)->send_incr_update(symbol, message)) {
                            none_new = false;
                          }
                          ++session;
                        } else {
                          // Remove the session
                          session = sessions_.erase(session);
                        }
                      }
                      return none_new;
                    }
                    
                    void
                    DepthFeedConnection::send_full_update(const std::string& symbol,
                                                          QuickFAST::Messages::FieldSet& message)
                    {
                      // For each session
                      Sessions::iterator session;
                      for (session = sessions_.begin(); session != sessions_.end(); ) {
                        // If the session is connected
                        if ((*session)->connected()) {
                          // conditionally send on that session
                          (*session)->send_full_update(symbol, message);
                          ++session;
                        } else {
                          // Remove the session
                          session = sessions_.erase(session);
                        }
                      }
                    }
                    
                    void
                    DepthFeedConnection::on_connect(const boost::system::error_code& error)
                    {
                      if (!error) {
                        std::cout << "connected to feed" << std::endl;
                        reset_handler_();
                        issue_read();
                      } else {
                        std::cout << "on_connect, error=" << error << std::endl;
                        socket_.close();
                        sleep(3);
                        // Try again
                        connect();
                      }
                    }
                    
                    void
                    DepthFeedConnection::on_accept(SessionPtr session,
                                                   const boost::system::error_code& error)
                    {
                      if (!error) {
                        std::cout << "accepted client connection" << std::endl;
                        sessions_.push_back(session);
                        session->set_connected();
                      } else {
                        std::cout << "on_accept, error=" << error << std::endl;
                        session.reset();
                        sleep(2);
                      }
                      // accept again
                      accept();
                    }
                    
                    void
                    DepthFeedConnection::on_receive(BufferPtr bp,
                                                    const boost::system::error_code& error,
                                                    std::size_t bytes_transferred)
                    {
                      if (!error) {
                        // Next read
                        issue_read();
                    
                        // Handle the buffer
                        if (!msg_handler_(bp, bytes_transferred)) {
                          socket_.close();
                        }
                      } else {
                        std::cout << "Error " << error << " receiving message" << std::endl;
                        socket_.close();
                        sleep(3);
                        connect();
                      }
                      // Restore buffer
                      unused_recv_buffers_.push_back(bp);
                    }
                    
                    void
                    DepthFeedConnection::on_send(WorkingBufferPtr wb,
                                                 const boost::system::error_code& error,
                                                 std::size_t bytes_transferred)
                    {
                      // Keep buffer for later
                      unused_send_buffers_.push_back(wb);
                    }
                    
                    void
                    DepthFeedConnection::issue_read()
                    {
                      BufferPtr bp = reserve_recv_buffer();
                      RecvHandler recv_handler = boost::bind(&DepthFeedConnection::on_receive, 
                                                             this, bp, _1, _2);
                      boost::asio::mutable_buffers_1 buffer(
                          boost::asio::buffer(*bp, bp->size()));
                      socket_.async_receive(buffer, 0, recv_handler);
                    }
                    
                    const char*
                    DepthFeedConnection::template_file_from_args(int argc, const char* argv[])
                    {
                      bool next_is_name = false;
                      for (int i = 0; i < argc; ++i) {
                        if (next_is_name) {
                          return argv[i];
                        } else if (strcmp(argv[i], "-t") == 0) {
                          next_is_name = true;
                        }
                      }
                      return "./templates/depth.xml";
                    }
                    
                    const char*
                    DepthFeedConnection::host_from_args(int argc, const char* argv[])
                    {
                      bool next_is_host = false;
                      for (int i = 0; i < argc; ++i) {
                        if (next_is_host) {
                          return argv[i];
                        } else if (strcmp(argv[i], "-h") == 0) {
                          next_is_host = true;
                        }
                      }
                      return "127.0.0.1";
                    }
                    
                    int
                    DepthFeedConnection::port_from_args(int argc, const char* argv[])
                    {
                      bool next_is_port = false;
                      for (int i = 0; i < argc; ++i) {
                        if (next_is_port) {
                          return atoi(argv[i]);
                        } else if (strcmp(argv[i], "-p") == 0) {
                          next_is_port = true;
                        }
                      }
                      return 10003;
                    }
                    
                    } } // End namespace
                </[depth_feed_connection.cpp]>
            </external/liquibook/examples/depth_feed_publisher>
            <external/liquibook/examples/mt_order_entry>
                <[Order.cpp]>
                    // Copyright (c) 2017 Object Computing, Inc.
                    // All rights reserved.
                    // See the file license.txt for licensing information.
                    #include "Order.h"
                    #include <sstream>
                    
                    namespace orderentry
                    {
                    
                    Order::Order(const std::string & id,
                        bool buy_side,
                        liquibook::book::Quantity quantity,
                        std::string symbol,
                        liquibook::book::Price price,
                        liquibook::book::Price stopPrice,
                        bool aon,
                        bool ioc)
                        : id_(id)
                        , buy_side_(buy_side)
                        , symbol_(symbol)
                        , quantity_(quantity)
                        , price_(price)
                        , stopPrice_(stopPrice)
                        , ioc_(ioc)
                        , aon_(aon)
                        , quantityFilled_(0)
                        , quantityOnMarket_(0)
                        , fillCost_(0)
                        , verbose_(false)
                    
                    {
                    }
                    
                    std::string 
                    Order::order_id() const
                    {
                        return id_;
                    }
                    
                    bool 
                    Order::is_limit() const
                    {
                        return price() != 0;
                    }
                    
                    bool 
                    Order::is_buy() const
                    {
                        return buy_side_;
                    }
                    
                    bool 
                    Order::all_or_none() const
                    {
                        return aon_;
                    }
                    
                    bool 
                    Order::immediate_or_cancel() const
                    {
                        return ioc_;
                    }
                    
                    std::string 
                    Order::symbol() const
                    {
                       return symbol_;
                    }
                    
                    liquibook::book::Price 
                    Order::price() const
                    {
                        return price_;
                    }
                    
                    liquibook::book::Quantity 
                    Order::order_qty() const
                    {
                        return quantity_;
                    }
                    
                    
                    liquibook::book::Price 
                    Order::stop_price() const
                    {
                        return stopPrice_;
                    }
                    
                    uint32_t 
                    Order::quantityOnMarket() const
                    {
                        return quantityOnMarket_;
                    }
                    
                    uint32_t 
                    Order::quantityFilled() const
                    {
                        return quantityFilled_;
                    }
                    
                    uint32_t 
                    Order::fillCost() const
                    {
                        return fillCost_;
                    }
                    
                    
                    const Order::History & 
                    Order::history() const
                    {
                        return history_;
                    }
                    
                    const Order::StateChange & 
                    Order::currentState() const
                    {
                        return history_.back();
                    }
                    
                    
                    Order & 
                    Order::verbose(bool verbose)
                    {
                        verbose_ = verbose;
                        return *this;
                    }
                    
                    bool
                    Order::isVerbose() const
                    {
                        return verbose_;
                    }
                    
                    void 
                    Order::onSubmitted()
                    {
                        std::stringstream msg;
                        msg << (is_buy() ? "BUY " : "SELL ") << quantity_ << ' ' << symbol_ << " @";
                        if( price_ == 0)
                        {
                            msg << "MKT";
                        }
                        else
                        {
                            msg << price_;
                        }
                        history_.emplace_back(Submitted, msg.str());
                    }
                    
                    void 
                    Order::onAccepted()
                    {
                        quantityOnMarket_ = quantity_;
                        history_.emplace_back(Accepted);
                    }
                    
                    void 
                    Order::onRejected(const char * reason)
                    {
                        history_.emplace_back(Rejected, reason);
                    }
                    
                    void 
                    Order::onFilled(
                        liquibook::book::Quantity fill_qty, 
                        liquibook::book::Cost fill_cost)
                    {
                        quantityOnMarket_ -= fill_qty;
                        fillCost_ += fill_cost;
                    
                        std::stringstream msg;
                        msg << fill_qty << " for " << fill_cost;
                        history_.emplace_back(Filled, msg.str());
                    }
                    
                    void 
                    Order::onCancelRequested()
                    {
                        history_.emplace_back(CancelRequested);
                    }
                    
                    void 
                    Order::onCancelled()
                    {
                        quantityOnMarket_ = 0;
                        history_.emplace_back(Cancelled);
                    }
                    
                    void 
                    Order::onCancelRejected(const char * reason)
                    {
                        history_.emplace_back(CancelRejected, reason);
                    }
                    
                    void 
                    Order::onReplaceRequested(
                        const int32_t& size_delta, 
                        liquibook::book::Price new_price)
                    {
                        std::stringstream msg;
                        if(size_delta != liquibook::book::SIZE_UNCHANGED)
                        {
                            msg << "Quantity change: " << size_delta << ' ';
                        }
                        if(new_price != liquibook::book::PRICE_UNCHANGED)
                        {
                            msg << "New Price " << new_price;
                        }
                        history_.emplace_back(ModifyRequested, msg.str());
                    }
                    
                    void 
                    Order::onReplaced(const int32_t& size_delta, 
                        liquibook::book::Price new_price)
                    {
                        std::stringstream msg;
                        if(size_delta != liquibook::book::SIZE_UNCHANGED)
                        {
                            quantity_ += size_delta;
                            quantityOnMarket_ += size_delta;
                            msg << "Quantity change: " << size_delta << ' ';
                        }
                        if(new_price != liquibook::book::PRICE_UNCHANGED)
                        {
                            price_ = new_price;
                            msg << "New Price " << new_price;
                        }
                        history_.emplace_back(Modified, msg.str());
                    }
                    
                    void 
                    Order::onReplaceRejected(const char * reason)
                    {
                        history_.emplace_back(ModifyRejected, reason);
                    }
                    
                    std::ostream & operator << (std::ostream & out, const Order::StateChange & event)
                    {
                        out << "{";
                        switch(event.state_)
                        {
                        case Order::Submitted:
                            out << "Submitted ";
                            break;
                        case Order::Rejected: 
                            out << "Rejected "; 
                            break;
                        case Order::Accepted:
                            out << "Accepted ";
                            break;
                        case Order::ModifyRequested:
                            out << "ModifyRequested ";
                            break;
                        case Order::ModifyRejected:
                            out << "ModifyRejected ";
                            break;
                        case Order::Modified:
                            out << "Modified ";
                            break;
                        case Order::PartialFilled:
                            out << "PartialFilled ";
                            break;
                        case Order::Filled: 
                            out << "Filled "; 
                            break;
                        case Order::CancelRequested:
                            out << "CancelRequested ";
                            break;
                        case Order::CancelRejected:
                            out << "CancelRejected ";
                            break;
                        case Order::Cancelled: 
                            out << "Cancelled "; 
                            break;
                        case Order::Unknown:
                            out << "Unknown ";
                            break;
                        }
                        out << event.description_;
                        out << "}";
                        return out;
                    }
                    
                    std::ostream & operator << (std::ostream & out, const Order & order)
                    {
                        out << "[#" << order.order_id(); 
                        out << ' ' << (order.is_buy() ? "BUY" : "SELL");
                        out << ' ' << order.order_qty();
                        out << ' ' << order.symbol();
                        if(order.price() == 0)
                        {
                            out << " MKT";
                        }
                        else
                        {
                            out << " $" << order.price();
                        }
                    
                        if(order.stop_price() != 0)
                        {
                           out << " STOP " << order.stop_price();
                        }
                    
                        out  << (order.all_or_none() ? " AON" : "")
                            << (order.immediate_or_cancel() ? " IOC" : "");
                    
                        auto onMarket = order.quantityOnMarket();
                        if(onMarket != 0)
                        {
                            out << " Open: " << onMarket;
                        }
                    
                        auto filled = order.quantityFilled();
                        if(filled != 0)
                        {
                            out << " Filled: " << filled;
                        }
                    
                        auto cost = order.fillCost();
                        if(cost != 0)
                        {
                            out << " Cost: " << cost;
                        }
                    
                        if(order.isVerbose())
                        {
                            const Order::History & history = order.history();
                            for(auto event = history.begin(); event != history.end(); ++event)
                            {
                                out << "\n\t" << *event;
                            } 
                        }
                        else
                        {
                            out << " Last Event:" << order.currentState();
                        }
                    
                       out << ']';
                       
                       return out;
                    }
                    
                    
                    }
                </[Order.cpp]>
                <[mt_order_entry_main.cpp]>
                    // Copyright (c) 2017 Object Computing, Inc.
                    // All rights reserved.
                    // See the file license.txt for licensing information.
                    #include "Market.h"
                    #include "Util.h"
                    #include <fstream>
                    #include <iomanip>
                    #include <string>
                    #include <locale>
                    #include <cstring>
                    #include <algorithm> 
                    #include <vector>
                    #include <iterator>
                    
                    using namespace orderentry;
                    
                    int main(int argc, const char * argv[])
                    {
                        bool done = false;
                        bool prompt = true;
                        bool interactive = true;
                        bool fileActive = false;
                        std::ostream * log = &std::cout;
                        std::ifstream commandFile;
                        std::ofstream logFile;
                    
                        if(argc > 1)
                        {
                            std::string filename = argv[1];
                            if(filename != "-")
                            {
                                commandFile.open(filename);
                                if(!commandFile.good())
                                {
                                    std::cerr << "Can't open command file " << filename << ". Exiting." << std::endl;
                                    return -1;
                                }
                                interactive = false;
                                fileActive = true;
                            }
                        }
                        if(argc > 2)
                        {
                            const char * filename = argv[2];
                            logFile.open(filename);
                            if(!logFile.good())
                            {
                                std::cerr << "Can't open log file " << filename << ". Exiting." << std::endl;
                                return -1;
                            }
                            log = & logFile;
                        }
                    
                        Market market(log);
                        while( !done)
                        {
                            std::string input;
                            if(fileActive) 
                            {
                                std::getline(commandFile, input);
                                if(!commandFile.good())
                                {
                                    if(interactive)
                                    {
                                        input = "# Switching to console input.";               
                                        fileActive = false;
                                    }
                                    else
                                    {
                                        input = "# end of command file.";
                                        done = true;
                                    }
                                }
                                // if it came from a file, echo it to the log
                                if(input.substr(0,2) != "##") // don't log ## comments.
                                {
                                    *log << input << std::endl;
                                }
                            }
                            else
                            {
                                if(prompt)
                                {
                                    std::cout << "Action[" << Market::prompt() 
                                    << "\t(?)    help for more options and detail.\n"
                                    << "\t(Quit) ]\n";
                                    prompt = false;
                                }
                                std::cout << "> " << std::flush;
                                std::getline(std::cin, input);
                            }
                            std::transform(input.begin(), input.end(), input.begin(), toupper);
                            if(log != &std::cout && !fileActive)
                            {
                                if(input.substr(0,2) != "##") // don't log ## comments.
                                {
                                    *log << input << std::endl;
                                }
                            }
                    
                            // if input ends in a ';' be sure there's a space before it to simplify parsing.
                            if(input.length() > 1)
                            {
                                if(input.back() == ';')
                                {
                                    input.pop_back();
                                    if(input.back() == ' ')
                                    {
                                        input.pop_back();
                                    }
                                    input.append(" ;");
                                }
                            }
                    
                            std::vector< std::string> words;
                            split(input," \t\v\n\r", words);
                            if(!words.empty())
                            {        
                                const std::string command = words[0];
                                if(command == "QUIT")
                                {
                                    done = true;
                                }
                                else if(command[0] == '#')
                                {
                                    // nothing
                                }
                                else if(command == "F" || command == "FILE")
                                {
                                    if(fileActive)
                                    {
                                        std::cout << "Only one input file at a time can be open." << std::endl;
                                    }
                                    else
                                    {
                                        std::cout << "Command file name: " << std::flush;
                                        std::string filename;
                                        std::getline(std::cin, filename);
                                        commandFile.open(filename);
                                        if(commandFile.good())
                                        {
                                            fileActive = true;
                                        }
                                        else
                                        {
                                            std::cout << "Cannot open " << filename << std::endl;
                                        }
                                    }
                                }
                                else if(command == "?" || command == "HELP")
                                {
                                    market.help();
                                    *log << "(F)ile  Open or Close a command input file\n"
                                        << "\tArguments\n"
                                        << "\t\t<FileName>  Required if no file is open. Must not appear if file is open.\n";
                                    *log << "QUIT  Exit from this program.\n";
                                    bool prompt = true;
                                }
                                else if(!market.apply(words))
                                {
                                    std::cerr << "Cannot process command";
                                    for(auto word = words.begin(); word != words.end(); ++ word)
                                    {
                                        std::cerr << ' ' << *word;
                                    }
                                    std::cerr << std::endl;
                                    bool prompt = true;
                                }
                            }
                        }
                        return 0;
                    }
                </[mt_order_entry_main.cpp]>
                <[Market.cpp]>
                    // Copyright (c) 2017 Object Computing, Inc.
                    // All rights reserved.
                    // See the file license.txt for licensing information.
                    #include "Market.h"
                    #include "Util.h"
                    
                    #include <functional> 
                    #include <cctype>
                    #include <locale>
                    
                    namespace {
                        ///////////////////////
                        // depth display helper
                        void displayDepthLevel(std::ostream & out, const liquibook::book::DepthLevel & level)
                        {
                            out << "\tPrice "  <<  level.price();
                            out << " Count: " << level.order_count();
                            out << " Quantity: " << level.aggregate_qty();
                            if(level.is_excess())
                            {
                                out << " EXCESS";
                            }
                            out << " Change id#: " << level.last_change();
                            out << std::endl;
                        }
                    
                        void publishDepth(std::ostream & out, const orderentry::BookDepth & depth)
                        {
                            liquibook::book::ChangeId published = depth.last_published_change();
                            bool needTitle = true;
                            // Iterate awkwardly
                            auto pos = depth.bids();
                            auto back = depth.last_bid_level();
                            bool more = true;
                            while(more)
                            {
                                if(pos->aggregate_qty() !=0 && pos->last_change() > published)
                                {
                                    if(needTitle)
                                    {
                                        out << "\n\tBIDS:\n";
                                        needTitle = false;
                                    }
                                    displayDepthLevel(out, *pos);
                                }
                                ++pos;
                                more = pos != back;
                            }
                    
                            needTitle = true;
                            pos = depth.asks();
                            back = depth.last_ask_level();
                            more = true;
                            while(more)
                            {
                                if(pos->aggregate_qty() !=0 && pos->last_change() > published)
                                {
                                    if(needTitle)
                                    {
                                        out << "\n\tASKS:\n";
                                        needTitle = false;
                                    }
                                    displayDepthLevel(out, *pos);
                                }
                                ++pos;
                                more = pos != back;
                            }
                        }
                    }
                    
                    namespace orderentry
                    {
                    
                    uint32_t Market::orderIdSeed_ = 0;
                    
                    Market::Market(std::ostream * out)
                    : logFile_(out)
                    {
                    }
                    
                    Market::~Market()
                    {
                    }
                    
                    const char * 
                    Market::prompt()
                    {
                        return "\t(B)uy\n\t(S)ell\n\t(M)odify\n\t(C)ancel\n\t(D)isplay\n";
                    }
                    
                    void 
                    Market::help(std::ostream & out)
                    {
                        out << "Buy: Create a new Buy order and add it to the book\n"
                            << "Sell: Create a new Sell order and add it to the book\n"
                            << "  Arguments for BUY or SELL\n"
                            << "     <Quantity>\n"
                            << "     <Symbol>\n"
                            << "     <Price> or MARKET\n"
                            << "     AON            (optional)\n"
                            << "     IOC            (optional)\n"
                            << "     STOP <Price>   (optional)\n"
                            << "     ;              end of order\n"
                            << std::endl;
                    
                        out << "Modify: Request Modify an existing order\n"
                            << "  Arguments:\n"
                            << "     <order#>\n"
                            << "     PRICE <new price>\n"
                            << "     QUANTITY <new initial quantity>\n"
                            << "     ;              end of modify requet\n"
                            << std::endl;
                    
                        out << "Cancel: Request cancel an existing order\n"
                            << "  Arguments:\n"
                            << "     <order#>\n"
                            << "     ;              end of cancel request (optional)\n"
                            << std::endl;
                    
                        out << "Display: Display status of an existing order\n"
                            << "  Arguments:\n"
                            << "     +       (enable verbose display)\n"
                            << "     <order#> or <symbol> or \"all\"\n"
                            << std::endl;
                    
                    }
                    
                    bool 
                    Market::apply(const std::vector<std::string> & tokens)
                    {
                        const std::string & command = tokens[0];
                        if(command == "BUY" || command == "B")
                        {
                            return doAdd("BUY", tokens, 1);
                        }
                        if(command == "SELL" || command == "S")
                        {
                            return doAdd("SELL", tokens, 1);
                        }
                        else if (command == "CANCEL" || command == "C")
                        {
                            return doCancel(tokens, 1);
                        }
                        else if(command == "MODIFY" || command == "M")
                        {
                            return doModify(tokens, 1);
                        }
                        else if(command == "DISPLAY" || command == "D")
                        {
                            return doDisplay(tokens, 1);
                        }
                        return false;
                    }
                    
                    
                    ////////
                    // ADD
                    bool 
                    Market::doAdd(const  std::string & side, const std::vector<std::string> & tokens, size_t pos)
                    {
                        //////////////
                        // Quantity
                        liquibook::book::Quantity quantity;
                        std::string qtyStr = nextToken(tokens, pos);
                        if(!qtyStr.empty())
                        {
                            quantity = toUint32(qtyStr);
                        }
                        else
                        {
                            quantity = promptForUint32("Quantity");
                        }
                        // sanity check
                        if(quantity == 0 || quantity > 1000000000)
                        {
                            out() << "--Expecting quantity" << std::endl;
                            return false;
                        }
                    
                        //////////////
                        // SYMBOL
                        std::string symbol = nextToken(tokens, pos);
                        if(symbol.empty())
                        {
                            symbol = promptForString("Symbol");
                        }
                        if(!symbolIsDefined(symbol))
                        {
                            if(symbol[0] == '+' || symbol[0] == '!')
                            {
                                bool useDepth = symbol[0] == '!';
                                symbol = symbol.substr(1);
                                if(!symbolIsDefined(symbol))
                                {
                                    addBook(symbol, useDepth);
                                }
                            }
                            else
                            {
                                std::string bookType;
                                while(bookType != "S" 
                                  && bookType != "D" 
                                  && bookType != "N")
                                {
                                  bookType = promptForString(
                                  "New Symbol " + symbol +  
                                  ". \nAdd [S]imple book, or [D]epth book, or 'N' to cancel request.\n[SDN}");
                                }
                                if(bookType == "N")
                                {
                                    out() << "Request ignored" << std::endl;
                                    return false;
                                }
                                bool useDepth = bookType == "D";
                                addBook(symbol, useDepth);
                            }
                        }
                    
                        ///////////////
                        // PRICE
                        uint32_t price = 0;
                        std::string priceStr = nextToken(tokens, pos);
                        if(!priceStr.empty())
                        {
                            price = stringToPrice(priceStr);
                        }
                        else
                        {
                            price = promptForPrice("Limit Price or MKT");
                        }
                        if(price > 10000000)
                        {
                            out() << "--Expecting price or MARKET" << std::endl;
                            return false;
                        }
                    
                        //////////////////////////
                        // OPTIONS: AON, IOC STOP
                        bool aon = false;
                        bool ioc = false;
                        liquibook::book::Price stopPrice = 0;
                        bool go = false;
                        while(!go)
                        {
                            bool prompted = false;
                            bool optionOk = false;
                            std::string option = nextToken(tokens, pos);
                            if(option.empty())
                            {
                                prompted = true;
                                option = promptForString("AON, or IOC, or STOP, or END");
                            }
                            if(option == ";" || option == "E" || option == "END")
                            {
                                go = true;
                                optionOk = true;
                            }
                            else if(option == "A" || option == "AON")
                            {
                                aon = true;
                                optionOk = true;
                            }
                            else if(option == "I" || option == "IOC")
                            {
                                ioc = true;
                                optionOk = true;
                            }
                            else if(option == "S" || option == "STOP")
                            {
                                std::string stopstr = nextToken(tokens, pos);
                    
                                if(!stopstr.empty())
                                {
                                    stopPrice = stringToPrice(stopstr);
                                } 
                                else
                                {
                                    stopPrice = promptForUint32("Stop Price");
                                    prompted = true;
                                }
                                optionOk = stopPrice <= 10000000;
                            }
                            if(!optionOk)
                            {
                                out() << "Unknown option " << option << std::endl;
                                if(!prompted)
                                {
                                    out() << "--Expecting AON IOC STOP or END" << std::endl;
                                    return false;
                                }
                            }
                        }
                    
                        std::string orderId = std::to_string(++orderIdSeed_);
                    
                        OrderPtr order = std::make_shared<Order>(orderId, side == "BUY", quantity, symbol, price, stopPrice, aon, ioc);
                    
                        const liquibook::book::OrderConditions AON(liquibook::book::oc_all_or_none);
                        const liquibook::book::OrderConditions IOC(liquibook::book::oc_immediate_or_cancel);
                        const liquibook::book::OrderConditions NOC(liquibook::book::oc_no_conditions);
                    
                        const liquibook::book::OrderConditions conditions = 
                            (aon ? AON : NOC) | (ioc ? IOC : NOC);
                    
                    
                        auto book = findBook(symbol);
                        if(!book)
                        {
                            out() << "--No order book for symbol" << symbol << std::endl;
                            return false;
                        }
                    
                        order->onSubmitted();
                        out() << "ADDING order:  " << *order << std::endl;
                    
                        orders_[orderId] = order;
                        book->add(order, conditions);
                        return true;
                    }
                    
                    ///////////
                    // CANCEL
                    bool
                    Market::doCancel(const std::vector<std::string> & tokens, size_t position)
                    {
                        OrderPtr order;
                        OrderBookPtr book;
                        if(!findExistingOrder(tokens, position, order, book))
                        {
                            return false;
                        }
                        out() << "Requesting Cancel: " << *order << std::endl;
                        book->cancel(order);
                        return true;
                    }
                    
                    ///////////
                    // MODIFY
                    bool
                    Market::doModify(const std::vector<std::string> & tokens, size_t position)
                    {
                        OrderPtr order;
                        OrderBookPtr book;
                        if(!findExistingOrder(tokens, position, order, book))
                        {
                            return false;
                        }
                    
                        //////////////
                        // options
                        //////////////////////////
                        // OPTIONS: PRICE (price) ; QUANTITY (delta)
                    
                        int64_t quantityChange = liquibook::book::SIZE_UNCHANGED;
                        liquibook::book::Price price = liquibook::book::PRICE_UNCHANGED;
                    
                        bool go = false;
                        while(!go)
                        {
                            bool prompted = false;
                            bool optionOk = false;
                            std::string option = nextToken(tokens, position);
                            if(option.empty())
                            {
                                prompted = true;
                                option = promptForString("PRICE, or QUANTITY, or END");
                            }
                            if(option == ";" || option == "E" || option == "END")
                            {
                                go = true;
                                optionOk = true;
                            }
                            else if(option == "P" || option == "PRICE")
                            {
                                uint32_t newPrice = INVALID_UINT32;
                                std::string priceStr = nextToken(tokens, position);
                                if(priceStr.empty())
                                {
                                    newPrice = promptForUint32("New Price");
                                }
                                else
                                {
                                    newPrice = toUint32(priceStr);
                                }
                    
                                if(newPrice > 0 && newPrice != INVALID_UINT32)
                                {
                                    price = newPrice;
                                    optionOk = true;
                                }
                                else
                                {
                                    out() << "Invalid price" << std::endl;
                                }
                            }
                            else if(option == "Q" || option == "QUANTITY")
                            {
                                int32_t qty = INVALID_INT32;
                                std::string qtyStr = nextToken(tokens, position);
                                if(qtyStr.empty())
                                {
                                    qty = promptForInt32("Change in quantity");
                                }
                                else
                                {
                                    qty = toInt32(qtyStr);
                                }
                                if(qty != INVALID_INT32)
                                {
                                    quantityChange = qty;
                                    optionOk = true;
                                }
                                else
                                {
                                    out() << "Invalid quantity change." << std::endl;
                                }
                            }
                    
                            if(!optionOk)
                            {
                                out() << "Unknown or invalid option " << option << std::endl;
                                if(!prompted)
                                {
                                    out() << "--Expecting PRICE <price>, or QUANTITY <change>, or  END" << std::endl;
                                    return false;
                                }
                            }
                        }
                    
                        book->replace(order, quantityChange, price);
                        out() << "Requested Modify" ;
                        if(quantityChange != liquibook::book::SIZE_UNCHANGED)
                        {
                            out() << " QUANTITY  += " << quantityChange;
                        }
                        if(price != liquibook::book::PRICE_UNCHANGED)
                        {
                            out() << " PRICE " << price;
                        }
                        out() << std::endl;
                        return true;
                    }
                    
                    ///////////
                    // DISPLAY
                    bool
                    Market::doDisplay(const std::vector<std::string> & tokens, size_t pos)
                    {
                        bool verbose = false;
                        // see if first token could be an order id.
                        // todo: handle prompted imput!
                        std::string parameter = nextToken(tokens, pos);
                        if(parameter.empty())
                        {
                            parameter = promptForString("+ or #OrderId or -orderOffset or symbol or \"ALL\"");
                        }
                        else
                        {
                            --pos; // Don't consume this parameter yet.
                        }
                        if(parameter[0] == '+')
                        {
                            verbose = true;
                            if(parameter.length() > 1)
                            {
                                parameter = parameter.substr(1);
                            }
                            else
                            {
                                ++pos; // now we can consume the first parameter (whether or not it's there!)
                                parameter = nextToken(tokens, pos);
                                if(parameter.empty())
                                {
                                    parameter = promptForString("#OrderId or -orderOffset or symbol or \"ALL\"");
                                }
                                else
                                {
                                    --pos; // Don't consume this parameter yet.
                                }
                            }
                        }
                        if(parameter[0] == '#' || parameter[0] == '-' || isdigit(parameter[0]))
                        {
                            OrderPtr order;
                            OrderBookPtr book;
                            if(findExistingOrder(parameter, order, book))
                            {
                                out() << *order << std::endl;
                                return true;
                            }
                        }
                    
                        // Not an order id.  Try for a symbol:
                        std::string symbol = parameter;
                        if(symbolIsDefined(symbol))
                        {
                            for(auto pOrder = orders_.begin(); pOrder != orders_.end(); ++pOrder)
                            {
                                const OrderPtr & order = pOrder->second;
                                if(order->symbol() == symbol)
                                {
                                    out() << order->verbose(verbose) << std::endl;
                                    order->verbose(false);
                                }
                            }
                            auto book = findBook(symbol);
                            if(!book)
                            {
                                out() << "--No order book for symbol" << symbol << std::endl;
                            }
                            else
                            {
                                book->log(out());
                            }
                            return true;
                        }
                        else if( symbol == "ALL")
                        {
                            for(auto pOrder = orders_.begin(); pOrder != orders_.end(); ++pOrder)
                            {
                                const OrderPtr & order = pOrder->second;
                                out() << order->verbose(verbose) << std::endl;
                                order->verbose(false);
                            }
                    
                            for(auto pBook = books_.begin(); pBook != books_.end(); ++pBook)
                            {
                                out() << "Order book for " << pBook->first << std::endl;
                                pBook->second->log(out());
                            }
                            return true;
                        }
                        else
                        {
                            out() << "--Unknown symbol: " << symbol << std::endl;
                        }
                        return false;
                    }
                    
                    /////////////////////////////
                    // Order book interactions
                    
                    bool
                    Market::symbolIsDefined(const std::string & symbol)
                    {
                        auto book = books_.find(symbol);
                        return book != books_.end();
                    }
                    
                    OrderBookPtr
                    Market::addBook(const std::string & symbol, bool useDepthBook)
                    {
                        OrderBookPtr result;
                        if(useDepthBook)
                        {
                            out() << "Create new depth order book for " << symbol << std::endl;
                            DepthOrderBookPtr depthBook = std::make_shared<DepthOrderBook>(symbol);
                            depthBook->set_bbo_listener(this);
                            depthBook->set_depth_listener(this);
                            result = depthBook;
                        }
                        else
                        {
                            out() << "Create new order book for " << symbol << std::endl;
                            result = std::make_shared<OrderBook>(symbol);
                        }
                        result->set_order_listener(this);
                        result->set_trade_listener(this);
                        result->set_order_book_listener(this);
                        books_[symbol] = result;
                        return result;
                    }
                    
                    OrderBookPtr
                    Market::findBook(const std::string & symbol)
                    {
                        OrderBookPtr result;
                        auto entry = books_.find(symbol);
                        if(entry != books_.end())
                        {
                            result = entry->second;
                        }
                        return result;
                    }
                    
                    bool Market::findExistingOrder(const std::vector<std::string> & tokens, size_t & position, OrderPtr & order, OrderBookPtr & book)
                    {
                        ////////////////
                        // Order ID
                        std::string orderId = nextToken(tokens, position);
                        trim(orderId);
                        if(orderId.empty())
                        {
                            orderId = promptForString("Order Id#");
                            trim(orderId);
                        }
                        // discard leading # if any
                        if(orderId[0] == '#')
                        {
                            orderId = orderId.substr(1);
                            trim(orderId);
                            if(orderId.empty())
                            {
                                out() << "--Expecting #orderID" << std::endl;
                                return false;
                            }
                        }
                    
                        if(orderId[0] == '-') // relative addressing
                        {
                            int32_t orderOffset = toInt32(orderId);
                            if(orderOffset == INVALID_INT32)
                            {
                                out() << "--Expecting orderID or offset" << std::endl;
                                return false;
                            }
                            uint32_t orderNumber = orderIdSeed_  + 1 + orderOffset;
                            orderId = std::to_string(orderNumber);
                        }
                        return findExistingOrder(orderId, order, book);
                    }
                    
                    bool Market::findExistingOrder(const std::string & orderId, OrderPtr & order, OrderBookPtr & book)
                    {
                        auto orderPosition = orders_.find(orderId);
                        if(orderPosition == orders_.end())
                        {
                            out() << "--Can't find OrderID #" << orderId << std::endl;
                            return false;
                        }
                    
                        order = orderPosition->second;
                        std::string symbol = order->symbol();
                        book = findBook(symbol);
                        if(!book)
                        {
                            out() << "--No order book for symbol" << symbol << std::endl;
                            return false;
                        }
                        return true;
                    }
                    
                    /////////////////////////////////////
                    // Implement OrderListener interface
                    
                    void 
                    Market::on_accept(const OrderPtr& order)
                    {
                        order->onAccepted();
                        out() << "\tAccepted: " <<*order<< std::endl;
                    }
                    
                    void 
                    Market::on_reject(const OrderPtr& order, const char* reason)
                    {
                        order->onRejected(reason);
                        out() << "\tRejected: " <<*order<< ' ' << reason << std::endl;
                    
                    }
                    
                    void 
                    Market::on_fill(const OrderPtr& order, 
                        const OrderPtr& matched_order, 
                        liquibook::book::Quantity fill_qty, 
                        liquibook::book::Cost fill_cost)
                    {
                        order->onFilled(fill_qty, fill_cost);
                        matched_order->onFilled(fill_qty, fill_cost);
                        out() << (order->is_buy() ? "\tBought: " : "\tSold: ") 
                            << fill_qty << " Shares for " << fill_cost << ' ' <<*order<< std::endl;
                        out() << (matched_order->is_buy() ? "\tBought: " : "\tSold: ") 
                            << fill_qty << " Shares for " << fill_cost << ' ' << *matched_order << std::endl;
                    }
                    
                    void 
                    Market::on_cancel(const OrderPtr& order)
                    {
                        order->onCancelled();
                        out() << "\tCanceled: " << *order<< std::endl;
                    }
                    
                    void Market::on_cancel_reject(const OrderPtr& order, const char* reason)
                    {
                        order->onCancelRejected(reason);
                        out() << "\tCancel Reject: " <<*order<< ' ' << reason << std::endl;
                    }
                    
                    void Market::on_replace(const OrderPtr& order, 
                        const int64_t& size_delta, 
                        liquibook::book::Price new_price)
                    {
                        order->onReplaced(size_delta, new_price);
                        out() << "\tModify " ;
                        if(size_delta != liquibook::book::SIZE_UNCHANGED)
                        {
                            out() << " QUANTITY  += " << size_delta;
                        }
                        if(new_price != liquibook::book::PRICE_UNCHANGED)
                        {
                            out() << " PRICE " << new_price;
                        }
                        out() <<*order<< std::endl;
                    }
                    
                    void 
                    Market::on_replace_reject(const OrderPtr& order, const char* reason)
                    {
                        order->onReplaceRejected(reason);
                        out() << "\tReplace Reject: " <<*order<< ' ' << reason << std::endl;
                    }
                    
                    ////////////////////////////////////
                    // Implement TradeListener interface
                    
                    void 
                    Market::on_trade(const OrderBook* book, 
                        liquibook::book::Quantity qty, 
                        liquibook::book::Cost cost)
                    {
                        out() << "\tTrade: " << qty <<  ' ' << book->symbol() << " Cost "  << cost  << std::endl;
                    }
                    
                    /////////////////////////////////////////
                    // Implement OrderBookListener interface
                    
                    void 
                    Market::on_order_book_change(const OrderBook* book)
                    {
                        out() << "\tBook Change: " << ' ' << book->symbol() << std::endl;
                    }
                    
                    
                    
                    /////////////////////////////////////////
                    // Implement BboListener interface
                    void 
                    Market::on_bbo_change(const DepthOrderBook * book, const BookDepth * depth)
                    {
                        out() << "\tBBO Change: " << ' ' << book->symbol() 
                            << (depth->changed() ? " Changed" : " Unchanged")
                            << " Change Id: " << depth->last_change()
                            << " Published: " << depth->last_published_change()
                            << std::endl;
                    
                    }
                    
                    /////////////////////////////////////////
                    // Implement DepthListener interface
                    void 
                    Market::on_depth_change(const DepthOrderBook * book, const BookDepth * depth)
                    {
                        out() << "\tDepth Change: " << ' ' << book->symbol();
                        out() << (depth->changed() ? " Changed" : " Unchanged")
                            << " Change Id: " << depth->last_change()
                            << " Published: " << depth->last_published_change();
                        publishDepth(out(), *depth);
                        out() << std::endl;
                    }
                    
                    }  // namespace orderentry
                </[Market.cpp]>
                <[Util.cpp]>
                    // Copyright (c) 2017 Object Computing, Inc.
                    // All rights reserved.
                    // See the file license.txt for licensing information.
                    #include "Util.h"
                    #include <iostream>
                    #include <algorithm>
                    #include <functional>
                    #include <cctype>
                    
                    namespace orderentry
                    {
                    std::string nextToken(const std::vector<std::string> & tokens, size_t & pos)
                    {
                        if(pos < tokens.size())
                        {
                            return tokens[pos++];
                        }
                        return "";
                    }
                    
                    uint32_t toUint32(const std::string & input)
                    {
                        char * end;
                        uint32_t value = strtoul(input.c_str(), &end, 10);
                        if(*end != '\0')
                        {
                            value = INVALID_UINT32;
                        }
                        return value;
                    }
                    
                    uint32_t toInt32(const std::string & input)
                    {
                        char * end;
                        uint32_t value = strtol(input.c_str(), &end, 10);
                        if(*end != '\0')
                        {
                            value = INVALID_INT32;
                        }
                        return value;
                    }
                    
                    
                    liquibook::book::Price stringToPrice(const std::string & str)
                    {
                        if(str == "MARKET" || str == "MKT")
                        {
                            return 0;
                        } else
                        {
                            return toUint32(str);
                        }
                    }
                    
                    std::string promptForString(const std::string & prompt, bool uppercase)
                    {
                        std::cout << "\n" << prompt << ": " << std::flush;
                        std::string input;
                        std::getline(std::cin, input);
                        if(uppercase)
                        {
                          std::transform(input.begin(), input.end(), input.begin(), toupper);
                        }
                        return input;
                    }
                    
                    liquibook::book::Price promptForPrice(const std::string & prompt)
                    {
                        std::string str = promptForString(prompt);
                        return stringToPrice(str);
                    }
                    
                    uint32_t promptForUint32(const std::string & prompt)
                    {
                        std::cout << "\n" << prompt << ": " << std::flush;
                        std::string input;
                        std::getline(std::cin, input);
                        return toUint32(input);
                    }
                    
                    int32_t promptForInt32(const std::string & prompt)
                    {
                        std::cout << "\n" << prompt << ": " << std::flush;
                        std::string input;
                        std::getline(std::cin, input);
                        return toInt32(input);
                    }
                    
                    bool promptForYesNo(const std::string & prompt)
                    {
                        while(true)
                        {
                            std::string input = promptForString(prompt);
                            if(input == "Y" || input == "YES" || input == "T" || input == "TRUE")
                            {
                                return true;
                            }
                            if(input == "N" || input == "NO" || input == "F" || input == "FALSE")
                            {
                                return false;
                            }
                        }
                    }
                    
                    // trim from start (in place)
                    std::string &  ltrim(std::string &s) {
                        s.erase(s.begin(), std::find_if(s.begin(), s.end(), 
                            std::not1(std::ptr_fun<int, int>(std::isspace))));
                        return s;
                    }
                    
                    // trim from end (in place)
                    std::string &  rtrim(std::string &s) {
                        s.erase(std::find_if(s.rbegin(), s.rend(), 
                            std::not1(std::ptr_fun<int, int>(std::isspace))).base(), s.end());
                        return s;
                    }
                    
                    // trim from both ends (in place)
                    std::string &  trim(std::string &s) 
                    {
                        return ltrim(rtrim(s));
                    }
                    
                    // trim from start (copying)
                    std::string ltrimmed(std::string s) 
                    {
                        ltrim(s);
                        return s;
                    }
                    
                    // trim from end (copying)
                    std::string rtrimmed(std::string s) 
                    {
                        rtrim(s);
                        return s;
                    }
                    
                    // trim from both ends (copying)
                    std::string trimmed(std::string s) 
                    {
                        trim(s);
                        return s;
                    }
                    
                    }
                    
                </[Util.cpp]>
            </external/liquibook/examples/mt_order_entry>
            <external/liquibook/test/perf>
                <[pt_order_book.cpp]>
                    // Copyright (c) 2012, 2013 Object Computing, Inc.
                    // All rights reserved.
                    // See the file license.txt for licensing information.
                    #include <simple/simple_order_book.h>
                    #include <book/types.h>
                    
                    #include <iostream>
                    #include <stdexcept>
                    #include <stdlib.h>
                    #include <time.h>
                    
                    using namespace liquibook;
                    using namespace liquibook::book;
                    
                    typedef simple::SimpleOrderBook<5> FullDepthOrderBook;
                    typedef simple::SimpleOrderBook<1> BboOrderBook;
                    typedef book::OrderBook<simple::SimpleOrder*> NoDepthOrderBook;
                    
                    template <class TypedOrderBook, class TypedOrder>
                    int run_test(TypedOrderBook& order_book, TypedOrder** orders, clock_t end) {
                      int count = 0;
                      TypedOrder** pp_order = orders;
                      do {
                        order_book.add(*pp_order);
                        ++pp_order;
                        if (*pp_order == nullptr) {
                          return -1;
                        }
                        ++count;
                      } while (clock() < end);
                      return int(pp_order - orders);
                    }
                    
                    template <class TypedOrderBook>
                    bool build_and_run_test(uint32_t dur_sec, uint32_t num_to_try) {
                      std::cout << "trying run of " << num_to_try << " orders";
                      TypedOrderBook order_book;
                      simple::SimpleOrder** orders = new simple::SimpleOrder*[num_to_try + 1];
                      
                      for (uint32_t i = 0; i <= num_to_try; ++i) {
                        bool is_buy((i % 2) == 0);
                        uint32_t delta = is_buy ? 1880 : 1884;
                        // ASK 1893
                        // ASK 1892
                        // ASK 1891
                        // ASK 1890
                        // ASK 1889 crossable
                        // ASK 1888 crossable
                        // ASK 1887 crossable
                        // ASK 1886 crossable
                        // ASK 1885 crossable
                        // ASK 1884 crossable
                    
                        // BID 1889 crossable
                        // BID 1888 crossable
                        // BID 1887 crossable
                        // BID 1886 crossable
                        // BID 1885 crossable
                        // BID 1884 crossable
                        // BID 1883
                        // BID 1882
                        // BID 1881
                        // BID 1880
                    
                        Price price = (rand() % 10) + delta;
                        
                        Quantity qty = ((rand() % 10) + 1) * 100;
                        orders[i] = new simple::SimpleOrder(is_buy, price, qty);
                      }
                      orders[num_to_try] = nullptr; // Final null
                      
                      clock_t start = clock();
                      clock_t stop = start + (dur_sec * CLOCKS_PER_SEC);
                    
                      int count = run_test(order_book, orders, stop);
                      for (uint32_t i = 0; i <= num_to_try; ++i) {
                        delete orders[i];
                      }
                      delete [] orders;
                      if (count > 0) {
                        std::cout << " - complete!" << std::endl;
                        std::cout << "Inserted " << count << " orders in " << dur_sec << " seconds"
                                  << ", or " << count / dur_sec << " insertions per sec"
                                  << std::endl;
                        uint32_t remain = uint32_t(order_book.bids().size() + order_book.asks().size());
                        std::cout << "Run matched " << count - remain << " orders" << std::endl;
                        return true;
                      } else {
                        std::cout << " - not enough orders" << std::endl;
                        return false;
                      }
                    
                      return count > 0;
                    }
                    
                    int main(int argc, const char* argv[])
                    {
                      uint32_t dur_sec = 3;
                      if (argc > 1) {
                        dur_sec = atoi(argv[1]);
                        if (!dur_sec) { 
                          dur_sec = 3;
                        }
                      }
                      std::cout << dur_sec << " sec performance test of order book" << std::endl;
                      
                      srand(dur_sec);
                    
                      {
                        std::cout << "testing order book with depth" << std::endl;
                        uint32_t num_to_try = dur_sec * 125000;
                        while (true) {
                          if (build_and_run_test<FullDepthOrderBook>(dur_sec, num_to_try)) {
                            break;
                          } else {
                            num_to_try *= 2;
                          }
                        }
                      }
                    
                      {
                        std::cout << "testing order book with bbo" << std::endl;
                        uint32_t num_to_try = dur_sec * 125000;
                        while (true) {
                          if (build_and_run_test<BboOrderBook>(dur_sec, num_to_try)) {
                            break;
                          } else {
                            num_to_try *= 2;
                          }
                        }
                      }
                    
                      {
                        std::cout << "testing order book without depth" << std::endl;
                        uint32_t num_to_try = dur_sec * 125000;
                        while (true) {
                          if (build_and_run_test<NoDepthOrderBook>(dur_sec, num_to_try)) {
                            break;
                          } else {
                            num_to_try *= 2;
                          }
                        }
                      }
                    
                    }
                    
                </[pt_order_book.cpp]>
            </external/liquibook/test/perf>
            <external/liquibook/test/unit>
                <[ut_order_book_shared_ptr.cpp]>
                    // Copyright (c) 2012 - 2017 Object Computing, Inc.
                    // All rights reserved.
                    // See the file license.txt for licensing information.
                    
                    #define BOOST_TEST_NO_MAIN LiquibookTest
                    #include <boost/test/unit_test.hpp>
                    
                    #include "ut_utils.h"
                    #include "changed_checker.h"
                    #include <book/order_book.h>
                    #include <simple/simple_order.h>
                    #include <simple/simple_order_book.h>
                    #include <memory>
                    
                    namespace liquibook {
                    
                    using book::DepthLevel;
                    using book::OrderBook;
                    using book::OrderTracker;
                    using simple::SimpleOrder;
                    
                    
                    typedef std::shared_ptr<SimpleOrder> SimpleOrderPtr;
                    class SharedPtrOrderBook : public OrderBook<SimpleOrderPtr>
                    {
                      virtual void perform_callback(OrderBook<SimpleOrderPtr>::TypedCallback& cb)
                      {
                        switch(cb.type) {
                          case TypedCallback::cb_order_accept:
                            cb.order->accept();
                            break;
                          case TypedCallback::cb_order_fill: {
                            Cost fill_cost = cb.price * cb.quantity;
                            cb.order->fill(cb.quantity, fill_cost, 0);
                            cb.matched_order->fill(cb.quantity, fill_cost, 0);
                            break;
                          }
                          case TypedCallback::cb_order_cancel:
                            cb.order->cancel();
                            break;
                          case TypedCallback::cb_order_replace:
                            cb.order->replace(cb.delta, cb.price);
                            break;
                          default:
                            // Nothing
                            break;
                        }
                      }
                    };
                    
                    typedef FillCheck<SimpleOrderPtr> SharedFillCheck;
                    
                    BOOST_AUTO_TEST_CASE(TestSharedPointerBuild)
                    {
                      SharedPtrOrderBook order_book;
                      SimpleOrderPtr ask1(new SimpleOrder(false, 1252, 100));
                      SimpleOrderPtr ask0(new SimpleOrder(false, 1251, 100));
                      SimpleOrderPtr bid1(new SimpleOrder(true,  1251, 100));
                      SimpleOrderPtr bid0(new SimpleOrder(true,  1250, 100));
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, ask1, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    
                      // Match - complete
                      {
                        SharedFillCheck fc1(bid1, 100, 125100);
                        SharedFillCheck fc2(ask0, 100, 125100);
                        BOOST_CHECK(add_and_verify(order_book, bid1, true, true));
                      }
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestSharedCancelBid)
                    {
                      SharedPtrOrderBook order_book;
                      SimpleOrderPtr ask1(new SimpleOrder(false, 1252, 100));
                      SimpleOrderPtr ask0(new SimpleOrder(false, 1251, 100));
                      SimpleOrderPtr bid0(new SimpleOrder(true,  1250, 100));
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, ask1, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    
                      // Cancel bid
                      BOOST_CHECK(cancel_and_verify(order_book, bid0, simple::os_cancelled));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(0, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    }
                    
                    } // namespace
                </[ut_order_book_shared_ptr.cpp]>
                <[ut_market_price.cpp]>
                    // Copyright (c) 2012 - 2017 Object Computing, Inc.
                    // All rights reserved.
                    // See the file license.txt for licensing information.
                    
                    #define BOOST_TEST_NO_MAIN LiquibookTest
                    #include <boost/test/unit_test.hpp>
                    
                    #include "ut_utils.h"
                    #include "changed_checker.h"
                    #include <book/order_book.h>
                    #include <simple/simple_order.h>
                    
                    namespace liquibook {
                    
                    using book::DepthLevel;
                    using book::OrderBook;
                    using book::OrderTracker;
                    using simple::SimpleOrder;
                    
                    namespace
                    {
                      const bool sideBuy = true;
                      const bool sideSell = false;
                    
                      const Price prcMkt = 0;
                      const Price prc0 = 9900;
                    
                      const Quantity q100 = 100;
                    
                      const bool expectMatch = true;
                      const bool expectNoMatch = false;
                    
                      const bool expectComplete = true;
                      const bool expectNoComplete = false;
                    }
                    
                    typedef OrderTracker<SimpleOrder*> SimpleTracker;
                    typedef test::ChangedChecker<5> ChangedChecker;
                    
                    typedef FillCheck<SimpleOrder*> SimpleFillCheck;
                    
                    BOOST_AUTO_TEST_CASE(TestNoMktToMktWithoutPreviousTrade)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder order0(sideBuy, prcMkt, q100);
                      SimpleOrder order1(sideSell, prcMkt, q100);
                    
                      // Check that no market-to-market trade happens without a prior trade
                      BOOST_CHECK(add_and_verify(order_book, &order0, expectNoMatch));
                      BOOST_CHECK(add_and_verify(order_book, &order1, expectNoMatch));
                    
                      SimpleFillCheck fc0(&order0, 0, 0);
                      SimpleFillCheck fc1(&order1, 0, 0);
                    
                      BOOST_CHECK_EQUAL(0U, order_book.market_price());
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestTradeSetsMarketPrice)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder order0(sideBuy, prcMkt, q100);
                      SimpleOrder order1(sideSell, prcMkt, q100);
                    
                      // Check that no market-to-market trade happens without a prior trade
                      BOOST_CHECK(add_and_verify(order_book, &order0, expectNoMatch));
                      BOOST_CHECK(add_and_verify(order_book, &order1, expectNoMatch));
                    
                      BOOST_CHECK_EQUAL(0U, order_book.market_price());
                    
                      SimpleOrder order2(sideBuy, prc0, q100);
                    
                      // Scope for fill checks
                      {
                        SimpleFillCheck fc0(&order0, 0, 0);
                        SimpleFillCheck fc1(&order1, q100, q100 * prc0);
                        SimpleFillCheck fc2(&order2, q100, q100 * prc0);
                        BOOST_CHECK(add_and_verify(order_book, &order2, expectMatch, expectComplete));
                      }
                      BOOST_CHECK_EQUAL(prc0, order_book.market_price());
                      
                      SimpleOrder order3(sideSell, prcMkt, q100);
                      // Scope for fill checks
                      {
                        SimpleFillCheck fc0(&order0, q100, q100 * prc0);
                        SimpleFillCheck fc3(&order3, q100, q100 * prc0);
                        BOOST_CHECK(add_and_verify(order_book, &order3, expectMatch, expectComplete));
                      }
                      BOOST_CHECK_EQUAL(prc0, order_book.market_price());
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestExplicitlySettingMarketPriceAllowsMarketToMarketTrades)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder order0(sideBuy, prcMkt, q100);
                      SimpleOrder order1(sideSell, prcMkt, q100);
                    
                      // Check that no market-to-market trade happens without a prior trade
                      BOOST_CHECK(add_and_verify(order_book, &order0, expectNoMatch));
                      BOOST_CHECK(add_and_verify(order_book, &order1, expectNoMatch));
                    
                      // IF WE MAKE THE MANUAL SETTING OF MARKET PRICE RETROACTIVE
                      // FIX THIS TEST TO REFLECT THAT
                      
                      // Scope for fill checks
                      {
                        SimpleFillCheck fc0(&order0, 0, 0);
                        SimpleFillCheck fc1(&order1, 0, 0);
                        order_book.set_market_price(prc0);
                      }
                    
                      SimpleOrder order2(sideBuy, prcMkt, q100);
                      SimpleOrder order3(sideSell, prcMkt, q100);
                      // Scope for fill checks
                      {
                        SimpleFillCheck fc0(&order0, q100, q100 * prc0);
                        SimpleFillCheck fc1(&order1, q100, q100 * prc0);
                        SimpleFillCheck fc2(&order2, q100, q100 * prc0);
                        SimpleFillCheck fc3(&order3, q100, q100 * prc0);
                        BOOST_CHECK(add_and_verify(order_book, &order2, expectMatch, expectComplete));
                        BOOST_CHECK(add_and_verify(order_book, &order3, expectMatch, expectComplete));
                      }
                    }
                    
                    } // namespace
                </[ut_market_price.cpp]>
                <[ut_depth.cpp]>
                    // Copyright (c) 2012 - 2017 Object Computing, Inc.
                    // All rights reserved.
                    // See the file license.txt for licensing information.
                    
                    #define BOOST_TEST_NO_MAIN LiquibookTest
                    #include <boost/test/unit_test.hpp>
                    
                    #include <book/depth.h>
                    #include "changed_checker.h"
                    #include <iostream>
                    
                    namespace liquibook {
                    
                    using book::Depth;
                    using book::DepthLevel;
                    typedef Depth<5> SizedDepth;
                    typedef test::ChangedChecker<5> ChangedChecker;
                    
                    bool verify_level(const DepthLevel*& level, 
                                      book::Price price, 
                                      uint32_t order_count, 
                                      book::Quantity aggregate_qty)
                    {
                      bool matched = true;
                      if (price != level->price()) {
                        std::cout << "Level price " << level->price() << std::endl;
                        matched = false;
                      }
                      if (order_count != level->order_count()) {
                        std::cout << "Level order count " << level->order_count() << std::endl;
                        matched = false;
                      }
                      if (aggregate_qty != level->aggregate_qty()) {
                        std::cout << "Level aggregate qty " << level->aggregate_qty() << std::endl;
                        matched = false;
                      }
                      ++level;
                      return matched;
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestAddBid)
                    {
                      SizedDepth depth;
                      ChangedChecker cc(depth);
                      depth.add_order(1234, 100, true);
                      const DepthLevel* first_bid = depth.bids();
                      BOOST_CHECK(verify_level(first_bid, 1234, 1, 100));
                      BOOST_CHECK(cc.verify_bid_changed(true, false, false, false, false));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestAddBids)
                    {
                      SizedDepth depth;
                      ChangedChecker cc(depth);
                      depth.add_order(1234, 100, true);
                      depth.add_order(1234, 200, true);
                      depth.add_order(1234, 300, true);
                      const DepthLevel* first_bid = depth.bids();
                      BOOST_CHECK(verify_level(first_bid, 1234, 3, 600));
                      BOOST_CHECK(cc.verify_bid_changed(true,false, false, false, false));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestAppendBidLevels)
                    {
                      SizedDepth depth;
                      ChangedChecker cc(depth);
                      depth.add_order(1236, 300, true);
                      depth.add_order(1235, 200, true);
                      depth.add_order(1232, 100, true);
                      depth.add_order(1235, 400, true);
                      const DepthLevel* bid = depth.bids();
                      BOOST_CHECK(verify_level(bid, 1236, 1, 300));
                      BOOST_CHECK(verify_level(bid, 1235, 2, 600));
                      BOOST_CHECK(verify_level(bid, 1232, 1, 100));
                      BOOST_CHECK(cc.verify_bid_changed(true, true, true, false, false));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestInsertBidLevels)
                    {
                      SizedDepth depth;
                      ChangedChecker cc(depth);
                      depth.add_order(1234, 800, true);
                    
                      BOOST_CHECK(cc.verify_bid_changed(true, false, false, false, false)); 
                      cc.reset();
                    
                      depth.add_order(1232, 100, true);
                      BOOST_CHECK(cc.verify_bid_changed(false, true, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1236, 300, true);
                      BOOST_CHECK(cc.verify_bid_changed(true, true, true, false, false)); 
                      cc.reset();
                    
                      depth.add_order(1235, 200, true);
                      BOOST_CHECK(cc.verify_bid_changed(false, true, true, true, false));
                      cc.reset();
                    
                      depth.add_order(1234, 900, true);
                      BOOST_CHECK(cc.verify_bid_changed(false, false, true, false, false));
                      cc.reset();
                    
                      depth.add_order(1231, 700, true);
                      BOOST_CHECK(cc.verify_bid_changed(false, false, false, false, true));
                      cc.reset();
                    
                      depth.add_order(1235, 400, true);
                      BOOST_CHECK(cc.verify_bid_changed(false, true, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1231, 500, true);
                      BOOST_CHECK(cc.verify_bid_changed(false, false, false, false, true));
                      cc.reset();
                    
                      depth.add_order(1233, 200, true);
                      BOOST_CHECK(cc.verify_bid_changed(false, false, false, true, true));
                      cc.reset();
                    
                      const DepthLevel* bid = depth.bids();
                      BOOST_CHECK(verify_level(bid, 1236, 1,  300));
                      BOOST_CHECK(verify_level(bid, 1235, 2,  600));
                      BOOST_CHECK(verify_level(bid, 1234, 2, 1700));
                      BOOST_CHECK(verify_level(bid, 1233, 1,  200));
                      BOOST_CHECK(verify_level(bid, 1232, 1,  100));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestInsertBidLevelsPast5)
                    {
                      SizedDepth depth;
                      ChangedChecker cc(depth);
                      depth.add_order(1234, 800, true);
                      BOOST_CHECK(cc.verify_bid_changed(true, false, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1232, 100, true);
                      BOOST_CHECK(cc.verify_bid_changed(false, true, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1236, 300, true);
                      BOOST_CHECK(cc.verify_bid_changed(true, true, true, false, false));
                      cc.reset();
                    
                      depth.add_order(1231, 700, true);
                      BOOST_CHECK(cc.verify_bid_changed(false, false, false, true, false));
                      cc.reset();
                    
                      depth.add_order(1234, 900, true);
                      BOOST_CHECK(cc.verify_bid_changed(false, true, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1235, 400, true);
                      BOOST_CHECK(cc.verify_bid_changed(false, true, true, true, true));
                      cc.reset();
                    
                      depth.add_order(1235, 200, true);
                      BOOST_CHECK(cc.verify_bid_changed(false, true, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1231, 500, true);
                      BOOST_CHECK(cc.verify_bid_changed(false, false, false, false, true));
                      cc.reset();
                    
                      depth.add_order(1230, 200, true);
                    
                      BOOST_CHECK(cc.verify_bid_changed(false, false, false, false, false));
                      cc.reset();
                      depth.add_order(1229, 200, true);
                    
                      BOOST_CHECK(cc.verify_bid_changed(false, false, false, false, false));
                      cc.reset();
                      const DepthLevel* bid = depth.bids();
                      BOOST_CHECK(verify_level(bid, 1236, 1,  300));
                      BOOST_CHECK(verify_level(bid, 1235, 2,  600));
                      BOOST_CHECK(verify_level(bid, 1234, 2, 1700));
                      BOOST_CHECK(verify_level(bid, 1232, 1,  100));
                      BOOST_CHECK(verify_level(bid, 1231, 2, 1200));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestInsertBidLevelsTruncate5)
                    {
                      SizedDepth depth;
                      ChangedChecker cc(depth);
                      depth.add_order(1234, 800, true);
                      BOOST_CHECK(cc.verify_bid_changed(true, false, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1232, 100, true);
                      BOOST_CHECK(cc.verify_bid_changed(false, true, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1236, 300, true);
                      BOOST_CHECK(cc.verify_bid_changed(true, true, true, false, false));
                      cc.reset();
                    
                      depth.add_order(1231, 700, true);
                      BOOST_CHECK(cc.verify_bid_changed(false, false, false, true, false));
                      cc.reset();
                    
                      depth.add_order(1234, 900, true);
                      BOOST_CHECK(cc.verify_bid_changed(false, true, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1235, 400, true);
                      BOOST_CHECK(cc.verify_bid_changed(false, true, true, true, true));
                      cc.reset();
                    
                      depth.add_order(1235, 200, true);
                      BOOST_CHECK(cc.verify_bid_changed(false, true, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1231, 500, true);
                      BOOST_CHECK(cc.verify_bid_changed(false, false, false, false, true));
                      cc.reset();
                    
                      depth.add_order(1230, 200, true);
                      BOOST_CHECK(cc.verify_bid_changed(false, false, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1238, 200, true);
                      BOOST_CHECK(cc.verify_bid_changed(true, true, true, true, true));
                      cc.reset();
                    
                      depth.add_order(1238, 250, true);
                      BOOST_CHECK(cc.verify_bid_changed(true, false, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1237, 500, true);
                      BOOST_CHECK(cc.verify_bid_changed(false, true, true, true, true));
                      cc.reset();
                      const DepthLevel* bid = depth.bids();
                      BOOST_CHECK(verify_level(bid, 1238, 2,  450));
                      BOOST_CHECK(verify_level(bid, 1237, 1,  500));
                      BOOST_CHECK(verify_level(bid, 1236, 1,  300));
                      BOOST_CHECK(verify_level(bid, 1235, 2,  600));
                      BOOST_CHECK(verify_level(bid, 1234, 2, 1700));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestCloseBid)
                    {
                      SizedDepth depth;
                      ChangedChecker cc(depth);
                      depth.add_order(1234, 300, true);
                      BOOST_CHECK(cc.verify_bid_changed(true, false, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1234, 500, true);
                      BOOST_CHECK(cc.verify_bid_changed(true, false, false, false, false));
                      cc.reset();
                    
                      BOOST_CHECK(!depth.close_order(1234, 300, true)); // Does not erase
                      BOOST_CHECK(cc.verify_bid_changed(true, false, false, false, false));
                    
                      const DepthLevel* first_bid = depth.bids();
                      BOOST_CHECK(verify_level(first_bid, 1234, 1, 500));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestCloseEraseBid)
                    {
                      SizedDepth depth;
                      ChangedChecker cc(depth);
                      depth.add_order(1235, 300, true);
                      BOOST_CHECK(cc.verify_bid_changed(true, false, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1235, 400, true);
                      BOOST_CHECK(cc.verify_bid_changed(true, false, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1234, 500, true);
                      BOOST_CHECK(cc.verify_bid_changed(false, true, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1233, 200, true);
                      BOOST_CHECK(cc.verify_bid_changed(false, false, true, false, false));
                      cc.reset();
                    
                      BOOST_CHECK(!depth.close_order(1235, 300, true)); // Does not erase
                      BOOST_CHECK(cc.verify_bid_changed(true, false, false, false, false));
                      cc.reset();
                    
                      BOOST_CHECK(depth.close_order(1235, 400, true)); // Erase
                      BOOST_CHECK(cc.verify_bid_changed(true, true, true, false, false));
                    
                      const DepthLevel* bid = depth.bids();
                      BOOST_CHECK(verify_level(bid, 1234, 1, 500));
                      BOOST_CHECK(verify_level(bid, 1233, 1, 200));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestAddCloseAddBid)
                    {
                      SizedDepth depth;
                      ChangedChecker cc(depth);
                      depth.add_order(1234, 300, true);
                      BOOST_CHECK(cc.verify_bid_changed(true, false, false, false, false));
                      cc.reset();
                      
                      depth.close_order(1234, 300, true);
                      BOOST_CHECK(cc.verify_bid_changed(true, false, false, false, false));
                      cc.reset();
                      
                      depth.add_order(1233, 200, true);
                      BOOST_CHECK(cc.verify_bid_changed(true, false, false, false, false));
                      cc.reset();
                      const DepthLevel* bid = depth.bids();
                      BOOST_CHECK(verify_level(bid, 1233, 1, 200));
                      BOOST_CHECK(verify_level(bid, false, false, false));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestAddCloseAddHigherBid)
                    {
                      SizedDepth depth;
                      ChangedChecker cc(depth);
                      depth.add_order(1234, 300, true);
                      BOOST_CHECK(cc.verify_bid_changed(true, false, false, false, false));
                      cc.reset();
                    
                      depth.close_order(1234, 300, true);
                      BOOST_CHECK(cc.verify_bid_changed(true, false, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1235, 200, true);
                      BOOST_CHECK(cc.verify_bid_changed(true, false, false, false, false));
                      cc.reset();
                    
                      const DepthLevel* bid = depth.bids();
                      BOOST_CHECK(verify_level(bid, 1235, 1, 200));
                      BOOST_CHECK(verify_level(bid, false, false, false));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestCloseBidsFreeLevels)
                    {
                      SizedDepth depth;
                      ChangedChecker cc(depth);
                      depth.add_order(1234, 800, true);
                      BOOST_CHECK(cc.verify_bid_changed(true, false, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1232, 100, true);
                      BOOST_CHECK(cc.verify_bid_changed(false, true, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1236, 300, true);
                      BOOST_CHECK(cc.verify_bid_changed(true, true, true, false, false));
                      cc.reset();
                    
                      depth.add_order(1235, 200, true);
                      BOOST_CHECK(cc.verify_bid_changed(false, true, true, true, false));
                      cc.reset();
                    
                      depth.add_order(1234, 900, true);
                      BOOST_CHECK(cc.verify_bid_changed(false, false, true, false, false));
                      cc.reset();
                    
                      depth.add_order(1231, 700, true);
                      BOOST_CHECK(cc.verify_bid_changed(false, false, false, false, true));
                      cc.reset();
                    
                      depth.add_order(1235, 400, true);
                      BOOST_CHECK(cc.verify_bid_changed(false, true, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1231, 500, true);
                      BOOST_CHECK(cc.verify_bid_changed(false, false, false, false, true));
                      cc.reset();
                    
                      depth.close_order(1234, 900, true); // No erase
                      BOOST_CHECK(cc.verify_bid_changed(false, false, true, false, false));
                      cc.reset();
                    
                      depth.close_order(1232, 100, true); // Erase
                      BOOST_CHECK(cc.verify_bid_changed(false, false, false, true, true));
                      cc.reset();
                    
                      depth.close_order(1236, 300, true); // Erase
                      BOOST_CHECK(cc.verify_bid_changed(true, true, true, true, false));
                      cc.reset();
                    
                      const DepthLevel* bid = depth.bids();
                      BOOST_CHECK(verify_level(bid, 1235, 2,  600));
                      BOOST_CHECK(verify_level(bid, 1234, 1,  800));
                      BOOST_CHECK(verify_level(bid, 1231, 2, 1200));
                      BOOST_CHECK(verify_level(bid,    0, 0,    0));
                      BOOST_CHECK(verify_level(bid,    0, 0,    0));
                    
                      depth.add_order(1233, 350, true); // Insert
                      BOOST_CHECK(cc.verify_bid_changed(false, false, true, true, false));
                      cc.reset();
                    
                      depth.add_order(1236, 300, true); // Insert
                      BOOST_CHECK(cc.verify_bid_changed(true, true, true, true, true));
                      cc.reset();
                    
                      depth.add_order(1231, 700, true);
                      BOOST_CHECK(cc.verify_bid_changed(false, false, false, false, true));
                      cc.reset();
                      bid = depth.bids();  // reset
                      BOOST_CHECK(verify_level(bid, 1236, 1,  300));
                      BOOST_CHECK(verify_level(bid, 1235, 2,  600));
                      BOOST_CHECK(verify_level(bid, 1234, 1,  800));
                      BOOST_CHECK(verify_level(bid, 1233, 1,  350));
                      BOOST_CHECK(verify_level(bid, 1231, 3, 1900));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestIncreaseBid)
                    {
                      SizedDepth depth;
                      ChangedChecker cc(depth);
                      depth.add_order(1236, 300, true);
                      BOOST_CHECK(cc.verify_bid_changed(true, false, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1235, 200, true);
                      BOOST_CHECK(cc.verify_bid_changed(false, true, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1232, 100, true);
                      BOOST_CHECK(cc.verify_bid_changed(false, false, true, false, false));
                      cc.reset();
                    
                      depth.add_order(1235, 400, true);
                      BOOST_CHECK(cc.verify_bid_changed(false, true, false, false, false));
                      cc.reset();
                    
                      depth.change_qty_order(1232, 37, true);
                      BOOST_CHECK(cc.verify_bid_changed(false, false, true, false, false));
                      cc.reset();
                    
                      depth.change_qty_order(1232, 41, true);
                      BOOST_CHECK(cc.verify_bid_changed(false, false, true, false, false));
                      cc.reset();
                    
                      depth.change_qty_order(1235, 201, true);
                      BOOST_CHECK(cc.verify_bid_changed(false, true, false, false, false));
                      cc.reset();
                    
                      const DepthLevel* bid = depth.bids();
                      BOOST_CHECK(verify_level(bid, 1236, 1, 300));
                      BOOST_CHECK(verify_level(bid, 1235, 2, 801));
                      BOOST_CHECK(verify_level(bid, 1232, 1, 178));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestDecreaseBid)
                    {
                      SizedDepth depth;
                      ChangedChecker cc(depth);
                      depth.add_order(1236, 300, true);
                      BOOST_CHECK(cc.verify_bid_changed(true, false, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1235, 200, true);
                      BOOST_CHECK(cc.verify_bid_changed(false, true, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1232, 100, true);
                      BOOST_CHECK(cc.verify_bid_changed(false, false, true, false, false));
                      cc.reset();
                    
                      depth.add_order(1235, 400, true);
                      BOOST_CHECK(cc.verify_bid_changed(false, true, false, false, false));
                      cc.reset();
                    
                      depth.change_qty_order(1236, -37, true);
                      BOOST_CHECK(cc.verify_bid_changed(true, false, false, false, false));
                      cc.reset();
                    
                      depth.change_qty_order(1236, -41, true);
                      BOOST_CHECK(cc.verify_bid_changed(true, false, false, false, false));
                      cc.reset();
                    
                      depth.change_qty_order(1235, -201, true);
                      BOOST_CHECK(cc.verify_bid_changed(false, true, false, false, false));
                      cc.reset();
                    
                      const DepthLevel* bid = depth.bids();
                      BOOST_CHECK(verify_level(bid, 1236, 1, 222));
                      BOOST_CHECK(verify_level(bid, 1235, 2, 399));
                      BOOST_CHECK(verify_level(bid, 1232, 1, 100));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestIncreaseDecreaseBid)
                    {
                      SizedDepth depth;
                      ChangedChecker cc(depth);
                      depth.add_order(1236, 300, true);
                      BOOST_CHECK(cc.verify_bid_changed(true, false, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1235, 200, true);
                      BOOST_CHECK(cc.verify_bid_changed(false, true, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1232, 100, true);
                      BOOST_CHECK(cc.verify_bid_changed(false, false, true, false, false));
                      cc.reset();
                    
                      depth.add_order(1235, 400, true);
                      BOOST_CHECK(cc.verify_bid_changed(false, true, false, false, false));
                      cc.reset();
                    
                      depth.change_qty_order(1236, 37, true);
                      BOOST_CHECK(cc.verify_bid_changed(true, false, false, false, false));
                      cc.reset();
                    
                      depth.change_qty_order(1235, -41, true);
                      BOOST_CHECK(cc.verify_bid_changed(false, true, false, false, false));
                      cc.reset();
                    
                      depth.change_qty_order(1232, 60, true);
                      BOOST_CHECK(cc.verify_bid_changed(false, false, true, false, false));
                      cc.reset();
                    
                      depth.change_qty_order(1236, -41, true);
                      BOOST_CHECK(cc.verify_bid_changed(true, false, false, false, false));
                      cc.reset();
                    
                      depth.change_qty_order(1236, 210, true);
                      BOOST_CHECK(cc.verify_bid_changed(true, false, false, false, false));
                      cc.reset();
                      const DepthLevel* bid = depth.bids();
                      BOOST_CHECK(verify_level(bid, 1236, 1, 506));
                      BOOST_CHECK(verify_level(bid, 1235, 2, 559));
                      BOOST_CHECK(verify_level(bid, 1232, 1, 160));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestAddAsk)
                    {
                      SizedDepth depth;
                      ChangedChecker cc(depth);
                      depth.add_order(1234, 100, false);
                      const DepthLevel* first_ask = depth.asks();
                      BOOST_CHECK(verify_level(first_ask, 1234, 1, 100));
                      BOOST_CHECK(cc.verify_ask_changed(true, false, false, false, false));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestAddAsks)
                    {
                      SizedDepth depth;
                      ChangedChecker cc(depth);
                      depth.add_order(1234, 100, false);
                      BOOST_CHECK(cc.verify_ask_changed(true, false, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1234, 200, false);
                      BOOST_CHECK(cc.verify_ask_changed(true, false, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1234, 300, false);
                      BOOST_CHECK(cc.verify_ask_changed(true, false, false, false, false));
                    
                      const DepthLevel* first_ask = depth.asks();
                      BOOST_CHECK(verify_level(first_ask, 1234, 3, 600));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestAppendAskLevels)
                    {
                      SizedDepth depth;
                      ChangedChecker cc(depth);
                      depth.add_order(1236, 300, false);
                      BOOST_CHECK(cc.verify_ask_changed(true, false, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1235, 200, false);
                      BOOST_CHECK(cc.verify_ask_changed(true, true, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1232, 100, false);
                      BOOST_CHECK(cc.verify_ask_changed(true, true, true, false, false));
                      cc.reset();
                    
                      depth.add_order(1235, 400, false);
                      BOOST_CHECK(cc.verify_ask_changed(false, true, false, false, false));
                      cc.reset();
                      const DepthLevel* ask = depth.asks();
                      BOOST_CHECK(verify_level(ask, 1232, 1, 100));
                      BOOST_CHECK(verify_level(ask, 1235, 2, 600));
                      BOOST_CHECK(verify_level(ask, 1236, 1, 300));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestInsertAskLevels)
                    {
                      SizedDepth depth;
                      ChangedChecker cc(depth);
                      depth.add_order(1234, 800, false);
                      BOOST_CHECK(cc.verify_ask_changed(true, false, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1232, 100, false);
                      BOOST_CHECK(cc.verify_ask_changed(true, true, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1236, 300, false);
                      BOOST_CHECK(cc.verify_ask_changed(false, false, true, false, false));
                      cc.reset();
                    
                      depth.add_order(1235, 200, false);
                      BOOST_CHECK(cc.verify_ask_changed(false, false, true, true, false));
                      cc.reset();
                    
                      depth.add_order(1234, 900, false);
                      BOOST_CHECK(cc.verify_ask_changed(false, true, false, false, false));
                      cc.reset();
                      depth.add_order(1231, 700, false);
                      depth.add_order(1235, 400, false);
                      depth.add_order(1231, 500, false);
                      const DepthLevel* ask = depth.asks();
                      BOOST_CHECK(verify_level(ask, 1231, 2, 1200));
                      BOOST_CHECK(verify_level(ask, 1232, 1,  100));
                      BOOST_CHECK(verify_level(ask, 1234, 2, 1700));
                      BOOST_CHECK(verify_level(ask, 1235, 2,  600));
                      BOOST_CHECK(verify_level(ask, 1236, 1,  300));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestInsertAskLevelsPast5)
                    {
                      SizedDepth depth;
                      ChangedChecker cc(depth);
                      depth.add_order(1234, 800, false);
                      BOOST_CHECK(cc.verify_ask_changed(true, false, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1232, 100, false);
                      BOOST_CHECK(cc.verify_ask_changed(true, true, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1236, 300, false);
                      BOOST_CHECK(cc.verify_ask_changed(false, false, true, false, false));
                      cc.reset();
                    
                      depth.add_order(1231, 700, false);
                      BOOST_CHECK(cc.verify_ask_changed(true, true, true, true, false));
                      cc.reset();
                    
                      depth.add_order(1234, 900, false);
                      BOOST_CHECK(cc.verify_ask_changed(false, false, true, false, false));
                      cc.reset();
                    
                      depth.add_order(1235, 400, false);
                      BOOST_CHECK(cc.verify_ask_changed(false, false, false, true, true));
                      cc.reset();
                    
                      depth.add_order(1235, 200, false);
                      BOOST_CHECK(cc.verify_ask_changed(false, false, false, true, false));
                      cc.reset();
                    
                      depth.add_order(1231, 500, false);
                      BOOST_CHECK(cc.verify_ask_changed(true, false, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1230, 200, false);
                      BOOST_CHECK(cc.verify_ask_changed(true, true, true, true, true));
                      cc.reset();
                    
                      depth.add_order(1229, 200, false);
                      BOOST_CHECK(cc.verify_ask_changed(true, true, true, true, true));
                      cc.reset();
                    
                      const DepthLevel* ask = depth.asks();
                      BOOST_CHECK(verify_level(ask, 1229, 1,  200));
                      BOOST_CHECK(verify_level(ask, 1230, 1,  200));
                      BOOST_CHECK(verify_level(ask, 1231, 2, 1200));
                      BOOST_CHECK(verify_level(ask, 1232, 1,  100));
                      BOOST_CHECK(verify_level(ask, 1234, 2, 1700));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestInsertAskLevelsTruncate5)
                    {
                      SizedDepth depth;
                      ChangedChecker cc(depth);
                      depth.add_order(1234, 800, false);
                      BOOST_CHECK(cc.verify_ask_changed(true, false, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1232, 100, false);
                      BOOST_CHECK(cc.verify_ask_changed(true, true, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1236, 300, false);
                      BOOST_CHECK(cc.verify_ask_changed(false, false, true, false, false));
                      cc.reset();
                    
                      depth.add_order(1231, 700, false);
                      BOOST_CHECK(cc.verify_ask_changed(true, true, true, true, false));
                      cc.reset();
                    
                      depth.add_order(1234, 900, false);
                      BOOST_CHECK(cc.verify_ask_changed(false, false, true, false, false));
                      cc.reset();
                    
                      depth.add_order(1235, 400, false);
                      BOOST_CHECK(cc.verify_ask_changed(false, false, false, true, true));
                      cc.reset();
                    
                      depth.add_order(1235, 200, false);
                      BOOST_CHECK(cc.verify_ask_changed(false, false, false, true, false));
                      cc.reset();
                    
                      depth.add_order(1231, 500, false);
                      BOOST_CHECK(cc.verify_ask_changed(true, false, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1230, 200, false);
                      BOOST_CHECK(cc.verify_ask_changed(true, true, true, true, true));
                      cc.reset();
                    
                      depth.add_order(1238, 200, false);
                      BOOST_CHECK(cc.verify_ask_changed(false, false, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1232, 250, false);
                      BOOST_CHECK(cc.verify_ask_changed(false, false, true, false, false));
                      cc.reset();
                    
                      depth.add_order(1237, 500, false);
                      BOOST_CHECK(cc.verify_ask_changed(false, false, false, false, false));
                      cc.reset();
                      const DepthLevel* ask = depth.asks();
                      BOOST_CHECK(verify_level(ask, 1230, 1,  200));
                      BOOST_CHECK(verify_level(ask, 1231, 2, 1200));
                      BOOST_CHECK(verify_level(ask, 1232, 2,  350));
                      BOOST_CHECK(verify_level(ask, 1234, 2, 1700));
                      BOOST_CHECK(verify_level(ask, 1235, 2,  600));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestCloseAsk)
                    {
                      SizedDepth depth;
                      ChangedChecker cc(depth);
                      depth.add_order(1234, 300, false);
                      BOOST_CHECK(cc.verify_ask_changed(true, false, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1234, 500, false);
                      BOOST_CHECK(cc.verify_ask_changed(true, false, false, false, false));
                      cc.reset();
                      BOOST_CHECK(!depth.close_order(1234, 300, false)); // Does not erase
                      const DepthLevel* first_ask = depth.asks();
                      BOOST_CHECK(verify_level(first_ask, 1234, 1, 500));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestCloseEraseAsk)
                    {
                      SizedDepth depth;
                      ChangedChecker cc(depth);
                      depth.add_order(1233, 300, false);
                      BOOST_CHECK(cc.verify_ask_changed(true, false, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1234, 500, false);
                      BOOST_CHECK(cc.verify_ask_changed(false, true, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1233, 400, false);
                      BOOST_CHECK(cc.verify_ask_changed(true, false, false, false, false));
                      cc.reset();
                    
                      BOOST_CHECK(!depth.close_order(1233, 300, false)); // Does not erase
                      BOOST_CHECK(cc.verify_ask_changed(true, false, false, false, false));
                      cc.reset();
                    
                      BOOST_CHECK(depth.close_order(1233, 400, false)); // Erase
                      BOOST_CHECK(cc.verify_ask_changed(true, true, false, false, false));
                      cc.reset();
                      const DepthLevel* first_ask = depth.asks();
                      BOOST_CHECK(verify_level(first_ask, 1234, 1, 500));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestAddCloseAddAsk)
                    {
                      SizedDepth depth;
                      ChangedChecker cc(depth);
                      depth.add_order(1234, 300, false);
                      BOOST_CHECK(cc.verify_ask_changed(true, false, false, false, false));
                      cc.reset();
                      
                      depth.close_order(1234, 300, false);
                      BOOST_CHECK(cc.verify_ask_changed(true, false, false, false, false));
                      cc.reset();
                      
                      depth.add_order(1233, 200, false);
                      BOOST_CHECK(cc.verify_ask_changed(true, false, false, false, false));
                      cc.reset();
                      const DepthLevel* ask = depth.asks();
                      BOOST_CHECK(verify_level(ask, 1233, 1, 200));
                      BOOST_CHECK(verify_level(ask, false, false, false));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestAddCloseAddHigherAsk)
                    {
                      SizedDepth depth;
                      ChangedChecker cc(depth);
                      depth.add_order(1234, 300, false);
                      BOOST_CHECK(cc.verify_ask_changed(true, false, false, false, false));
                      cc.reset();
                      
                      depth.close_order(1234, 300, false);
                      BOOST_CHECK(cc.verify_ask_changed(true, false, false, false, false));
                      cc.reset();
                      
                      depth.add_order(1235, 200, false);
                      BOOST_CHECK(cc.verify_ask_changed(true, false, false, false, false));  
                      cc.reset();
                      const DepthLevel* ask = depth.asks();
                      BOOST_CHECK(verify_level(ask, 1235, 1, 200));
                      BOOST_CHECK(verify_level(ask, false, false, false));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestCloseAsksFreeLevels)
                    {
                      SizedDepth depth;
                      ChangedChecker cc(depth);
                      depth.add_order(1234, 800, false);
                      BOOST_CHECK(cc.verify_ask_changed(true, false, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1232, 100, false);
                      BOOST_CHECK(cc.verify_ask_changed(true, true, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1236, 300, false);
                      BOOST_CHECK(cc.verify_ask_changed(false, false, true, false, false));
                      cc.reset();
                    
                      depth.add_order(1235, 200, false);
                      BOOST_CHECK(cc.verify_ask_changed(false, false, true, true, false));
                      cc.reset();
                    
                      depth.add_order(1234, 900, false);
                      BOOST_CHECK(cc.verify_ask_changed(false, true, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1231, 700, false);
                      BOOST_CHECK(cc.verify_ask_changed(true, true, true, true, true));
                      cc.reset();
                    
                      depth.add_order(1235, 400, false);
                      BOOST_CHECK(cc.verify_ask_changed(false, false, false, true, false));
                      cc.reset();
                    
                      depth.add_order(1231, 500, false);
                      BOOST_CHECK(cc.verify_ask_changed(true, false, false, false, false));
                      cc.reset();
                    
                      depth.close_order(1234, 900, false); // does not erase
                      BOOST_CHECK(cc.verify_ask_changed(false, false, true, false, false));
                      cc.reset();
                    
                      depth.close_order(1232, 100, false); // erase
                      BOOST_CHECK(cc.verify_ask_changed(false, true, true, true, true));
                      cc.reset();
                      depth.close_order(1236, 100, false);
                      BOOST_CHECK(cc.verify_ask_changed(false, false, false, true, false));
                      cc.reset();
                      const DepthLevel* ask = depth.asks();
                      BOOST_CHECK(verify_level(ask, 1231, 2, 1200));
                      BOOST_CHECK(verify_level(ask, 1234, 1,  800));
                      BOOST_CHECK(verify_level(ask, 1235, 2,  600));
                      BOOST_CHECK(verify_level(ask,    0, 0,    0));
                      BOOST_CHECK(verify_level(ask,    0, 0,    0));
                      depth.add_order(1233, 350, false);
                      depth.add_order(1236, 300, false);
                      depth.add_order(1231, 700, false);
                      ask = depth.asks();  // reset
                      BOOST_CHECK(verify_level(ask, 1231, 3, 1900));
                      BOOST_CHECK(verify_level(ask, 1233, 1,  350));
                      BOOST_CHECK(verify_level(ask, 1234, 1,  800));
                      BOOST_CHECK(verify_level(ask, 1235, 2,  600));
                      BOOST_CHECK(verify_level(ask, 1236, 1,  300));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestIncreaseAsk)
                    {
                      SizedDepth depth;
                      ChangedChecker cc(depth);
                      depth.add_order(1236, 300, false);
                      BOOST_CHECK(cc.verify_ask_changed(true, false, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1235, 200, false);
                      BOOST_CHECK(cc.verify_ask_changed(true, true, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1232, 100, false);
                      BOOST_CHECK(cc.verify_ask_changed(true, true, true, false, false));
                      cc.reset();
                    
                      depth.add_order(1235, 400, false);
                      BOOST_CHECK(cc.verify_ask_changed(false, true, false, false, false));
                      cc.reset();
                    
                      depth.change_qty_order(1232, 37, false);
                      BOOST_CHECK(cc.verify_ask_changed(true, false, false, false, false));
                      cc.reset();
                    
                      depth.change_qty_order(1232, 41, false);
                      BOOST_CHECK(cc.verify_ask_changed(true, false, false, false, false));
                      cc.reset();
                    
                      depth.change_qty_order(1235, 201, false);
                      BOOST_CHECK(cc.verify_ask_changed(false, true, false, false, false));
                      cc.reset();
                      const DepthLevel* ask = depth.asks();
                      BOOST_CHECK(verify_level(ask, 1232, 1, 178));
                      BOOST_CHECK(verify_level(ask, 1235, 2, 801));
                      BOOST_CHECK(verify_level(ask, 1236, 1, 300));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestDecreaseAsk)
                    {
                      SizedDepth depth;
                      ChangedChecker cc(depth);
                      depth.add_order(1236, 300, false);
                      BOOST_CHECK(cc.verify_ask_changed(true, false, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1235, 200, false);
                      BOOST_CHECK(cc.verify_ask_changed(true, true, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1232, 100, false);
                      BOOST_CHECK(cc.verify_ask_changed(true, true, true, false, false));
                      cc.reset();
                    
                      depth.add_order(1235, 400, false);
                      BOOST_CHECK(cc.verify_ask_changed(false, true, false, false, false));
                      cc.reset();
                    
                      depth.change_qty_order(1236, -37, false);
                      BOOST_CHECK(cc.verify_ask_changed(false, false, true, false, false));
                      cc.reset();
                    
                      depth.change_qty_order(1236, -41, false);
                      BOOST_CHECK(cc.verify_ask_changed(false, false, true, false, false));
                      cc.reset();
                    
                      depth.change_qty_order(1235, -201, false);
                      BOOST_CHECK(cc.verify_ask_changed(false, true, false, false, false));
                      cc.reset();
                      const DepthLevel* ask = depth.asks();
                      BOOST_CHECK(verify_level(ask, 1232, 1, 100));
                      BOOST_CHECK(verify_level(ask, 1235, 2, 399));
                      BOOST_CHECK(verify_level(ask, 1236, 1, 222));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestIncreaseDecreaseAsk)
                    {
                      SizedDepth depth;
                      ChangedChecker cc(depth);
                      depth.add_order(1236, 300, false);
                      BOOST_CHECK(cc.verify_ask_changed(true, false, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1235, 200, false);
                      BOOST_CHECK(cc.verify_ask_changed(true, true, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1232, 100, false);
                      BOOST_CHECK(cc.verify_ask_changed(true, true, true, false, false));
                      cc.reset();
                    
                      depth.add_order(1235, 400, false);
                      BOOST_CHECK(cc.verify_ask_changed(false, true, false, false, false));
                      cc.reset();
                    
                      depth.change_qty_order(1236, 37, false);
                      BOOST_CHECK(cc.verify_ask_changed(false, false, true, false, false));
                      cc.reset();
                    
                      depth.change_qty_order(1235, -41, false);
                      BOOST_CHECK(cc.verify_ask_changed(false, true, false, false, false));
                      cc.reset();
                    
                      depth.change_qty_order(1232, 51, false);
                      BOOST_CHECK(cc.verify_ask_changed(true, false, false, false, false));
                      cc.reset();
                    
                      depth.change_qty_order(1236, -41, false);
                      BOOST_CHECK(cc.verify_ask_changed(false, false, true, false, false));
                      cc.reset();
                    
                      depth.change_qty_order(1236, 201, false);
                      BOOST_CHECK(cc.verify_ask_changed(false, false, true, false, false));
                      cc.reset();
                      const DepthLevel* ask = depth.asks();
                      BOOST_CHECK(verify_level(ask, 1232, 1, 151));
                      BOOST_CHECK(verify_level(ask, 1235, 2, 559));
                      BOOST_CHECK(verify_level(ask, 1236, 1, 497));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestReplaceBid)
                    {
                      SizedDepth depth;
                      ChangedChecker cc(depth);
                      depth.add_order(1236, 300, true);
                      BOOST_CHECK(cc.verify_bid_changed(true, false, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1235, 200, true);
                      BOOST_CHECK(cc.verify_bid_changed(false, true, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1232, 100, true);
                      BOOST_CHECK(cc.verify_bid_changed(false, false, true, false, false));
                      cc.reset();
                    
                      depth.add_order(1235, 400, true);
                      BOOST_CHECK(cc.verify_bid_changed(false, true, false, false, false));
                      cc.reset();
                    
                    
                      // Verify Levels 
                      const DepthLevel* bid = depth.bids();
                      BOOST_CHECK(verify_level(bid, 1236, 1, 300));
                      BOOST_CHECK(verify_level(bid, 1235, 2, 600));
                      BOOST_CHECK(verify_level(bid, 1232, 1, 100));
                    
                      // Replace bid
                      depth.replace_order(1235, 1237, 200, 200, true);
                    
                      // Verify Levels 
                      bid = depth.bids();
                      BOOST_CHECK(verify_level(bid, 1237, 1, 200));
                      BOOST_CHECK(verify_level(bid, 1236, 1, 300));
                      BOOST_CHECK(verify_level(bid, 1235, 1, 400));
                      BOOST_CHECK(verify_level(bid, 1232, 1, 100));
                    
                      BOOST_CHECK(cc.verify_bid_changed(true, true, true, true, false));
                      cc.reset();
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestReplaceAsk)
                    {
                      SizedDepth depth;
                      ChangedChecker cc(depth);
                      depth.add_order(1236, 300, false);
                      BOOST_CHECK(cc.verify_ask_changed(true, false, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1235, 200, false);
                      BOOST_CHECK(cc.verify_ask_changed(true, true, false, false, false));
                      cc.reset();
                    
                      depth.add_order(1232, 100, false);
                      BOOST_CHECK(cc.verify_ask_changed(true, true, true, false, false));
                      cc.reset();
                    
                      depth.add_order(1235, 400, false);
                      BOOST_CHECK(cc.verify_ask_changed(false, true, false, false, false));
                      cc.reset();
                    
                      // Verify Levels 
                      const DepthLevel* ask = depth.asks();
                      BOOST_CHECK(verify_level(ask, 1232, 1, 100));
                      BOOST_CHECK(verify_level(ask, 1235, 2, 600));
                      BOOST_CHECK(verify_level(ask, 1236, 1, 300));
                    
                      // Replace ask
                      depth.replace_order(1235, 1237, 200, 200, false);
                    
                      // Verify Levels 
                      ask = depth.asks();
                      BOOST_CHECK(verify_level(ask, 1232, 1, 100));
                      BOOST_CHECK(verify_level(ask, 1235, 1, 400));
                      BOOST_CHECK(verify_level(ask, 1236, 1, 300));
                      BOOST_CHECK(verify_level(ask, 1237, 1, 200));
                    
                      BOOST_CHECK(cc.verify_ask_changed(false, true, false, true, false));
                      cc.reset();
                    }
                    
                    } // namespace
                </[ut_depth.cpp]>
                <[ut_all_or_none.cpp]>
                    // Copyright (c) 2012 - 2017 Object Computing, Inc.
                    // All rights reserved.
                    // See the file license.txt for licensing information.
                    
                    #define BOOST_TEST_NO_MAIN LiquibookTest
                    #include <boost/test/unit_test.hpp>
                    
                    #include "ut_utils.h"
                    
                    namespace liquibook {
                    
                    using simple::SimpleOrder;
                    typedef FillCheck<SimpleOrder*> SimpleFillCheck;
                    
                    namespace {
                    const OrderConditions AON(oc_all_or_none);
                    const OrderConditions noConditions(0);
                    
                    const Quantity qty1 = 100;
                    const Quantity qty2 = qty1 + qty1;
                    const Quantity qty3 = qty2 + qty1;
                    const Quantity qty4 = qty2 + qty2;
                    const Quantity qty6 = qty2 + qty4;
                    const Quantity qty7 = 700; // derive this?
                    const Quantity qtyNone = 0;
                    
                    const Price prc0 = 1250;
                    const Price prc1 = 1251;
                    const Price prc2 = 1252;
                    const Price prc3 = 1253;
                    const Price prcNone = 0;
                    const Price MARKET_ORDER_PRICE = MARKET_ORDER_PRICE;
                    
                    const bool buySide = true;
                    const bool sellSide = false;
                    const bool expectMatch = true;
                    const bool expectNoMatch = false;
                    const bool expectComplete = true;
                    const bool expectNoComplete = false;
                    
                    }
                    
                    
                    BOOST_AUTO_TEST_CASE(TestRegBidMatchAon)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask2(sellSide, prc2, qty1);
                      SimpleOrder ask1(sellSide, prc1, qty1); // AON
                      SimpleOrder ask0(sellSide, prc1, qty2); // AON, but skipped
                      SimpleOrder bid1(buySide, prc1, qty1);
                      SimpleOrder bid0(buySide, prc0, qty1);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, expectNoMatch));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, expectNoMatch, expectNoComplete, AON));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, expectNoMatch, expectNoComplete, AON));
                      BOOST_CHECK(add_and_verify(order_book, &ask2, expectNoMatch));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1UL, order_book.bids().size());
                      BOOST_CHECK_EQUAL(3UL, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(prc0, 1, qty1));
                      BOOST_CHECK(dc.verify_ask(prc1, 2, qty1 + qty2));
                      BOOST_CHECK(dc.verify_ask(prc2, 1, qty1));
                    
                      // Match - complete
                      {
                        SimpleFillCheck fc1(&bid1, qty1, prc1 * qty1);
                        SimpleFillCheck fc2(&ask1, qty1, prc1 * qty1);
                        BOOST_CHECK(add_and_verify(order_book, &bid1, expectMatch, expectComplete));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(prc0, 1, qty1));
                      BOOST_CHECK(dc.verify_ask(prc1, 1, qty2));
                      BOOST_CHECK(dc.verify_ask(prc2, 1, qty1));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestRegBidMatchMulti)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask2(sellSide, prc1, qty7);
                      SimpleOrder ask1(sellSide, prc1, qty1); // AON
                      SimpleOrder ask0(sellSide, prc1, qty1); // AON
                      SimpleOrder bid1(buySide, prc1, qty4);
                      SimpleOrder bid0(buySide, prc0, qty1);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, expectNoMatch));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, expectNoMatch, expectNoComplete, AON));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, expectNoMatch, expectNoComplete, AON));
                      BOOST_CHECK(add_and_verify(order_book, &ask2, expectNoMatch, expectNoComplete));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(3, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(prc0, 1, qty1));
                      BOOST_CHECK(dc.verify_ask(prc1, 3, qty7 + qty1 + qty1));
                    
                      // Match - complete
                      {
                        SimpleFillCheck fc0(&bid1, qty4, prc1 * qty4);
                        SimpleFillCheck fc1(&ask0, qty1, prc1 * qty1);
                        SimpleFillCheck fc2(&ask1, qty1, prc1 * qty1);
                        SimpleFillCheck fc3(&ask2, qty2, prc1 * qty2);
                        BOOST_CHECK(add_and_verify(order_book, &bid1, expectMatch, expectComplete));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(prc0, 1, qty1));
                      BOOST_CHECK(dc.verify_ask(prc1, 1, qty4 + qty1));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestAonBidNoMatch)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask1(sellSide, prc2, qty1); // no match, price
                      SimpleOrder ask0(sellSide, prc1, qty1); 
                      SimpleOrder bid1(buySide, prc1, qty3); // no match, AON
                      SimpleOrder bid0(buySide, prc0, qty1); // no match, price
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, expectNoMatch));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, expectNoMatch));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, expectNoMatch));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(prc0, 1, qty1));
                      BOOST_CHECK(dc.verify_ask(prc1, 1, qty1));
                      BOOST_CHECK(dc.verify_ask(prc2, 1, qty1));
                    
                      // Match - complete
                      {
                        SimpleFillCheck fc1(&bid1, qtyNone, prcNone);
                        SimpleFillCheck fc2(&ask0, qtyNone, prcNone);
                        BOOST_CHECK(add_and_verify(order_book, &bid1, expectNoMatch, expectNoComplete, AON));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(prc1, 1, qty3));
                      BOOST_CHECK(dc.verify_bid(prc0, 1, qty1));
                      BOOST_CHECK(dc.verify_ask(prc1, 1, qty1));
                      BOOST_CHECK(dc.verify_ask(prc2, 1, qty1));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(2, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestAonBidMatchReg)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask1(sellSide, prc2, qty1);
                      SimpleOrder ask0(sellSide, prc1, qty4);
                      SimpleOrder bid1(buySide, prc1, qty3); // AON
                      SimpleOrder bid0(buySide, prc0, qty1);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, expectNoMatch));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, expectNoMatch));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, expectNoMatch));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(prc0, 1, qty1));
                      BOOST_CHECK(dc.verify_ask(prc1, 1, qty4));
                      BOOST_CHECK(dc.verify_ask(prc2, 1, qty1));
                    
                      // Match - complete
                      {
                        SimpleFillCheck fc1(&bid1, qty3, prc1 * qty3);
                        SimpleFillCheck fc2(&ask0, qty3, prc1 * qty3);
                        BOOST_CHECK(add_and_verify(order_book, &bid1, expectMatch, expectComplete, AON));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(prc0, 1, qty1));
                      BOOST_CHECK(dc.verify_ask(prc1, 1, qty1));
                      BOOST_CHECK(dc.verify_ask(prc2, 1, qty1));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestAonBidMatchMulti)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask3(sellSide, prc2, qty1);
                      SimpleOrder ask2(sellSide, prc2, qty1);
                      SimpleOrder ask1(sellSide, prc1, qty4); // AON no match
                      SimpleOrder ask0(sellSide, prc1, qty4);
                      SimpleOrder bid1(buySide, MARKET_ORDER_PRICE, qty6); // AON
                      SimpleOrder bid0(buySide, prc0, qty1);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, expectNoMatch));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, expectNoMatch));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, expectNoMatch, expectNoComplete, AON));
                      BOOST_CHECK(add_and_verify(order_book, &ask2, expectNoMatch));
                      BOOST_CHECK(add_and_verify(order_book, &ask3, expectNoMatch));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(4, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(prc0, 1, qty1));
                      BOOST_CHECK(dc.verify_ask(prc1, 2, qty4 + qty4));
                      BOOST_CHECK(dc.verify_ask(prc2, 2, qty1 + qty1));
                    
                      // Match - complete
                      { 
                      //ASSERT_NO_THROW(
                        SimpleFillCheck fc1(&bid1, qty6, prc1 * qty2 + prc1 * qty4);
                        SimpleFillCheck fc2(&ask0, qty2, prc1 * qty2);
                        SimpleFillCheck fc3(&ask1, qty4, prc1 * qty4);
                        SimpleFillCheck fc4(&ask2, 0, prc2 * 0);
                        SimpleFillCheck fc5(&ask3, 0, prc2 * 0);
                        BOOST_CHECK(add_and_verify(order_book, &bid1, expectMatch, expectComplete, AON));
                      //); 
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(prc0, 1, qty1));
                      BOOST_CHECK(dc.verify_ask(prc1, 1, qty2));
                      BOOST_CHECK(dc.verify_ask(prc2, 2, qty1 + qty1));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(3, order_book.asks().size());
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestAonBidNoMatchMulti)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask2(sellSide, prc2, qty4); // AON no match
                      SimpleOrder ask1(sellSide, prc2, qty1);
                      SimpleOrder ask0(sellSide, prc1, qty4);
                      SimpleOrder bid1(buySide, MARKET_ORDER_PRICE, qty6); // AON
                      SimpleOrder bid0(buySide, prc0, qty1);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, expectNoMatch));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, expectNoMatch));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, expectNoMatch));
                      BOOST_CHECK(add_and_verify(order_book, &ask2, expectNoMatch, expectNoComplete, AON));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(3, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(prc0, 1, qty1));
                      BOOST_CHECK(dc.verify_ask(prc1, 1, qty4));
                      BOOST_CHECK(dc.verify_ask(prc2, 2, qty4 + qty1));
                    
                      // Match - complete
                      { 
                      //ASSERT_NO_THROW(
                        SimpleFillCheck fc0(&bid0, qtyNone, prcNone);
                        SimpleFillCheck fc1(&bid1, qty6, qty2 * prc1 + qty4 * prc2); // filled 600 @ 751000
                        SimpleFillCheck fc2(&ask0, qty2, qty2 * prc1); // filled 200 @ 250200
                        SimpleFillCheck fc3(&ask1, qtyNone, prcNone); // 0
                        SimpleFillCheck fc4(&ask2, qty4, qty4 * prc2); // filled 400 @ 500800
                        BOOST_CHECK(add_and_verify(order_book, &bid1, expectMatch, expectComplete, AON));
                      //); 
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(prc0, 1, qty1));
                      BOOST_CHECK(dc.verify_ask(prc1, 1, qty2));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestAonBidMatchAon)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask1(sellSide, prc2, qty1);
                      SimpleOrder ask0(sellSide, prc1, qty3); // AON
                      SimpleOrder bid1(buySide, prc1, qty3); // AON
                      SimpleOrder bid0(buySide, prc0, qty1);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, expectNoMatch));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, expectNoMatch, expectNoComplete, AON));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, expectNoMatch));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(prc0, 1, qty1));
                      BOOST_CHECK(dc.verify_ask(prc1, 1, qty3));
                      BOOST_CHECK(dc.verify_ask(prc2, 1, qty1));
                    
                      // Match - complete
                      {
                        SimpleFillCheck fc1(&bid1, qty3, prc1 * qty3);
                        SimpleFillCheck fc2(&ask0, qty3, prc1 * qty3);
                        BOOST_CHECK(add_and_verify(order_book, &bid1, expectMatch, expectComplete, AON));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(prc0, 1, qty1));
                      BOOST_CHECK(dc.verify_ask(prc2, 1, qty1));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestRegAskMatchAon)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask0(sellSide, prc2, qty1);
                      SimpleOrder ask1(sellSide, prc1, qty1);
                      SimpleOrder bid1(buySide, prc1, qty2); // AON, but skipped
                      SimpleOrder bid2(buySide, prc1, qty1); // AON
                      SimpleOrder bid0(buySide, prc0, qty1);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, expectNoMatch));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, expectNoMatch, expectNoComplete, AON));
                      BOOST_CHECK(add_and_verify(order_book, &bid2, expectNoMatch, expectNoComplete, AON));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, expectNoMatch));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(3, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(prc1, 2, qty3));
                      BOOST_CHECK(dc.verify_bid(prc0, 1, qty1));
                      BOOST_CHECK(dc.verify_ask(prc2, 1, qty1));
                    
                      // Match - complete
                      {
                        SimpleFillCheck fc1(&bid2, qty1, prc1 * qty1);
                        SimpleFillCheck fc2(&ask1, qty1, prc1 * qty1);
                        BOOST_CHECK(add_and_verify(order_book, &ask1, expectMatch, expectComplete));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(prc1, 1, qty2));
                      BOOST_CHECK(dc.verify_bid(prc0, 1, qty1));
                      BOOST_CHECK(dc.verify_ask(prc2, 1, qty1));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(2, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestRegAskMatchMulti)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask0(sellSide, prc2, qty1);
                      SimpleOrder ask1(sellSide, prc0, qty4);
                      SimpleOrder bid1(buySide, prc1, qty1); // AON
                      SimpleOrder bid2(buySide, prc1, qty1); // AON
                      SimpleOrder bid0(buySide, prc0, qty7);
                    
                      // Calculate some expected results
                      // ask1(400) matches bid 1(100), bid2(100), and part(200) of bid0 
                      // leaving 500 shares of bid 0)
                      Quantity bid0FillQty = qty4 - qty1 - qty1;
                      Quantity bid0RemainQty = qty7 - bid0FillQty;
                      uint32_t bid0FillAmount = bid0FillQty * prc0;
                      uint32_t bid1FillAmount = prc1 * qty1;
                      uint32_t bid2FillAmount = prc1 * qty1;
                      uint32_t ask1FillAmount = bid1FillAmount + bid2FillAmount + bid0FillAmount;
                      
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &ask0, expectNoMatch));
                      BOOST_CHECK(add_and_verify(order_book, &bid0, expectNoMatch));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, expectNoMatch, expectNoComplete, AON));
                      BOOST_CHECK(add_and_verify(order_book, &bid2, expectNoMatch, expectNoComplete, AON));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(3, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(prc1, 2, qty2));
                      BOOST_CHECK(dc.verify_bid(prc0, 1, qty7));
                      BOOST_CHECK(dc.verify_ask(prc2, 1, qty1));
                    
                      // Match - complete
                      {
                        SimpleFillCheck fc0(&bid1, qty1, prc1 * qty1);
                        SimpleFillCheck fc1(&bid2, qty1, prc1 * qty1);
                        SimpleFillCheck fc2(&bid0, qty2, prc0 * qty2);
                        SimpleFillCheck fc3(&ask1, qty4, ask1FillAmount);
                        BOOST_CHECK(add_and_verify(order_book, &ask1, expectMatch, expectComplete));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(prc0, 1, bid0RemainQty));
                      BOOST_CHECK(dc.verify_ask(prc2, 1, qty1));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestAonAskNoMatch)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask0(sellSide, prc2, qty1);
                      SimpleOrder ask1(sellSide, prc1, qty4); // AON
                      SimpleOrder bid1(buySide, prc1, qty1);
                      SimpleOrder bid2(buySide, prc1, qty1);
                      SimpleOrder bid0(buySide, prc0, qty7);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &ask0, expectNoMatch));
                      BOOST_CHECK(add_and_verify(order_book, &bid0, expectNoMatch));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, expectNoMatch));
                      BOOST_CHECK(add_and_verify(order_book, &bid2, expectNoMatch));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(3, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(prc1, 2, qty2));
                      BOOST_CHECK(dc.verify_bid(prc0, 1, qty7));
                      BOOST_CHECK(dc.verify_ask(prc2, 1, qty1));
                    
                      // Match - complete
                      {
                        SimpleFillCheck fc0(&bid1, qtyNone, prcNone);
                        SimpleFillCheck fc1(&bid2, qtyNone, prcNone);
                        SimpleFillCheck fc2(&bid0, qtyNone, prcNone);
                        SimpleFillCheck fc3(&ask1, qtyNone, prcNone);
                        BOOST_CHECK(add_and_verify(order_book, &ask1, expectNoMatch, expectNoComplete, AON));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(prc1, 2, qty2));
                      BOOST_CHECK(dc.verify_bid(prc0, 1, qty7));
                      BOOST_CHECK(dc.verify_ask(prc1, 1, qty4));
                      BOOST_CHECK(dc.verify_ask(prc2, 1, qty1));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(3, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestAonAskMatchReg)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask0(sellSide, prc2, qty1);
                      SimpleOrder ask1(sellSide, prc1, qty1); // AON
                      SimpleOrder bid1(buySide, prc1, qty1);
                      SimpleOrder bid0(buySide, prc0, qty7);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &ask0, expectNoMatch));
                      BOOST_CHECK(add_and_verify(order_book, &bid0, expectNoMatch));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, expectNoMatch));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(2, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(prc1, 1, qty1));
                      BOOST_CHECK(dc.verify_bid(prc0, 1, qty7));
                      BOOST_CHECK(dc.verify_ask(prc2, 1, qty1));
                    
                      // Match - complete
                      {
                        SimpleFillCheck fc0(&bid1, qty1, prc1 * qty1);
                        SimpleFillCheck fc3(&ask1, qty1, prc1 * qty1);
                        BOOST_CHECK(add_and_verify(order_book, &ask1, expectMatch, expectComplete, AON));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(prc0, 1, qty7));
                      BOOST_CHECK(dc.verify_ask(prc2, 1, qty1));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestAonAskMatchMulti)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask0(sellSide, prc2, qty1); // no match due to price
                      SimpleOrder ask1(sellSide, prc0, qty6); // AON
                      SimpleOrder bid1(buySide, prc1, qty1); // AON
                      SimpleOrder bid2(buySide, prc1, qty1);
                      SimpleOrder bid3(buySide, prc1, qty1);
                      SimpleOrder bid0(buySide, prc0, qty7);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &ask0, expectNoMatch));
                      BOOST_CHECK(add_and_verify(order_book, &bid0, expectNoMatch));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, expectNoMatch, expectNoComplete, AON));
                      BOOST_CHECK(add_and_verify(order_book, &bid2, expectNoMatch));
                      BOOST_CHECK(add_and_verify(order_book, &bid3, expectNoMatch));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(4, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(prc1, 3, qty3));
                      BOOST_CHECK(dc.verify_bid(prc0, 1, qty7));
                      BOOST_CHECK(dc.verify_ask(prc2, 1, qty1));
                    
                      // Match - complete
                      { 
                      // ASSERT_NO_THROW(
                        
                        uint32_t b1Cost = prc1 * qty1;
                        SimpleFillCheck fc0(&bid1, qty1, b1Cost);
                        uint32_t b2Cost = prc1 * qty1;
                        SimpleFillCheck fc1(&bid2, qty1, b2Cost);
                        uint32_t b3Cost = prc1 * qty1;
                        SimpleFillCheck fc2(&bid3, qty1, b3Cost);
                        Quantity b0Fill = qty6 - qty1 - qty1 - qty1;
                        uint32_t b0Cost = b0Fill * prc0;
                        SimpleFillCheck fc3(&bid0, b0Fill, b0Cost);
                        uint32_t a1Cost = b0Cost + b1Cost +b2Cost + b3Cost;
                        SimpleFillCheck fc4(&ask1, qty6, a1Cost);
                        BOOST_CHECK(add_and_verify(order_book, &ask1, expectMatch, expectComplete, AON));
                      // ); 
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(prc0, 1, qty4));
                      BOOST_CHECK(dc.verify_ask(prc2, 1, qty1));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    }
                    ///////////////////
                    
                    BOOST_AUTO_TEST_CASE(TestOneAonBidOneAonAsk)
                    {
                        SimpleOrderBook order_book;
                        SimpleOrder bid1(buySide,prc1,qty1); // AON
                        SimpleOrder ask1(sellSide,prc1,qty1); // AON
                    
                        // Prime the order book: No Matches
                        BOOST_CHECK(add_and_verify(order_book,&bid1,expectNoMatch,expectNoComplete,AON));
                    
                        // Verify sizes
                        BOOST_CHECK_EQUAL(1u,order_book.bids().size());
                        BOOST_CHECK_EQUAL(0u,order_book.asks().size());
                    
                        // Verify depth
                        DepthCheck<SimpleOrderBook> dc(order_book.depth());
                        BOOST_CHECK(dc.verify_bid(prc1 , 1, qty1));
                    
                        // Add matching order
                        {
                            SimpleFillCheck fc1(&bid1,qty1, qty1 * prc1);
                            SimpleFillCheck fc3(&ask1,qty1, qty1 * prc1);
                            BOOST_CHECK(add_and_verify(order_book, &ask1, expectMatch, expectComplete, AON));
                        }
                    
                        // Verify sizes
                        BOOST_CHECK_EQUAL(0,order_book.bids().size());
                        BOOST_CHECK_EQUAL(0,order_book.asks().size());
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestTwoAonBidOneAonAsk)
                    {
                        SimpleOrderBook order_book;
                        SimpleOrder bid1(buySide,prc1,qty1); // AON
                        SimpleOrder bid2(buySide,prc1,qty2); // AON
                        SimpleOrder ask1(sellSide,prc1,qty3); // AON
                    
                        // Prime the order book: No Matches
                        BOOST_CHECK(add_and_verify(order_book, &bid1, expectNoMatch, expectNoComplete,AON));//AON)); //noConditions
                        BOOST_CHECK(add_and_verify(order_book, &bid2,expectNoMatch,expectNoComplete,AON));
                    
                        // Verify sizes
                        BOOST_CHECK_EQUAL(2u,order_book.bids().size());
                        BOOST_CHECK_EQUAL(0u,order_book.asks().size());
                    
                        // Verify depth
                        DepthCheck<SimpleOrderBook> dc(order_book.depth());
                        BOOST_CHECK(dc.verify_bid(prc1, 2, qty1 + qty2));
                    
                        // Add matching order
                        {
                            SimpleFillCheck fc1(&bid1, qty1, qty1 * prc1);
                            SimpleFillCheck fc2(&bid2, qty2, qty2 * prc1);
                            SimpleFillCheck fc3(&ask1, qty3, qty3 * prc1);
                            BOOST_CHECK(add_and_verify(order_book, &ask1, expectMatch, expectComplete, AON));
                        }
                    
                        // Verify sizes
                        BOOST_CHECK_EQUAL(0,order_book.bids().size());
                        BOOST_CHECK_EQUAL(0,order_book.asks().size());
                    
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestOneAonBidTwoAsk)
                    {
                        SimpleOrderBook order_book;
                    
                        SimpleOrder bid1(buySide,prc1,qty3); // AON
                        SimpleOrder ask1(sellSide,prc1,qty1); // No Conditions
                        SimpleOrder ask2(sellSide,prc1,qty2); // No Conditions
                    
                        // Prime the order book: No Matches
                        BOOST_CHECK(add_and_verify(order_book,&bid1,expectNoMatch,expectNoComplete,AON));//AON)); //noConditions
                    
                        // Add an order that does NOT meet the AON condition
                        BOOST_CHECK(add_and_verify(order_book,&ask1,expectNoMatch,expectNoComplete,noConditions));
                        // Verify sizes
                        BOOST_CHECK_EQUAL(1u,order_book.bids().size());
                        BOOST_CHECK_EQUAL(1u,order_book.asks().size());
                    
                        // Verify depth
                        DepthCheck<SimpleOrderBook> dc(order_book.depth());
                        BOOST_CHECK(dc.verify_bid(prc1,1,qty3));
                        BOOST_CHECK(dc.verify_ask(prc1,1,qty1));
                    
                        // Add matching order
                        {
                            SimpleFillCheck fc1(&bid1,qty3,qty3 * prc1);
                        SimpleFillCheck fc2(&ask1,qty1,qty1 * prc1);
                        SimpleFillCheck fc3(&ask2,qty2,qty2 * prc1);
                        BOOST_CHECK(add_and_verify(order_book,&ask2,expectMatch,expectComplete,noConditions));
                        }
                    
                        // Verify sizes
                        BOOST_CHECK_EQUAL(0,order_book.bids().size());
                        BOOST_CHECK_EQUAL(0,order_book.asks().size());
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestOneBidTwoAonAsk)
                    {
                        SimpleOrderBook order_book;
                    
                        SimpleOrder bid1(buySide,prc1,qty3); // noConditions
                        SimpleOrder ask1(sellSide,prc1,qty1); // AON 
                        SimpleOrder ask2(sellSide,prc1,qty2); // AON
                    
                        // Prime the order book: No Matches
                        BOOST_CHECK(add_and_verify(order_book,&bid1,expectNoMatch,expectNoComplete,AON));
                    
                        // Verify sizes
                        BOOST_CHECK_EQUAL(1u,order_book.bids().size());
                        BOOST_CHECK_EQUAL(0u,order_book.asks().size());
                    
                        // Verify depth
                        DepthCheck<SimpleOrderBook> dc(order_book.depth());
                        BOOST_CHECK(dc.verify_bid(prc1,1,qty3));
                    
                        // Add matching order
                        {
                            SimpleFillCheck fc1(&bid1,qty3,qty3 * prc1);
                            SimpleFillCheck fc2(&ask1,qty1,qty1 * prc1);
                            SimpleFillCheck fc3(&ask2,qty2,qty2 * prc1);
                            BOOST_CHECK(add_and_verify(order_book,&ask1,expectNoMatch,expectNoComplete,noConditions));
                            BOOST_CHECK(add_and_verify(order_book,&ask2,expectMatch,expectComplete,noConditions));
                        }
                    
                        // Verify sizes
                        BOOST_CHECK_EQUAL(0,order_book.bids().size());
                        BOOST_CHECK_EQUAL(0,order_book.asks().size());
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestTwoAonBidTwoAonAsk)
                    {
                    #if 1
                        int todo_FixTestAonsTwoBidTwoAsk;
                        std::cout << "***** WARNING TEST " << "TestAonsTwoBidTwoAsk" << " is disabled" << std::endl;
                    #else
                      // The current match algorithm tries to match one order from one side of the market to "N" orders
                      // from the other side.   This test won't pass because it requires two orders from each side.
                      // I'm leaving the test here as a challenge to future developers who want to improve the matching
                      // algorithm (good luck)
                    
                      SimpleOrderBook order_book;
                    
                      SimpleOrder ask1(sellSide,prc1,qty3); // AON
                      SimpleOrder ask2(sellSide,prc1,qty2); // AON
                    
                      SimpleOrder bid1(buySide,prc1,qty1); // AON
                      SimpleOrder bid2(buySide,prc1,qty4); // AON
                    
                                                            // Prime the order book: No Matches
                      BOOST_CHECK(add_and_verify(order_book,&bid1,expectNoMatch,expectNoComplete,AON));
                      BOOST_CHECK(add_and_verify(order_book,&bid2,expectNoMatch,expectNoComplete,AON));
                      BOOST_CHECK(add_and_verify(order_book,&ask1,expectNoMatch,expectNoComplete,AON));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(2u,order_book.bids().size());
                      BOOST_CHECK_EQUAL(1u,order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(prc1,2,qty1 + qty4));
                      BOOST_CHECK(dc.verify_ask(prc1,1,qty3));
                    
                      // Add matching order
                      {
                          SimpleFillCheck fc1(&bid1,qty1,qty3 * prc1);
                      SimpleFillCheck fc2(&bid2,qty4,qty3 * prc1);
                      SimpleFillCheck fc3(&ask1,qty3,qty1 * prc1);
                      SimpleFillCheck fc4(&ask2,qty2,qty2 * prc1);
                      BOOST_CHECK(add_and_verify(order_book,&ask2,expectMatch,expectComplete,AON));
                      }
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(0,order_book.bids().size());
                      BOOST_CHECK_EQUAL(0,order_book.asks().size());
                    #endif
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestAonAskNoMatchMulti)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask0(sellSide, prc2, qty1); // no match (price)
                      SimpleOrder ask1(sellSide, prc0, qty6); // AON
                    
                      SimpleOrder bid0(buySide, prc0, qty4); // AON no match
                      SimpleOrder bid1(buySide, prc1, qty1); // AON
                      SimpleOrder bid2(buySide, prc1, qty4);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &ask0, expectNoMatch));
                      BOOST_CHECK(add_and_verify(order_book, &bid0, expectNoMatch, expectNoComplete,AON));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, expectNoMatch, expectNoComplete,AON));//AON)); //noConditions
                      BOOST_CHECK(add_and_verify(order_book, &bid2, expectNoMatch));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(3, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(prc1, 2, qty1 + qty4));
                      BOOST_CHECK(dc.verify_bid(prc0, 1, qty4));
                      BOOST_CHECK(dc.verify_ask(prc2, 1, qty1));
                    
                      // This test was bogus -- testing a bug in the matching algorithm
                      // I fixed the bug and the test started to fail.
                      // So fixed the test to expect:
                      // Ask1 (600 AON) should match bid0 (400 AON) + bid1(100) + bid 2(100 of 400)
                      //
                      // Now we need a new test of an AON that should NOT match!
                    
                      // No match
                      { 
                    //  ASSERT_NO_THROW(
                        SimpleFillCheck fc0(&bid0, qty4, prc0 * qty4);
                        SimpleFillCheck fc1(&bid1, qty1, qty1 * prc1);
                        SimpleFillCheck fc2(&bid2, qty1, prc1 * qty1);
                        SimpleFillCheck fc3(&ask1, qty6, prc0 * qty4 + qty1 * prc1 + prc1 * qty1);
                        BOOST_CHECK(add_and_verify(order_book, &ask1, expectMatch, expectComplete, AON));
                      //); 
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(prc1, 1, qty4 - qty1));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestAonAskMatchAon)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask0(sellSide, prc2, qty1);
                      SimpleOrder ask1(sellSide, prc1, qty2); // AON
                      SimpleOrder bid1(buySide, prc1, qty2); // AON
                      SimpleOrder bid0(buySide, prc0, qty4);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &ask0, expectNoMatch));
                      BOOST_CHECK(add_and_verify(order_book, &bid0, expectNoMatch));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, expectNoMatch, expectNoComplete, AON));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(2, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_ask(prc2, 1, qty1));
                      BOOST_CHECK(dc.verify_bid(prc1, 1, qty2));
                      BOOST_CHECK(dc.verify_bid(prc0, 1, qty4));
                    
                      // Match complete
                      {
                        SimpleFillCheck fc1(&bid1, qty2, prc1 * qty2);
                        SimpleFillCheck fc3(&ask1, qty2, prc1 * qty2);
                        BOOST_CHECK(add_and_verify(order_book, &ask1, expectMatch, expectComplete, AON));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_ask(prc2, 1, qty1));
                      BOOST_CHECK(dc.verify_bid(prc0, 1, qty4));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestReplaceAonBidSmallerMatch)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask2(sellSide, prc3, qty1);
                      SimpleOrder ask1(sellSide, prc2, qty1);
                      SimpleOrder ask0(sellSide, prc1, qty1);
                      SimpleOrder bid1(buySide, prc1, qty2); // AON
                      SimpleOrder bid0(buySide, prc0, qty1);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, expectNoMatch));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, expectNoMatch, expectNoComplete, AON));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, expectNoMatch));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, expectNoMatch));
                      BOOST_CHECK(add_and_verify(order_book, &ask2, expectNoMatch));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(2, order_book.bids().size());
                      BOOST_CHECK_EQUAL(3, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(prc1, 1, qty2));
                      BOOST_CHECK(dc.verify_bid(prc0, 1, qty1));
                      BOOST_CHECK(dc.verify_ask(prc1, 1, qty1));
                      BOOST_CHECK(dc.verify_ask(prc2, 1, qty1));
                      BOOST_CHECK(dc.verify_ask(prc3, 1, qty1));
                    
                      // Match - complete
                      {
                        SimpleFillCheck fc2(&ask0, qty1, prc1 * qty1);
                        BOOST_CHECK(replace_and_verify(
                            order_book, &bid1, -(int32_t)qty1, PRICE_UNCHANGED, simple::os_complete, qty1));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(prc0, 1, qty1));
                      BOOST_CHECK(dc.verify_ask(prc2, 1, qty1));
                      BOOST_CHECK(dc.verify_ask(prc3, 1, qty1));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestReplaceAonBidPriceMatch)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask2(sellSide, prc3, qty1);
                      SimpleOrder ask1(sellSide, prc2, qty1);
                      SimpleOrder ask0(sellSide, prc1, qty1);
                      SimpleOrder bid1(buySide, prc1, qty2); // AON
                      SimpleOrder bid0(buySide, prc0, qty1);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, expectNoMatch));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, expectNoMatch, expectNoComplete, AON));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, expectNoMatch));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, expectNoMatch));
                      BOOST_CHECK(add_and_verify(order_book, &ask2, expectNoMatch));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(2, order_book.bids().size());
                      BOOST_CHECK_EQUAL(3, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(prc1, 1, qty2));
                      BOOST_CHECK(dc.verify_bid(prc0, 1, qty1));
                      BOOST_CHECK(dc.verify_ask(prc1, 1, qty1));
                      BOOST_CHECK(dc.verify_ask(prc2, 1, qty1));
                      BOOST_CHECK(dc.verify_ask(prc3, 1, qty1));
                    
                      // Match - complete
                      {
                        SimpleFillCheck fc1(&ask0, qty1, prc1 * qty1);
                        SimpleFillCheck fc2(&ask1, qty1, prc2 * qty1);
                        BOOST_CHECK(replace_and_verify(
                            order_book, &bid1, qtyNone, prc2, simple::os_complete, qty2));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(prc0, 1, qty1));
                      BOOST_CHECK(dc.verify_ask(prc3, 1, qty1));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestReplaceBidLargerMatchAon)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask2(sellSide, prc3, qty1);
                      SimpleOrder ask1(sellSide, prc2, qty1);
                      SimpleOrder ask0(sellSide, prc1, qty2); // AON
                      SimpleOrder bid1(buySide, prc1, qty1);
                      SimpleOrder bid0(buySide, prc0, qty1);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, expectNoMatch));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, expectNoMatch));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, expectNoMatch, expectNoComplete, AON));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, expectNoMatch));
                      BOOST_CHECK(add_and_verify(order_book, &ask2, expectNoMatch));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(2, order_book.bids().size());
                      BOOST_CHECK_EQUAL(3, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(prc1, 1, qty1));
                      BOOST_CHECK(dc.verify_bid(prc0, 1, qty1));
                      BOOST_CHECK(dc.verify_ask(prc1, 1, qty2));
                      BOOST_CHECK(dc.verify_ask(prc2, 1, qty1));
                      BOOST_CHECK(dc.verify_ask(prc3, 1, qty1));
                    
                      // Match - complete
                      {
                        SimpleFillCheck fc2(&ask0, qty2, qty2 * prc1);
                        BOOST_CHECK(replace_and_verify(
                            order_book, &bid1, qty1, PRICE_UNCHANGED, simple::os_complete, qty2));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(prc0, 1, qty1));
                      BOOST_CHECK(dc.verify_ask(prc2, 1, qty1));
                      BOOST_CHECK(dc.verify_ask(prc3, 1, qty1));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    }
                    
                    } // Namespace
                </[ut_all_or_none.cpp]>
                <[ut_immediate_or_cancel.cpp]>
                    // Copyright (c) 2012 - 2017 Object Computing, Inc.
                    // All rights reserved.
                    // See the file license.txt for licensing information.
                    
                    #define BOOST_TEST_NO_MAIN LiquibookTest
                    #include <boost/test/unit_test.hpp>
                    
                    #include "ut_utils.h"
                    
                    namespace liquibook {
                    
                    using simple::SimpleOrder;
                    typedef FillCheck<SimpleOrder*> SimpleFillCheck;
                    
                    OrderConditions IOC(oc_immediate_or_cancel);
                    OrderConditions FOK(oc_all_or_none | oc_immediate_or_cancel);
                    
                    BOOST_AUTO_TEST_CASE(TestIocBidNoMatch)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask2(false, 1252, 100);
                      SimpleOrder ask1(false, 1251, 100);
                      SimpleOrder ask0(false, 1250, 100);
                      SimpleOrder bid0(true,  1250, 100);
                      SimpleOrder bid1(true,  1249, 100);
                      SimpleOrder bid2(true,  1248, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask2, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid2, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(2, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1249, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1248, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    
                      // No Match - will cancel order
                      {
                        SimpleFillCheck fc0(&bid0, 0, 0, IOC);
                        SimpleFillCheck fc1(&bid1, 0, 0);
                        SimpleFillCheck fc2(&bid2, 0, 0);
                        //SimpleFillCheck fc3(&ask0, 0, 0);
                        SimpleFillCheck fc4(&ask1, 0, 0);
                        SimpleFillCheck fc5(&ask2, 0, 0);
                        BOOST_CHECK(add_and_verify(order_book, &bid0, false, false, IOC));
                      }
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(2, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1249, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1248, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestIocBidPartialMatch)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask2(false, 1252, 100);
                      SimpleOrder ask1(false, 1251, 100);
                      SimpleOrder ask0(false, 1250, 100);
                      SimpleOrder bid0(true,  1250, 300);
                      SimpleOrder bid1(true,  1249, 100);
                      SimpleOrder bid2(true,  1248, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask2, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid2, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(2, order_book.bids().size());
                      BOOST_CHECK_EQUAL(3, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1249, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1248, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1250, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    
                      // Partial Match - will cancel order
                      {
                        SimpleFillCheck fc0(&bid0, 100, 125000, IOC);
                        SimpleFillCheck fc1(&bid1, 0, 0);
                        SimpleFillCheck fc2(&bid2, 0, 0);
                        SimpleFillCheck fc3(&ask0, 100, 125000);
                        SimpleFillCheck fc4(&ask1, 0, 0);
                        SimpleFillCheck fc5(&ask2, 0, 0);
                        BOOST_CHECK(add_and_verify(order_book, &bid0, true, false, IOC));
                      }
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(2, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1249, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1248, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestIocBidFullMatch)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask2(false, 1252, 100);
                      SimpleOrder ask1(false, 1251, 100);
                      SimpleOrder ask0(false, 1250, 400);
                      SimpleOrder bid0(true,  1250, 300);
                      SimpleOrder bid1(true,  1249, 100);
                      SimpleOrder bid2(true,  1248, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask2, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid2, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(2, order_book.bids().size());
                      BOOST_CHECK_EQUAL(3, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1249, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1248, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1250, 1, 400));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    
                      // Full Match - will complete order
                      {
                        SimpleFillCheck fc0(&bid0, 300, 1250 * 300, IOC);
                        SimpleFillCheck fc1(&bid1, 0, 0);
                        SimpleFillCheck fc2(&bid2, 0, 0);
                        SimpleFillCheck fc3(&ask0, 300, 1250 * 300);
                        SimpleFillCheck fc4(&ask1, 0, 0);
                        SimpleFillCheck fc5(&ask2, 0, 0);
                        BOOST_CHECK(add_and_verify(order_book, &bid0, true, true, IOC));
                      }
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(2, order_book.bids().size());
                      BOOST_CHECK_EQUAL(3, order_book.asks().size());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1249, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1248, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1250, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestIocBidMultiMatch)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask2(false, 1252, 100);
                      SimpleOrder ask1(false, 1251, 100);
                      SimpleOrder ask0(false, 1250, 400);
                      SimpleOrder bid0(true,  1251, 500);
                      SimpleOrder bid1(true,  1249, 100);
                      SimpleOrder bid2(true,  1248, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask2, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid2, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(2, order_book.bids().size());
                      BOOST_CHECK_EQUAL(3, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1249, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1248, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1250, 1, 400));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    
                      // Full Match - will complete order
                      {
                        SimpleFillCheck fc0(&bid0, 500, 625100, IOC);
                        SimpleFillCheck fc1(&bid1, 0, 0);
                        SimpleFillCheck fc2(&bid2, 0, 0);
                        SimpleFillCheck fc3(&ask0, 400, 1250 * 400);
                        SimpleFillCheck fc4(&ask1, 100, 1251 * 100);
                        SimpleFillCheck fc5(&ask2, 0, 0);
                        BOOST_CHECK(add_and_verify(order_book, &bid0, true, true, IOC));
                      }
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(2, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1249, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1248, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestFokBidNoMatch)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask2(false, 1252, 100);
                      SimpleOrder ask1(false, 1251, 100);
                      SimpleOrder ask0(false, 1250, 100);
                      SimpleOrder bid0(true,  1250, 100);
                      SimpleOrder bid1(true,  1249, 100);
                      SimpleOrder bid2(true,  1248, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask2, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid2, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(2, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1249, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1248, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    
                      // No Match - will cancel order
                      {
                        SimpleFillCheck fc0(&bid0, 0, 0, FOK);
                        SimpleFillCheck fc1(&bid1, 0, 0);
                        SimpleFillCheck fc2(&bid2, 0, 0);
                        //SimpleFillCheck fc3(&ask0, 0, 0);
                        SimpleFillCheck fc4(&ask1, 0, 0);
                        SimpleFillCheck fc5(&ask2, 0, 0);
                        BOOST_CHECK(add_and_verify(order_book, &bid0, false, false, FOK));
                      }
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(2, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1249, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1248, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestFokBidPartialMatch)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask2(false, 1252, 100);
                      SimpleOrder ask1(false, 1251, 100);
                      SimpleOrder ask0(false, 1250, 100);
                      SimpleOrder bid0(true,  1250, 300);
                      SimpleOrder bid1(true,  1249, 100);
                      SimpleOrder bid2(true,  1248, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask2, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid2, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(2, order_book.bids().size());
                      BOOST_CHECK_EQUAL(3, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1249, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1248, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1250, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    
                      // Partial Match - will not fill and will cancel order
                      {
                        SimpleFillCheck fc0(&bid0, 0, 0, FOK);
                        SimpleFillCheck fc1(&bid1, 0, 0);
                        SimpleFillCheck fc2(&bid2, 0, 0);
                        SimpleFillCheck fc3(&ask0, 0, 0);
                        SimpleFillCheck fc4(&ask1, 0, 0);
                        SimpleFillCheck fc5(&ask2, 0, 0);
                        BOOST_CHECK(add_and_verify(order_book, &bid0, false, false, FOK));
                      }
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(2, order_book.bids().size());
                      BOOST_CHECK_EQUAL(3, order_book.asks().size());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1249, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1248, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1250, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestFokBidFullMatch)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask2(false, 1252, 100);
                      SimpleOrder ask1(false, 1251, 100);
                      SimpleOrder ask0(false, 1250, 400);
                      SimpleOrder bid0(true,  1250, 300);
                      SimpleOrder bid1(true,  1249, 100);
                      SimpleOrder bid2(true,  1248, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask2, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid2, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(2, order_book.bids().size());
                      BOOST_CHECK_EQUAL(3, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1249, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1248, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1250, 1, 400));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    
                      // Full Match - will complete order
                      {
                        SimpleFillCheck fc0(&bid0, 300, 1250 * 300, FOK);
                        SimpleFillCheck fc1(&bid1, 0, 0);
                        SimpleFillCheck fc2(&bid2, 0, 0);
                        SimpleFillCheck fc3(&ask0, 300, 1250 * 300);
                        SimpleFillCheck fc4(&ask1, 0, 0);
                        SimpleFillCheck fc5(&ask2, 0, 0);
                        BOOST_CHECK(add_and_verify(order_book, &bid0, true, true, FOK));
                      }
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(2, order_book.bids().size());
                      BOOST_CHECK_EQUAL(3, order_book.asks().size());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1249, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1248, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1250, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestFokBidMultiMatch)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask2(false, 1252, 100);
                      SimpleOrder ask1(false, 1251, 100);
                      SimpleOrder ask0(false, 1250, 400);
                      SimpleOrder bid0(true,  1251, 500);
                      SimpleOrder bid1(true,  1249, 100);
                      SimpleOrder bid2(true,  1248, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask2, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid2, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(2, order_book.bids().size());
                      BOOST_CHECK_EQUAL(3, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1249, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1248, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1250, 1, 400));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    
                      // Full Match - will complete order
                      {
                        SimpleFillCheck fc0(&bid0, 500, 625100, FOK);
                        SimpleFillCheck fc1(&bid1, 0, 0);
                        SimpleFillCheck fc2(&bid2, 0, 0);
                        SimpleFillCheck fc3(&ask0, 400, 1250 * 400);
                        SimpleFillCheck fc4(&ask1, 100, 1251 * 100);
                        SimpleFillCheck fc5(&ask2, 0, 0);
                        BOOST_CHECK(add_and_verify(order_book, &bid0, true, true, FOK));
                      }
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(2, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1249, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1248, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestIocAskNoMatch)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask2(false, 1252, 100);
                      SimpleOrder ask1(false, 1251, 100);
                      SimpleOrder ask0(false, 1250, 100);
                      SimpleOrder bid0(true,  1250, 100);
                      SimpleOrder bid1(true,  1249, 100);
                      SimpleOrder bid2(true,  1248, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask2, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid2, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(2, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1249, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1248, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    
                      // No Match - will cancel order
                      {
                        // SimpleFillCheck fc0(&bid0, 0, 0);
                        SimpleFillCheck fc1(&bid1, 0, 0);
                        SimpleFillCheck fc2(&bid2, 0, 0);
                        SimpleFillCheck fc3(&ask0, 0, 0, IOC);
                        SimpleFillCheck fc4(&ask1, 0, 0);
                        SimpleFillCheck fc5(&ask2, 0, 0);
                        BOOST_CHECK(add_and_verify(order_book, &ask0, false, false, IOC));
                      }
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(2, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1249, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1248, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestIocAskPartialMatch)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask2(false, 1252, 100);
                      SimpleOrder ask1(false, 1251, 100);
                      SimpleOrder ask0(false, 1250, 300);
                      SimpleOrder bid0(true,  1250, 100);
                      SimpleOrder bid1(true,  1249, 100);
                      SimpleOrder bid2(true,  1248, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask2, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid2, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(3, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1249, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1248, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    
                      // Partial Match - will cancel order
                      {
                        SimpleFillCheck fc0(&bid0, 100, 125000);
                        SimpleFillCheck fc1(&bid1, 0, 0);
                        SimpleFillCheck fc2(&bid2, 0, 0);
                        SimpleFillCheck fc3(&ask0, 100, 125000, IOC);
                        SimpleFillCheck fc4(&ask1, 0, 0);
                        SimpleFillCheck fc5(&ask2, 0, 0);
                        BOOST_CHECK(add_and_verify(order_book, &ask0, true, false, IOC));
                      }
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(2, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1249, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1248, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestIocAskFullMatch)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask2(false, 1252, 100);
                      SimpleOrder ask1(false, 1251, 100);
                      SimpleOrder ask0(false, 1250, 300);
                      SimpleOrder bid0(true,  1250, 300);
                      SimpleOrder bid1(true,  1249, 100);
                      SimpleOrder bid2(true,  1248, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask2, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid2, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(3, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1250, 1, 300));
                      BOOST_CHECK(dc.verify_bid(1249, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1248, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    
                      // Full match
                      {
                        SimpleFillCheck fc0(&bid0, 300, 1250 * 300);
                        SimpleFillCheck fc1(&bid1, 0, 0);
                        SimpleFillCheck fc2(&bid2, 0, 0);
                        SimpleFillCheck fc3(&ask0, 300, 1250 * 300, IOC);
                        SimpleFillCheck fc4(&ask1, 0, 0);
                        SimpleFillCheck fc5(&ask2, 0, 0);
                        BOOST_CHECK(add_and_verify(order_book, &ask0, true, true, IOC));
                      }
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(2, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1249, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1248, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestIocAskMultiMatch)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask2(false, 1252, 100);
                      SimpleOrder ask1(false, 1251, 100);
                      SimpleOrder ask0(false, 1249, 400);
                      SimpleOrder bid0(true,  1250, 300);
                      SimpleOrder bid1(true,  1249, 100);
                      SimpleOrder bid2(true,  1248, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask2, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid2, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(3, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1250, 1, 300));
                      BOOST_CHECK(dc.verify_bid(1249, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1248, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    
                      // Full match
                      {
                        SimpleFillCheck fc0(&bid0, 300, 1250 * 300);
                        SimpleFillCheck fc1(&bid1, 100, 1249 * 100);
                        SimpleFillCheck fc2(&bid2, 0, 0);
                        SimpleFillCheck fc3(&ask0, 400, 499900, IOC);
                        SimpleFillCheck fc4(&ask1, 0, 0);
                        SimpleFillCheck fc5(&ask2, 0, 0);
                        BOOST_CHECK(add_and_verify(order_book, &ask0, true, true, IOC));
                      }
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1248, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestFokAskNoMatch)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask2(false, 1252, 100);
                      SimpleOrder ask1(false, 1251, 100);
                      SimpleOrder ask0(false, 1250, 100);
                      SimpleOrder bid0(true,  1250, 100);
                      SimpleOrder bid1(true,  1249, 100);
                      SimpleOrder bid2(true,  1248, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask2, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid2, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(2, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1249, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1248, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    
                      // No Match - will cancel order
                      {
                        // SimpleFillCheck fc0(&bid0, 0, 0);
                        SimpleFillCheck fc1(&bid1, 0, 0);
                        SimpleFillCheck fc2(&bid2, 0, 0);
                        SimpleFillCheck fc3(&ask0, 0, 0, FOK);
                        SimpleFillCheck fc4(&ask1, 0, 0);
                        SimpleFillCheck fc5(&ask2, 0, 0);
                        BOOST_CHECK(add_and_verify(order_book, &ask0, false, false, FOK));
                      }
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(2, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1249, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1248, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestFokAskPartialMatch)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask2(false, 1252, 100);
                      SimpleOrder ask1(false, 1251, 100);
                      SimpleOrder ask0(false, 1250, 300);
                      SimpleOrder bid0(true,  1250, 100);
                      SimpleOrder bid1(true,  1249, 100);
                      SimpleOrder bid2(true,  1248, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask2, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid2, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(3, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1249, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1248, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    
                      // Partial Match - will not fill and will cancel order
                      {
                        SimpleFillCheck fc0(&bid0, 0, 0);
                        SimpleFillCheck fc1(&bid1, 0, 0);
                        SimpleFillCheck fc2(&bid2, 0, 0);
                        SimpleFillCheck fc3(&ask0, 0, 0, FOK);
                        SimpleFillCheck fc4(&ask1, 0, 0);
                        SimpleFillCheck fc5(&ask2, 0, 0);
                        BOOST_CHECK(add_and_verify(order_book, &ask0, false, false, FOK));
                      }
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(3, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1249, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1248, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestFokAskFullMatch)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask2(false, 1252, 100);
                      SimpleOrder ask1(false, 1251, 100);
                      SimpleOrder ask0(false, 1250, 300);
                      SimpleOrder bid0(true,  1250, 300);
                      SimpleOrder bid1(true,  1249, 100);
                      SimpleOrder bid2(true,  1248, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask2, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid2, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(3, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1250, 1, 300));
                      BOOST_CHECK(dc.verify_bid(1249, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1248, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    
                      // Full Match
                      {
                        SimpleFillCheck fc0(&bid0, 300, 1250 * 300);
                        SimpleFillCheck fc1(&bid1, 0, 0);
                        SimpleFillCheck fc2(&bid2, 0, 0);
                        SimpleFillCheck fc3(&ask0, 300, 1250 * 300, FOK);
                        SimpleFillCheck fc4(&ask1, 0, 0);
                        SimpleFillCheck fc5(&ask2, 0, 0);
                        BOOST_CHECK(add_and_verify(order_book, &ask0, true, true, FOK));
                      }
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(2, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1249, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1248, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestFokAskMultiMatch)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask2(false, 1252, 100);
                      SimpleOrder ask1(false, 1251, 100);
                      SimpleOrder ask0(false, 1249, 400);
                      SimpleOrder bid0(true,  1250, 300);
                      SimpleOrder bid1(true,  1249, 100);
                      SimpleOrder bid2(true,  1248, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask2, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid2, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(3, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1250, 1, 300));
                      BOOST_CHECK(dc.verify_bid(1249, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1248, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    
                      // Full match
                      {
                        SimpleFillCheck fc0(&bid0, 300, 1250 * 300);
                        SimpleFillCheck fc1(&bid1, 100, 1249 * 100);
                        SimpleFillCheck fc2(&bid2, 0, 0);
                        SimpleFillCheck fc3(&ask0, 400, 499900, FOK);
                        SimpleFillCheck fc4(&ask1, 0, 0);
                        SimpleFillCheck fc5(&ask2, 0, 0);
                        BOOST_CHECK(add_and_verify(order_book, &ask0, true, true, FOK));
                      }
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1248, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    }
                    
                    } // Namespace
                </[ut_immediate_or_cancel.cpp]>
                <[ut_bbo_order_book.cpp]>
                    // Copyright (c) 2012 - 2017 Object Computing, Inc.
                    // All rights reserved.
                    // See the file license.txt for licensing information.
                    
                    #define BOOST_TEST_NO_MAIN LiquibookTest
                    #include <boost/test/unit_test.hpp>
                    
                    #include <book/depth_constants.h>
                    #include <book/order_book.h>
                    #include <simple/simple_order.h>
                    #include <simple/simple_order_book.h>
                    #include "changed_checker.h"
                    #include "depth_check.h"
                    #include "ut_utils.h"
                    
                    using namespace liquibook::book;
                    
                    namespace liquibook {
                    
                    using book::DepthLevel;
                    using book::OrderBook;
                    using book::OrderTracker;
                    using simple::SimpleOrder;
                    
                    typedef OrderTracker<SimpleOrder*> SimpleTracker;
                    typedef test::ChangedChecker<5> ChangedChecker;
                    typedef SimpleOrderBook::DepthTracker SimpleDepth;
                    
                    typedef FillCheck<SimpleOrder*> SimpleFillCheck;
                    
                    BOOST_AUTO_TEST_CASE(TestBboBidsMultimapSortCorrect)
                    {
                      SimpleOrderBook::Bids bids;
                      SimpleOrder order0(true, 1250, 100);
                      SimpleOrder order1(true, 1255, 100);
                      SimpleOrder order2(true, 1240, 100);
                      SimpleOrder order3(true,    0, 100);
                      SimpleOrder order4(true, 1245, 100);
                    
                      // Insert out of price order
                      bids.insert(std::make_pair(ComparablePrice(true, order0.price()), SimpleTracker(&order0)));
                      bids.insert(std::make_pair(ComparablePrice(true, order1.price()), SimpleTracker(&order1)));
                      bids.insert(std::make_pair(ComparablePrice(true, order2.price()), SimpleTracker(&order2)));
                      bids.insert(std::make_pair(ComparablePrice(true, 0), 
                                                 SimpleTracker(&order3)));
                      bids.insert(std::make_pair(ComparablePrice(true, order4.price()), SimpleTracker(&order4)));
                      
                      // Should access in price order
                      SimpleOrder* expected_order[] = {
                        &order3, &order1, &order0, &order4, &order2
                      };
                    
                      SimpleOrderBook::Bids::iterator bid;
                      int index = 0;
                    
                      for (bid = bids.begin(); bid != bids.end(); ++bid, ++index) {
                        if (expected_order[index]->price() == MARKET_ORDER_PRICE) {
                          BOOST_CHECK_EQUAL(MARKET_ORDER_PRICE, bid->first);
                        } else {
                          BOOST_CHECK_EQUAL(expected_order[index]->price(), bid->first);
                        }
                        BOOST_CHECK_EQUAL(expected_order[index], bid->second.ptr());
                      }
                    
                      // Should be able to search and find
                      BOOST_CHECK((bids.upper_bound(book::ComparablePrice(true, 1245)))->second.ptr()->price() == 1240);
                      BOOST_CHECK((bids.lower_bound(book::ComparablePrice(true, 1245)))->second.ptr()->price() == 1245);
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestBboAsksMultimapSortCorrect)
                    {
                      SimpleOrderBook::Asks asks;
                      SimpleOrder order0(false, 3250, 100);
                      SimpleOrder order1(false, 3235, 800);
                      SimpleOrder order2(false, 3230, 200);
                      SimpleOrder order3(false,    0, 200);
                      SimpleOrder order4(false, 3245, 100);
                      SimpleOrder order5(false, 3265, 200);
                    
                      // Insert out of price order
                      asks.insert(std::make_pair(book::ComparablePrice(false, order0.price()), SimpleTracker(&order0)));
                      asks.insert(std::make_pair(book::ComparablePrice(false, order1.price()), SimpleTracker(&order1)));
                      asks.insert(std::make_pair(book::ComparablePrice(false, order2.price()), SimpleTracker(&order2)));
                      asks.insert(std::make_pair(book::ComparablePrice(false, MARKET_ORDER_PRICE), 
                                                 SimpleTracker(&order3)));
                      asks.insert(std::make_pair(book::ComparablePrice(false, order4.price()), SimpleTracker(&order4)));
                      asks.insert(std::make_pair(book::ComparablePrice(false, order5.price()), SimpleTracker(&order5)));
                      
                      // Should access in price order
                      SimpleOrder* expected_order[] = {
                        &order3, &order2, &order1, &order4, &order0, &order5
                      };
                    
                      SimpleOrderBook::Asks::iterator ask;
                      int index = 0;
                    
                      for (ask = asks.begin(); ask != asks.end(); ++ask, ++index) {
                        if (expected_order[index]->price() == MARKET_ORDER_PRICE) {
                          BOOST_CHECK_EQUAL(MARKET_ORDER_ASK_SORT_PRICE, ask->first);
                        } else {
                          BOOST_CHECK_EQUAL(expected_order[index]->price(), ask->first);
                        }
                        BOOST_CHECK_EQUAL(expected_order[index], ask->second.ptr());
                      }
                    
                      BOOST_CHECK((asks.upper_bound(book::ComparablePrice(false, 3235)))->second.ptr()->price() == 3245);
                      BOOST_CHECK((asks.lower_bound(book::ComparablePrice(false, 3235)))->second.ptr()->price() == 3235);
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestBboAddCompleteBid)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask1(false, 1252, 100);
                      SimpleOrder ask0(false, 1251, 100);
                      SimpleOrder bid1(true,  1251, 100);
                      SimpleOrder bid0(true,  1250, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 100));
                    
                      // Match - complete
                      {
                        SimpleFillCheck fc1(&bid1, 100, 125100);
                        SimpleFillCheck fc2(&ask0, 100, 125100);
                        BOOST_CHECK(add_and_verify(order_book, &bid1, true, true));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestBboAddCompleteAsk)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask0(false, 1251, 100);
                      SimpleOrder ask1(false, 1250, 100);
                      SimpleOrder bid0(true,  1250, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 100));
                    
                      // Match - complete
                      {
                        SimpleFillCheck fc1(&ask1, 100, 125000);
                        SimpleFillCheck fc2(&bid0, 100, 125000);
                        BOOST_CHECK(add_and_verify(order_book, &ask1, true, true));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(   0, 0,   0));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 100));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(0, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestBboAddMultiMatchBid)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask1(false, 1252, 100);
                      SimpleOrder ask0(false, 1251, 300);
                      SimpleOrder ask2(false, 1251, 200);
                      SimpleOrder bid1(true,  1251, 500);
                      SimpleOrder bid0(true,  1250, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask2, false));
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1251, 2, 500));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(3, order_book.asks().size());
                    
                      // Match - complete
                      {
                        SimpleFillCheck fc1(&bid1, 500, 1251 * 500);
                        SimpleFillCheck fc2(&ask2, 200, 1251 * 200);
                        SimpleFillCheck fc3(&ask0, 300, 1251 * 300);
                        BOOST_CHECK(add_and_verify(order_book, &bid1, true, true));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    
                      // Verify remaining
                      BOOST_CHECK_EQUAL(&ask1, order_book.asks().begin()->second.ptr());
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestBboAddMultiMatchAsk)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask1(false, 9252, 100);
                      SimpleOrder ask0(false, 9251, 300);
                      SimpleOrder ask2(false, 9251, 200);
                      SimpleOrder ask3(false, 9250, 600);
                      SimpleOrder bid0(true,  9250, 100);
                      SimpleOrder bid1(true,  9250, 500);
                      SimpleOrder bid2(true,  9248, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid2, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask2, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(3, order_book.bids().size());
                      BOOST_CHECK_EQUAL(3, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(9250, 2, 600));
                      BOOST_CHECK(dc.verify_ask(9251, 2, 500));
                    
                      // Match - complete
                      {
                        SimpleFillCheck fc1(&ask3, 600, 9250 * 600);
                        SimpleFillCheck fc2(&bid0, 100, 9250 * 100);
                        SimpleFillCheck fc3(&bid1, 500, 9250 * 500);
                        BOOST_CHECK(add_and_verify(order_book, &ask3, true, true));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(9248, 1, 100));
                      BOOST_CHECK(dc.verify_ask(9251, 2, 500));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(3, order_book.asks().size());
                    
                      // Verify remaining
                      BOOST_CHECK_EQUAL(&bid2, order_book.bids().begin()->second.ptr());
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestBboAddPartialMatchBid)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask0(false, 7253, 300);
                      SimpleOrder ask1(false, 7252, 100);
                      SimpleOrder ask2(false, 7251, 200);
                      SimpleOrder bid1(true,  7251, 350);
                      SimpleOrder bid0(true,  7250, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask2, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(3, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(7250, 1, 100));
                      BOOST_CHECK(dc.verify_ask(7251, 1, 200));
                    
                      // Match - partial
                      {
                        SimpleFillCheck fc1(&bid1, 200, 7251 * 200);
                        SimpleFillCheck fc2(&ask2, 200, 7251 * 200);
                        BOOST_CHECK(add_and_verify(order_book, &bid1, true, false));
                      }
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(2, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(7251, 1, 150));
                      BOOST_CHECK(dc.verify_ask(7252, 1, 100));
                    
                      // Verify remaining
                      BOOST_CHECK_EQUAL(&ask1, order_book.asks().begin()->second.ptr());
                      BOOST_CHECK_EQUAL(&bid1, order_book.bids().begin()->second.ptr());
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestBboAddPartialMatchAsk)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask0(false, 1253, 300);
                      SimpleOrder ask1(false, 1251, 400);
                      SimpleOrder bid1(true,  1251, 350);
                      SimpleOrder bid0(true,  1250, 100);
                      SimpleOrder bid2(true,  1250, 200);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid2, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(3, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1251, 1, 350));
                      BOOST_CHECK(dc.verify_ask(1253, 1, 300));
                    
                      // Match - partial
                      {
                        SimpleFillCheck fc1(&ask1, 350, 1251 * 350);
                        SimpleFillCheck fc2(&bid1, 350, 1251 * 350);
                        BOOST_CHECK(add_and_verify(order_book, &ask1,  true, false));
                      }
                    
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(2, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1250, 2, 300));
                      BOOST_CHECK(dc.verify_ask(1251, 1,  50));
                    
                      // Verify remaining
                      BOOST_CHECK_EQUAL(&bid0, order_book.bids().begin()->second.ptr());
                      BOOST_CHECK_EQUAL(&ask1, order_book.asks().begin()->second.ptr());
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestBboAddMultiPartialMatchBid)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask1(false, 1252, 100);
                      SimpleOrder ask2(false, 1251, 200);
                      SimpleOrder ask0(false, 1251, 300);
                      SimpleOrder bid1(true,  1251, 750);
                      SimpleOrder bid0(true,  1250, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask2, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(3, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1251, 2, 500));
                    
                      // Match - partial
                      {
                        SimpleFillCheck fc1(&bid1, 500, 1251 * 500);
                        SimpleFillCheck fc2(&ask0, 300, 1251 * 300);
                        SimpleFillCheck fc3(&ask2, 200, 1251 * 200);
                        BOOST_CHECK(add_and_verify(order_book, &bid1, true, false));
                      }
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(2, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1251, 1, 250));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    
                      // Verify remaining
                      BOOST_CHECK_EQUAL(&ask1, order_book.asks().begin()->second.ptr());
                      BOOST_CHECK_EQUAL(&bid1, order_book.bids().begin()->second.ptr());
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestBboAddMultiPartialMatchAsk)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask0(false, 1253, 300);
                      SimpleOrder ask1(false, 1251, 700);
                      SimpleOrder bid1(true,  1251, 370);
                      SimpleOrder bid2(true,  1251, 200);
                      SimpleOrder bid0(true,  1250, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid2, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(3, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1251, 2, 570));
                      BOOST_CHECK(dc.verify_ask(1253, 1, 300));
                    
                      // Match - partial
                      {
                        SimpleFillCheck fc1(&ask1, 570, 1251 * 570);
                        SimpleFillCheck fc2(&bid1, 370, 1251 * 370);
                        SimpleFillCheck fc3(&bid2, 200, 1251 * 200);
                        BOOST_CHECK(add_and_verify(order_book, &ask1,  true, false));
                      }
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 130));
                    
                      // Verify remaining
                      BOOST_CHECK_EQUAL(&bid0, order_book.bids().begin()->second.ptr());
                      BOOST_CHECK_EQUAL(100, order_book.bids().begin()->second.open_qty());
                      BOOST_CHECK_EQUAL(&ask1, order_book.asks().begin()->second.ptr());
                      BOOST_CHECK_EQUAL(130, order_book.asks().begin()->second.open_qty());
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestBboRepeatMatchBid)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask3(false, 1251, 400);
                      SimpleOrder ask2(false, 1251, 200);
                      SimpleOrder ask1(false, 1251, 300);
                      SimpleOrder ask0(false, 1251, 100);
                      SimpleOrder bid1(true,  1251, 900);
                      SimpleOrder bid0(true,  1250, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, false));
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1251, 1, 900));
                    
                      // Match - repeated
                      {
                        SimpleFillCheck fc1(&bid1, 100, 125100);
                        SimpleFillCheck fc2(&ask0, 100, 125100);
                        BOOST_CHECK(add_and_verify(order_book, &ask0, true, true));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1251, 1, 800));
                    
                      {
                        SimpleFillCheck fc1(&bid1, 300, 1251 * 300);
                        SimpleFillCheck fc2(&ask1, 300, 1251 * 300);
                        BOOST_CHECK(add_and_verify(order_book, &ask1, true, true));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1251, 1, 500));
                    
                      {
                        SimpleFillCheck fc1(&bid1, 200, 1251 * 200);
                        SimpleFillCheck fc2(&ask2, 200, 1251 * 200);
                        BOOST_CHECK(add_and_verify(order_book, &ask2, true, true));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1251, 1, 300));
                    
                      {
                        SimpleFillCheck fc1(&bid1, 300, 1251 * 300);
                        SimpleFillCheck fc2(&ask3, 300, 1251 * 300);
                        BOOST_CHECK(add_and_verify(order_book, &ask3, true));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 100));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestBboRepeatMatchAsk)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask0(false,  1252, 100);
                      SimpleOrder ask1(false,  1251, 900);
                      SimpleOrder bid0(true, 1251, 100);
                      SimpleOrder bid1(true, 1251, 300);
                      SimpleOrder bid2(true, 1251, 200);
                      SimpleOrder bid3(true, 1251, 400);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_ask(1251, 1, 900));
                    
                      BOOST_CHECK_EQUAL(&ask1, order_book.asks().begin()->second.ptr());
                    
                      // Match - repeated
                      {
                        SimpleFillCheck fc1(&ask1, 100, 125100);
                        SimpleFillCheck fc2(&bid0, 100, 125100);
                        BOOST_CHECK(add_and_verify(order_book, &bid0, true, true));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_ask(1251, 1, 800));
                    
                      {
                        SimpleFillCheck fc1(&ask1, 300, 1251 * 300);
                        SimpleFillCheck fc2(&bid1, 300, 1251 * 300);
                        BOOST_CHECK(add_and_verify(order_book, &bid1, true, true));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_ask(1251, 1, 500));
                    
                      {
                        SimpleFillCheck fc1(&ask1, 200, 1251 * 200);
                        SimpleFillCheck fc2(&bid2, 200, 1251 * 200);
                        BOOST_CHECK(add_and_verify(order_book, &bid2, true, true));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_ask(1251, 1, 300));
                    
                      {
                        SimpleFillCheck fc1(&ask1, 300, 1251 * 300);
                        SimpleFillCheck fc2(&bid3, 300, 1251 * 300);
                        BOOST_CHECK(add_and_verify(order_book, &bid3, true));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1251, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestBboAddMarketOrderBid)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask1(false, 1252, 100);
                      SimpleOrder ask0(false, 1251, 100);
                      SimpleOrder bid1(true,     0, 100);
                      SimpleOrder bid0(true,  1250, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 100));
                    
                      // Match - complete
                      {
                        SimpleFillCheck fc1(&bid1, 100, 125100);
                        SimpleFillCheck fc2(&ask0, 100, 125100);
                        BOOST_CHECK(add_and_verify(order_book, &bid1, true, true));
                      }
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestBboAddMarketOrderAsk)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask0(false, 1252, 100);
                      SimpleOrder ask1(false,    0, 100);
                      SimpleOrder bid1(true,  1251, 100);
                      SimpleOrder bid0(true,  1250, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(2, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1251, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    
                      // Match - complete
                      {
                        SimpleFillCheck fc1(&bid1, 100, 125100);
                        SimpleFillCheck fc2(&ask1, 100, 125100);
                        BOOST_CHECK(add_and_verify(order_book, &ask1, true, true));
                      }
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestBboAddMarketOrderBidMultipleMatch)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask1(false, 12520, 300);
                      SimpleOrder ask0(false, 12510, 200);
                      SimpleOrder bid1(true,      0, 500);
                      SimpleOrder bid0(true,  12500, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(12500, 1, 100));
                      BOOST_CHECK(dc.verify_ask(12510, 1, 200));
                    
                      // Match - complete
                      {
                        SimpleFillCheck fc1(&bid1, 500, 12510 * 200 + 12520 * 300);
                        SimpleFillCheck fc2(&ask0, 200, 12510 * 200);
                        SimpleFillCheck fc3(&ask1, 300, 12520 * 300);
                        BOOST_CHECK(add_and_verify(order_book, &bid1, true, true));
                      }
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(0, order_book.asks().size());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(12500, 1, 100));
                      BOOST_CHECK(dc.verify_ask(    0, 0,   0));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestBboAddMarketOrderAskMultipleMatch)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask0(false, 12520, 100);
                      SimpleOrder ask1(false,     0, 600);
                      SimpleOrder bid1(true,  12510, 200);
                      SimpleOrder bid0(true,  12500, 400);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(2, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(12510, 1, 200));
                      BOOST_CHECK(dc.verify_ask(12520, 1, 100));
                    
                      // Match - complete
                      {
                        SimpleFillCheck fc1(&bid0, 400, 12500 * 400);
                        SimpleFillCheck fc2(&bid1, 200, 12510 * 200);
                        SimpleFillCheck fc3(&ask1, 600, 12500 * 400 + 12510 * 200);
                        BOOST_CHECK(add_and_verify(order_book, &ask1, true, true));
                      }
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(0, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(    0, 0,   0));
                      BOOST_CHECK(dc.verify_ask(12520, 1, 100));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestBboMatchMarketOrderBid)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask0(false, 1253, 100);
                      SimpleOrder bid1(true,     0, 100);
                      SimpleOrder bid0(true,  1250, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(2, order_book.bids().size());
                      BOOST_CHECK_EQUAL(0, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_ask(   0, 0,   0));
                    
                      // Match - complete
                      {
                        SimpleFillCheck fc1(&bid1, 100, 125300);
                        SimpleFillCheck fc2(&ask0, 100, 125300);
                        BOOST_CHECK(add_and_verify(order_book, &ask0, true, true));
                      }
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(0, order_book.asks().size());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_ask(   0, 0,   0));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestBboMatchMarketOrderAsk)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask0(false, 1252, 100);
                      SimpleOrder ask1(false,    0, 100);
                      SimpleOrder bid0(true,  1250, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(0, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                      BOOST_CHECK(dc.verify_bid(   0, 0,   0));
                    
                      // Match - complete
                      {
                        SimpleFillCheck fc1(&bid0, 100, 125000);
                        SimpleFillCheck fc2(&ask1, 100, 125000);
                        BOOST_CHECK(add_and_verify(order_book, &bid0, true, true));
                      }
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(0, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestBboMatchMultipleMarketOrderBid)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask0(false, 1253, 400);
                      SimpleOrder bid1(true,     0, 100);
                      SimpleOrder bid2(true,     0, 200);
                      SimpleOrder bid0(true,  1250, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid2, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(3, order_book.bids().size());
                      BOOST_CHECK_EQUAL(0, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_ask(   0, 0,   0));
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                    
                      // Match - complete
                      {
                        SimpleFillCheck fc1(&bid1, 100, 1253 * 100);
                        SimpleFillCheck fc2(&bid2, 200, 1253 * 200);
                        SimpleFillCheck fc3(&ask0, 300, 1253 * 300);
                        BOOST_CHECK(add_and_verify(order_book, &ask0, true, false));
                      }
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_ask(1253, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                    }
                    
                    
                    BOOST_AUTO_TEST_CASE(TestBboMatchMultipleMarketOrderAsk)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask0(false, 1252, 100);
                      SimpleOrder ask2(false,    0, 400);
                      SimpleOrder ask1(false,    0, 100);
                      SimpleOrder bid0(true,  1250, 300);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask2, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(0, order_book.bids().size());
                      BOOST_CHECK_EQUAL(3, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                      BOOST_CHECK(dc.verify_bid(   0, 0,   0));
                    
                      // Match - partiaL
                      {
                        SimpleFillCheck fc1(&bid0, 300, 1250 * 300);
                        SimpleFillCheck fc2(&ask1, 100, 1250 * 100);
                        SimpleFillCheck fc3(&ask2, 200, 1250 * 200);
                        BOOST_CHECK(add_and_verify(order_book, &bid0, true, true));
                      }
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(0, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                      BOOST_CHECK(dc.verify_bid(   0, 0,   0));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestBboCancelBid)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask1(false, 1252, 100);
                      SimpleOrder ask0(false, 1251, 100);
                      SimpleOrder bid0(true,  1250, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 100));
                    
                      // Cancel bid
                      BOOST_CHECK(cancel_and_verify(order_book, &bid0, simple::os_cancelled));
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(0,    0,   0));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 100));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(0, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestBboCancelAskAndMatch)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask1(false, 1252, 100);
                      SimpleOrder ask0(false, 1251, 100);
                      SimpleOrder bid2(true,  1252, 100);
                      SimpleOrder bid0(true,  1250, 100);
                      SimpleOrder bid1(true,  1250, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(2, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1250, 2, 200));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 100));
                    
                      // Cancel bid
                      BOOST_CHECK(cancel_and_verify(order_book, &ask0, simple::os_cancelled));
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1250, 2, 200));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    
                      // Match - partiaL
                      {
                        SimpleFillCheck fc1(&bid2, 100, 1252 * 100);
                        SimpleFillCheck fc2(&ask1, 100, 1252 * 100);
                        BOOST_CHECK(add_and_verify(order_book, &bid2, true, true));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1250, 2, 200));
                      BOOST_CHECK(dc.verify_ask(   0, 0,   0));
                    
                      // Cancel bid
                      BOOST_CHECK(cancel_and_verify(order_book, &bid0, simple::os_cancelled));
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_ask(   0, 0,   0));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(0, order_book.asks().size());
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestBboCancelBidFail)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask0(false, 1251, 100);
                      SimpleOrder ask1(false, 1250, 100);
                      SimpleOrder bid0(true,  1250, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_ask(1251, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                    
                      // Match - complete
                      {
                        SimpleFillCheck fc1(&ask1, 100, 125000);
                        SimpleFillCheck fc2(&bid0, 100, 125000);
                        BOOST_CHECK(add_and_verify(order_book, &ask1, true, true));
                      }
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(0, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_ask(1251, 1, 100));
                      BOOST_CHECK(dc.verify_bid(   0, 0,   0));
                    
                      // Cancel a filled order
                      BOOST_CHECK(cancel_and_verify(order_book, &bid0, simple::os_complete));
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_ask(1251, 1, 100));
                      BOOST_CHECK(dc.verify_bid(   0, 0,   0));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestBboCancelAskFail)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask1(false, 1252, 100);
                      SimpleOrder ask0(false, 1251, 100);
                      SimpleOrder bid1(true,  1251, 100);
                      SimpleOrder bid0(true,  1250, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_ask(1251, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                    
                      // Match - complete
                      {
                        SimpleFillCheck fc1(&bid1, 100, 125100);
                        SimpleFillCheck fc2(&ask0, 100, 125100);
                        BOOST_CHECK(add_and_verify(order_book, &bid1, true, true));
                      }
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                    
                      // Cancel a filled order
                      BOOST_CHECK(cancel_and_verify(order_book, &ask0, simple::os_complete));
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestBboCancelBidRestore)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask10(false, 1258, 600);
                      SimpleOrder ask9(false,  1257, 700);
                      SimpleOrder ask8(false,  1256, 100);
                      SimpleOrder ask7(false,  1256, 100);
                      SimpleOrder ask6(false,  1255, 500);
                      SimpleOrder ask5(false,  1255, 200);
                      SimpleOrder ask4(false,  1254, 300);
                      SimpleOrder ask3(false,  1252, 200);
                      SimpleOrder ask2(false,  1252, 100);
                      SimpleOrder ask1(false,  1251, 400);
                      SimpleOrder ask0(false,  1250, 500);
                    
                      SimpleOrder bid0(true,   1249, 100);
                      SimpleOrder bid1(true,   1249, 200);
                      SimpleOrder bid2(true,   1249, 200);
                      SimpleOrder bid3(true,   1248, 400);
                      SimpleOrder bid4(true,   1246, 600);
                      SimpleOrder bid5(true,   1246, 500);
                      SimpleOrder bid6(true,   1245, 200);
                      SimpleOrder bid7(true,   1245, 100);
                      SimpleOrder bid8(true,   1245, 200);
                      SimpleOrder bid9(true,   1244, 700);
                      SimpleOrder bid10(true,  1244, 300);
                      SimpleOrder bid11(true,  1242, 300);
                      SimpleOrder bid12(true,  1241, 400);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &ask0,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask2,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask3,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask4,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask5,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask6,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask7,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask8,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask9,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask10, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid0,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid2,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid3,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid4,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid5,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid6,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid7,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid8,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid9,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid10, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid11, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid12, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(13, order_book.bids().size());
                      BOOST_CHECK_EQUAL(11, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1249, 3,  500));
                      BOOST_CHECK(dc.verify_ask(1250, 1,  500));
                    
                      // Cancel a bid level (erase)
                      BOOST_CHECK(cancel_and_verify(order_book, &bid3, simple::os_cancelled));
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1249, 3,  500));
                      BOOST_CHECK(dc.verify_ask(1250, 1,  500));
                      
                      // Cancel common bid levels (not erased)
                      BOOST_CHECK(cancel_and_verify(order_book, &bid7, simple::os_cancelled));
                      BOOST_CHECK(cancel_and_verify(order_book, &bid4, simple::os_cancelled));
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1249, 3,  500));
                      BOOST_CHECK(dc.verify_ask(1250, 1,  500));
                    
                      // Cancel the best bid level (erased)
                      BOOST_CHECK(cancel_and_verify(order_book, &bid1, simple::os_cancelled));
                      BOOST_CHECK(cancel_and_verify(order_book, &bid0, simple::os_cancelled));
                      BOOST_CHECK(cancel_and_verify(order_book, &bid2, simple::os_cancelled));
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1246, 1,  500));
                      BOOST_CHECK(dc.verify_ask(1250, 1,  500));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestBboCancelAskRestore)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask10(false, 1258, 600);
                      SimpleOrder ask9(false,  1257, 700);
                      SimpleOrder ask8(false,  1256, 100);
                      SimpleOrder ask7(false,  1256, 100);
                      SimpleOrder ask6(false,  1255, 500);
                      SimpleOrder ask5(false,  1255, 200);
                      SimpleOrder ask4(false,  1254, 300);
                      SimpleOrder ask3(false,  1252, 200);
                      SimpleOrder ask2(false,  1252, 100);
                      SimpleOrder ask1(false,  1251, 400);
                      SimpleOrder ask0(false,  1250, 500);
                    
                      SimpleOrder bid0(true,   1249, 100);
                      SimpleOrder bid1(true,   1249, 200);
                      SimpleOrder bid2(true,   1249, 200);
                      SimpleOrder bid3(true,   1248, 400);
                      SimpleOrder bid4(true,   1246, 600);
                      SimpleOrder bid5(true,   1246, 500);
                      SimpleOrder bid6(true,   1245, 200);
                      SimpleOrder bid7(true,   1245, 100);
                      SimpleOrder bid8(true,   1245, 200);
                      SimpleOrder bid9(true,   1244, 700);
                      SimpleOrder bid10(true,  1244, 300);
                      SimpleOrder bid11(true,  1242, 300);
                      SimpleOrder bid12(true,  1241, 400);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &ask0,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask2,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask3,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask4,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask5,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask6,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask7,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask8,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask9,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask10, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid0,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid2,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid3,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid4,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid5,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid6,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid7,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid8,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid9,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid10, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid11, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid12, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(13, order_book.bids().size());
                      BOOST_CHECK_EQUAL(11, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1249, 3,  500));
                      BOOST_CHECK(dc.verify_ask(1250, 1,  500));
                    
                      // Cancel an ask level (erase)
                      BOOST_CHECK(cancel_and_verify(order_book, &ask1, simple::os_cancelled));
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1249, 3,  500));
                      BOOST_CHECK(dc.verify_ask(1250, 1,  500));
                    
                      // Cancel common ask levels (not erased)
                      BOOST_CHECK(cancel_and_verify(order_book, &ask2, simple::os_cancelled));
                      BOOST_CHECK(cancel_and_verify(order_book, &ask6, simple::os_cancelled));
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1249, 3,  500));
                      BOOST_CHECK(dc.verify_ask(1250, 1,  500));
                    
                      // Cancel the best ask level (erased)
                      BOOST_CHECK(cancel_and_verify(order_book, &ask0, simple::os_cancelled));
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1249, 3,  500));
                      BOOST_CHECK(dc.verify_ask(1252, 1,  200));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestBboFillCompleteBidRestoreDepth)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask10(false, 1258, 600);
                      SimpleOrder ask9(false,  1257, 700);
                      SimpleOrder ask8(false,  1256, 100);
                      SimpleOrder ask7(false,  1256, 100);
                      SimpleOrder ask6(false,  1255, 500);
                      SimpleOrder ask5(false,  1255, 200);
                      SimpleOrder ask4(false,  1254, 300);
                      SimpleOrder ask3(false,  1252, 200);
                      SimpleOrder ask2(false,  1252, 100);
                      SimpleOrder ask1(false,  1251, 400);
                      SimpleOrder ask0(false,  1250, 500);
                    
                      SimpleOrder bid0(true,   1249, 100);
                      SimpleOrder bid1(true,   1249, 200);
                      SimpleOrder bid2(true,   1249, 200);
                      SimpleOrder bid3(true,   1248, 400);
                      SimpleOrder bid4(true,   1246, 600);
                      SimpleOrder bid5(true,   1246, 500);
                      SimpleOrder bid6(true,   1245, 200);
                      SimpleOrder bid7(true,   1245, 100);
                      SimpleOrder bid8(true,   1245, 200);
                      SimpleOrder bid9(true,   1244, 700);
                      SimpleOrder bid10(true,  1244, 300);
                      SimpleOrder bid11(true,  1242, 300);
                      SimpleOrder bid12(true,  1241, 400);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &ask0,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask2,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask3,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask4,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask5,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask6,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask7,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask8,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask9,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask10, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid0,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid2,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid3,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid4,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid5,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid6,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid7,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid8,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid9,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid10, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid11, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid12, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(13, order_book.bids().size());
                      BOOST_CHECK_EQUAL(11, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1249, 3,  500));
                      BOOST_CHECK(dc.verify_ask(1250, 1,  500));
                    
                      // Fill the top bid level (erase) and add an ask level (insert)
                      SimpleOrder cross_ask(false,  1249, 800);
                      {
                        SimpleFillCheck fc1(&bid0,      100, 1249 * 100);
                        SimpleFillCheck fc2(&bid1,      200, 1249 * 200);
                        SimpleFillCheck fc3(&bid2,      200, 1249 * 200);
                        SimpleFillCheck fc4(&cross_ask, 500, 1249 * 500);
                        BOOST_CHECK(add_and_verify(order_book, &cross_ask, true, false));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1248, 1,  400));
                      BOOST_CHECK(dc.verify_ask(1249, 1,  300)); // Inserted
                      
                      // Fill the top bid level (erase) but do not add an ask level (no insert)
                      SimpleOrder cross_ask2(false,  1248, 400);
                      {
                        SimpleFillCheck fc1(&bid3,       400, 1248 * 400);
                        SimpleFillCheck fc4(&cross_ask2, 400, 1248 * 400);
                        BOOST_CHECK(add_and_verify(order_book, &cross_ask2, true, true));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1246, 2, 1100));
                      BOOST_CHECK(dc.verify_ask(1249, 1,  300));
                    
                      // Fill the top bid level (erase) and add ask level (insert),
                      //    but nothing to restore
                      SimpleOrder cross_ask3(false,  1246, 2400);
                      {
                        SimpleFillCheck fc1(&bid4,        600, 1246 * 600);
                        SimpleFillCheck fc2(&bid5,        500, 1246 * 500);
                        SimpleFillCheck fc3(&cross_ask3, 1100, 1246 * 1100);
                        BOOST_CHECK(add_and_verify(order_book, &cross_ask3, true, false));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1245, 3,  500));
                      BOOST_CHECK(dc.verify_ask(1246, 1, 1300));
                    
                      // Partial fill the top bid level (reduce) 
                      SimpleOrder cross_ask4(false,  1245, 250);
                      {
                        SimpleFillCheck fc1(&bid6,        200, 1245 * 200);
                        SimpleFillCheck fc2(&bid7,         50, 1245 *  50);
                        SimpleFillCheck fc3(&cross_ask4,  250, 1245 * 250);
                        BOOST_CHECK(add_and_verify(order_book, &cross_ask4, true, true));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1245, 2,  250)); // 1 filled, 1 reduced
                      BOOST_CHECK(dc.verify_ask(1246, 1, 1300));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestBboFillCompleteAskRestoreDepth)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask10(false, 1258, 600);
                      SimpleOrder ask9(false,  1257, 700);
                      SimpleOrder ask8(false,  1256, 100);
                      SimpleOrder ask7(false,  1256, 100);
                      SimpleOrder ask6(false,  1255, 500);
                      SimpleOrder ask5(false,  1255, 200);
                      SimpleOrder ask4(false,  1254, 300);
                      SimpleOrder ask3(false,  1252, 200);
                      SimpleOrder ask2(false,  1252, 100);
                      SimpleOrder ask1(false,  1251, 400);
                      SimpleOrder ask0(false,  1250, 500);
                    
                      SimpleOrder bid0(true,   1249, 100);
                      SimpleOrder bid1(true,   1249, 200);
                      SimpleOrder bid2(true,   1249, 200);
                      SimpleOrder bid3(true,   1248, 400);
                      SimpleOrder bid4(true,   1246, 600);
                      SimpleOrder bid5(true,   1246, 500);
                      SimpleOrder bid6(true,   1245, 200);
                      SimpleOrder bid7(true,   1245, 100);
                      SimpleOrder bid8(true,   1245, 200);
                      SimpleOrder bid9(true,   1244, 700);
                      SimpleOrder bid10(true,  1244, 300);
                      SimpleOrder bid11(true,  1242, 300);
                      SimpleOrder bid12(true,  1241, 400);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &ask0,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask2,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask3,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask4,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask5,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask6,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask7,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask8,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask9,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask10, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid0,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid2,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid3,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid4,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid5,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid6,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid7,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid8,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid9,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid10, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid11, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid12, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(13, order_book.bids().size());
                      BOOST_CHECK_EQUAL(11, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1249, 3,  500));
                      BOOST_CHECK(dc.verify_ask(1250, 1,  500));
                    
                      // Fill the top ask level (erase) and add a bid level (insert)
                      SimpleOrder cross_bid(true,  1250, 800);
                      {
                        SimpleFillCheck fc1(&ask0,      500, 1250 * 500);
                        SimpleFillCheck fc4(&cross_bid, 500, 1250 * 500);
                        BOOST_CHECK(add_and_verify(order_book, &cross_bid, true, false));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1250, 1,  300));
                      BOOST_CHECK(dc.verify_ask(1251, 1,  400));
                    
                      // Fill the top ask level (erase) but do not add an bid level (no insert)
                      SimpleOrder cross_bid2(true,  1251, 400);
                      {
                        SimpleFillCheck fc1(&ask1,       400, 1251 * 400);
                        SimpleFillCheck fc4(&cross_bid2, 400, 1251 * 400);
                        BOOST_CHECK(add_and_verify(order_book, &cross_bid2, true, true));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1250, 1,  300));
                      BOOST_CHECK(dc.verify_ask(1252, 2,  300));
                    
                      // Fill the top ask level (erase) and add bid level (insert),
                      //    but nothing to restore
                      SimpleOrder cross_bid3(true,  1252, 2400);
                      {
                        SimpleFillCheck fc1(&ask2,        100, 1252 * 100);
                        SimpleFillCheck fc2(&ask3,        200, 1252 * 200);
                        SimpleFillCheck fc3(&cross_bid3,  300, 1252 * 300);
                        BOOST_CHECK(add_and_verify(order_book, &cross_bid3, true, false));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1252, 1, 2100)); // Insert
                      BOOST_CHECK(dc.verify_ask(1254, 1,  300));
                    
                      // Fill the top ask level (erase) but nothing to restore
                      SimpleOrder cross_bid4(true,  1254, 300);
                      {
                        SimpleFillCheck fc2(&ask4,        300, 1254 * 300);
                        SimpleFillCheck fc3(&cross_bid4,  300, 1254 * 300);
                        BOOST_CHECK(add_and_verify(order_book, &cross_bid4, true, true));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1252, 1, 2100));
                      BOOST_CHECK(dc.verify_ask(1255, 2,  700));
                    
                      // Partial fill the top ask level (reduce) 
                      SimpleOrder cross_bid5(true,  1255, 550);
                      {
                        SimpleFillCheck fc1(&ask5,        200, 1255 * 200);
                        SimpleFillCheck fc2(&ask6,        350, 1255 * 350);
                        SimpleFillCheck fc3(&cross_bid5,  550, 1255 * 550);
                        BOOST_CHECK(add_and_verify(order_book, &cross_bid5, true, true));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1252, 1, 2100));
                      BOOST_CHECK(dc.verify_ask(1255, 1,  150)); // 1 filled, 1 reduced
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestBboReplaceSizeDecrease)
                    {
                      SimpleOrderBook order_book;
                      ChangedChecker cc(order_book.depth());
                      SimpleOrder ask1(false, 1252, 200);
                      SimpleOrder ask0(false, 1252, 300);
                      SimpleOrder bid1(true,  1251, 100);
                      SimpleOrder bid0(true,  1250, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1251, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 2, 500));
                    
                      // Verify changed stamps
                      BOOST_CHECK(cc.verify_bbo_changed(true, true));
                      cc.reset();
                    
                      // Replace size
                      BOOST_CHECK(replace_and_verify(order_book, &bid0, -60));
                      BOOST_CHECK(replace_and_verify(order_book, &ask0, -150));
                    
                      // Verify orders
                      BOOST_CHECK_EQUAL(40, bid0.order_qty());
                      BOOST_CHECK_EQUAL(150, ask0.order_qty());
                      
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1251, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 2, 350));
                    
                      // Verify changed stamps
                      BOOST_CHECK(cc.verify_bbo_changed(false, true));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestBboReplaceSizeDecreaseCancel)
                    {
                      SimpleOrderBook order_book;
                      ChangedChecker cc(order_book.depth());
                      SimpleOrder ask1(false, 1252, 200);
                      SimpleOrder ask0(false, 1252, 300);
                      SimpleOrder bid1(true,  1251, 400);
                      SimpleOrder bid0(true,  1250, 100);
                      SimpleOrder bid2(true,  1249, 700);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid2, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1251, 1, 400));
                      BOOST_CHECK(dc.verify_ask(1252, 2, 500));
                    
                      // Partial Fill existing book
                      SimpleOrder cross_bid(true,  1252, 125);
                      SimpleOrder cross_ask(false, 1251, 100);
                      
                      {
                        SimpleFillCheck fc1(&cross_bid, 125, 1252 * 125);
                        SimpleFillCheck fc2(&ask0,      125, 1252 * 125);
                        BOOST_CHECK(add_and_verify(order_book, &cross_bid, true, true));
                      }
                      {
                        SimpleFillCheck fc1(&cross_ask, 100, 1251 * 100);
                        SimpleFillCheck fc2(&bid1,      100, 1251 * 100);
                        BOOST_CHECK(add_and_verify(order_book, &cross_ask, true, true));
                      }
                    
                      // Verify quantity
                      BOOST_CHECK_EQUAL(175, ask0.open_qty());
                      BOOST_CHECK_EQUAL(300, bid1.open_qty());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1251, 1, 300));
                      BOOST_CHECK(dc.verify_ask(1252, 2, 375));
                    
                      // Replace size - cancel
                      BOOST_CHECK(replace_and_verify(
                          order_book, &ask0, -175, PRICE_UNCHANGED, simple::os_cancelled)); 
                    
                      // Verify orders
                      BOOST_CHECK_EQUAL(125, ask0.order_qty());
                      BOOST_CHECK_EQUAL(0, ask0.open_qty());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1251, 1, 300));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 200));
                    
                      // Replace size - reduce level
                      BOOST_CHECK(replace_and_verify(
                          order_book, &bid1, -100, PRICE_UNCHANGED, simple::os_accepted)); 
                    
                      // Verify orders
                      BOOST_CHECK_EQUAL(300, bid1.order_qty());
                      BOOST_CHECK_EQUAL(200, bid1.open_qty());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1251, 1, 200));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 200));
                    
                      // Replace size - cancel and erase level
                      BOOST_CHECK(replace_and_verify(
                          order_book, &bid1, -200, PRICE_UNCHANGED, simple::os_cancelled)); 
                    
                      // Verify orders
                      BOOST_CHECK_EQUAL(100, bid1.order_qty());
                      BOOST_CHECK_EQUAL(0, bid1.open_qty());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 200));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestBboReplaceSizeDecreaseTooMuch)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask1(false, 1252, 200);
                      SimpleOrder ask0(false, 1252, 300);
                      SimpleOrder bid1(true,  1251, 100);
                      SimpleOrder bid0(true,  1250, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1251, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 2, 500));
                    
                      SimpleOrder cross_bid(true,  1252, 200);
                      // Partial fill existing order
                      {
                        SimpleFillCheck fc1(&cross_bid, 200, 1252 * 200);
                        SimpleFillCheck fc2(&ask0,      200, 1252 * 200);
                        BOOST_CHECK(add_and_verify(order_book, &cross_bid, true, true));
                      }
                    
                      // Verify open quantity
                      BOOST_CHECK_EQUAL(100, ask0.open_qty());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1251, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 2, 300));
                    
                      // Replace size - not enough left
                      order_book.replace(&ask0, -150, PRICE_UNCHANGED);
                    
                      // Verify ask0 state
                      BOOST_CHECK_EQUAL(0, ask0.open_qty());
                      BOOST_CHECK_EQUAL(200, ask0.order_qty());
                      BOOST_CHECK_EQUAL(simple::os_cancelled, ask0.state());
                    
                      // Verify depth unchanged
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1251, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 200));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestBboReplaceSizeIncreaseDecrease)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask1(false, 1252, 200);
                      SimpleOrder ask0(false, 1251, 300);
                      SimpleOrder bid1(true,  1251, 100);
                      SimpleOrder bid0(true,  1250, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 300));
                    
                      // Replace size
                      BOOST_CHECK(replace_and_verify(order_book, &ask0, 50));
                      BOOST_CHECK(replace_and_verify(order_book, &bid0, 25));
                    
                      BOOST_CHECK(replace_and_verify(order_book, &ask0, -100));
                      BOOST_CHECK(replace_and_verify(order_book, &bid0, 25));
                    
                      BOOST_CHECK(replace_and_verify(order_book, &ask0, 300));
                      BOOST_CHECK(replace_and_verify(order_book, &bid0, -75));
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1250, 1, 75));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 550));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestBboReplaceBidPriceChange)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask0(false, 1253, 300);
                      SimpleOrder ask1(false, 1252, 200);
                      SimpleOrder bid1(true,  1251, 140);
                      SimpleOrder bid0(true,  1250, 120);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1251, 1, 140));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 200));
                    
                      // Replace price increase
                      BOOST_CHECK(replace_and_verify(order_book, &bid0, SIZE_UNCHANGED, 1251));
                    
                      // Verify price change in book
                      SimpleOrderBook::Bids::const_iterator bid = order_book.bids().begin();
                      BOOST_CHECK_EQUAL(1251, bid->first);
                      BOOST_CHECK_EQUAL(&bid1, bid->second.ptr());
                      BOOST_CHECK_EQUAL(1251, (++bid)->first);
                      BOOST_CHECK_EQUAL(&bid0, bid->second.ptr());
                      BOOST_CHECK(order_book.bids().end() == ++bid);
                    
                      // Verify order
                      BOOST_CHECK_EQUAL(1251, bid0.price());
                      BOOST_CHECK_EQUAL(120, bid0.order_qty());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1251, 2, 260));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 200));
                    
                      // Replace price decrease
                      BOOST_CHECK(replace_and_verify(order_book, &bid1, SIZE_UNCHANGED, 1250));
                    
                      // Verify price change in book
                      bid = order_book.bids().begin();
                      BOOST_CHECK_EQUAL(1251, bid->first);
                      BOOST_CHECK_EQUAL(&bid0, bid->second.ptr());
                      BOOST_CHECK_EQUAL(1250, (++bid)->first);
                      BOOST_CHECK_EQUAL(&bid1, bid->second.ptr());
                      BOOST_CHECK(order_book.bids().end() == ++bid);
                    
                      // Verify order
                      BOOST_CHECK_EQUAL(1250, bid1.price());
                      BOOST_CHECK_EQUAL(140, bid1.order_qty());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1251, 1, 120));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 200));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestBboReplaceAskPriceChange)
                    {
                      SimpleOrderBook order_book;
                      ChangedChecker cc(order_book.depth());
                    
                      SimpleOrder ask0(false, 1253, 300);
                      SimpleOrder ask1(false, 1252, 200);
                      SimpleOrder bid1(true,  1251, 140);
                      SimpleOrder bid0(true,  1250, 120);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1251, 1, 140));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 200));
                    
                      // Replace price increase 1252 -> 1253
                      BOOST_CHECK(replace_and_verify(order_book, &ask1, SIZE_UNCHANGED, 1253));
                    
                      // Verify price change in book
                      SimpleOrderBook::Asks::const_iterator ask = order_book.asks().begin();
                      BOOST_CHECK_EQUAL(1253, ask->first);
                      BOOST_CHECK_EQUAL(&ask0, ask->second.ptr());
                      BOOST_CHECK_EQUAL(1253, (++ask)->first);
                      BOOST_CHECK_EQUAL(&ask1, ask->second.ptr());
                      BOOST_CHECK(order_book.asks().end() == ++ask);
                    
                      // Verify order
                      BOOST_CHECK_EQUAL(1253, ask1.price());
                      BOOST_CHECK_EQUAL(200, ask1.order_qty());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1251, 1, 140));
                      BOOST_CHECK(dc.verify_ask(1253, 2, 500));
                    
                      // Replace price decrease 1253 -> 1252
                      BOOST_CHECK(replace_and_verify(order_book, &ask0, SIZE_UNCHANGED, 1252));
                    
                      // Verify price change in book
                      ask = order_book.asks().begin();
                      BOOST_CHECK_EQUAL(1252, ask->first);
                      BOOST_CHECK_EQUAL(&ask0, ask->second.ptr());
                      BOOST_CHECK_EQUAL(1253, (++ask)->first);
                      BOOST_CHECK_EQUAL(&ask1, ask->second.ptr());
                      BOOST_CHECK(order_book.asks().end() == ++ask);
                    
                      // Verify order
                      BOOST_CHECK_EQUAL(1252, ask0.price());
                      BOOST_CHECK_EQUAL(300, ask0.order_qty());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1251, 1, 140));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 300));
                    }
                    } // namespace
                </[ut_bbo_order_book.cpp]>
                <[ut_listeners.cpp]>
                    // Copyright (c) 2012 - 2017 Object Computing, Inc.
                    // All rights reserved.
                    // See the file license.txt for licensing information.
                    
                    #define BOOST_TEST_NO_MAIN LiquibookTest
                    #include <boost/test/unit_test.hpp>
                    
                    #include "ut_utils.h"
                    #include "changed_checker.h"
                    #include <book/order_book.h>
                    #include <simple/simple_order.h>
                    
                    namespace liquibook {
                    
                    using book::OrderBook;
                    using simple::SimpleOrder;
                    
                    typedef SimpleOrder* OrderPtr;
                    typedef OrderBook<OrderPtr> TypedOrderBook;
                    typedef DepthOrderBook<OrderPtr> TypedDepthOrderBook;
                    typedef TypedDepthOrderBook::DepthTracker DepthTracker;
                    
                    class TradeCbListener : public TradeListener<TypedOrderBook>
                    {
                    public:
                      virtual void on_trade(const TypedOrderBook* order_book,
                                            Quantity qty,
                                            Cost cost)
                      {
                        quantities_.push_back(qty);
                        costs_.push_back(cost);
                      }
                    
                      void reset()
                      {
                        quantities_.clear();
                        costs_.clear();
                      }
                      std::vector<Quantity> quantities_;
                      std::vector<Cost> costs_;
                    };
                    
                    class OrderCbListener : public OrderListener<OrderPtr>
                    {
                    public:
                      virtual void on_accept(const OrderPtr& order)
                      {
                        accepts_.push_back(order);
                      }
                      virtual void on_reject(const OrderPtr& order, const char* )
                      {
                        rejects_.push_back(order);
                      }
                      virtual void on_fill(const OrderPtr& order, 
                                           const OrderPtr& , // matched_order
                                           Quantity ,        // fill_qty
                                           Cost)             // fill_cost
                      {
                        fills_.push_back(order);
                      }
                      virtual void on_cancel(const OrderPtr& order)
                      {
                        cancels_.push_back(order);
                      }
                      virtual void on_cancel_reject(const OrderPtr& order, const char* )
                      {
                        cancel_rejects_.push_back(order);
                      }
                      virtual void on_replace(const OrderPtr& order,
                                              const int32_t& , // size_delta
                                              Price )          // new_price)
                      {
                        replaces_.push_back(order);
                      }
                      virtual void on_replace_reject(const OrderPtr& order, const char* )
                      {
                        replace_rejects_.push_back(order);
                      }
                    
                      void reset()
                      {
                        accepts_.clear();
                        rejects_.clear();
                        fills_.clear();
                        cancels_.clear();
                        cancel_rejects_.clear();
                        replaces_.clear();
                        replace_rejects_.clear();
                      }
                    
                      typedef std::vector<const SimpleOrder*> OrderVector;
                      OrderVector accepts_;
                      OrderVector rejects_;
                      OrderVector fills_;
                      OrderVector cancels_;
                      OrderVector cancel_rejects_;
                      OrderVector replaces_;
                      OrderVector replace_rejects_;
                    };
                    
                    BOOST_AUTO_TEST_CASE(TestOrderCallbacks)
                    {
                      SimpleOrder order0(false, 3250, 100);
                      SimpleOrder order1(true,  3250, 800);
                      SimpleOrder order2(false, 3230, 0);
                      SimpleOrder order3(false, 3240, 200);
                      SimpleOrder order4(true,  3250, 600);
                    
                      OrderCbListener listener;
                      TypedOrderBook order_book;
                      order_book.set_order_listener(&listener);
                      // Add order, should be accepted
                      order_book.add(&order0);
                      BOOST_CHECK_EQUAL(1, listener.accepts_.size());
                      listener.reset();
                      // Add matching order, should be accepted, followed by a fill
                      order_book.add(&order1);
                      BOOST_CHECK_EQUAL(1, listener.accepts_.size());
                      BOOST_CHECK_EQUAL(1, listener.fills_.size());
                      listener.reset();
                      // Add invalid order, should be rejected
                      order_book.add(&order2);
                      BOOST_CHECK_EQUAL(1, listener.rejects_.size());
                      listener.reset();
                      // Cancel only valid order, should be cancelled
                      order_book.cancel(&order1);
                      BOOST_CHECK_EQUAL(1, listener.cancels_.size());
                      listener.reset();
                      // Cancel filled order, should be rejected
                      order_book.cancel(&order0);
                      BOOST_CHECK_EQUAL(1, listener.cancel_rejects_.size());
                      listener.reset();
                      // Add a new order and replace it, should be replaced
                      order_book.add(&order3);
                      order_book.replace(&order3, 0, 3250);
                      BOOST_CHECK_EQUAL(1, listener.accepts_.size());
                      BOOST_CHECK_EQUAL(1, listener.replaces_.size());
                      listener.reset();
                      // Add matching order, should be accepted, followed by a fill
                      order_book.add(&order4);
                      BOOST_CHECK_EQUAL(1, listener.accepts_.size());
                      BOOST_CHECK_EQUAL(1, listener.fills_.size());
                      listener.reset();
                      // Replace matched order, with too large of a size decrease, replace
                      // should be rejected
                      order_book.replace(&order3, -500);
                      BOOST_CHECK_EQUAL(0, listener.replaces_.size());
                      BOOST_CHECK_EQUAL(1, listener.replace_rejects_.size());
                    }
                    
                    class OrderBookCbListener : public OrderBookListener<TypedOrderBook>
                    {
                    public:
                    
                      virtual void on_order_book_change(const TypedOrderBook* book)
                      {
                        changes_.push_back(book);
                      }
                    
                      void reset()
                      {
                        changes_.clear();
                      }
                    
                      typedef std::vector<const TypedOrderBook*> OrderBookVector;
                      OrderBookVector changes_;
                    };
                    
                    BOOST_AUTO_TEST_CASE(TestOrderBookCallbacks)
                    {
                      SimpleOrder order0(false, 3250, 100);
                      SimpleOrder order1(true,  3250, 800);
                      SimpleOrder order2(false, 3230, 0);
                      SimpleOrder order3(false, 3240, 200);
                      SimpleOrder order4(true,  3250, 600);
                    
                      OrderBookCbListener listener;
                      OrderBook<OrderPtr> order_book;
                      order_book.set_order_book_listener(&listener);
                      // Add order, should be accepted
                      order_book.add(&order0);
                      BOOST_CHECK_EQUAL(1, listener.changes_.size());
                      listener.reset();
                      // Add matching order, should be accepted, followed by a fill
                      order_book.add(&order1);
                      BOOST_CHECK_EQUAL(1, listener.changes_.size());
                      listener.reset();
                      // Add invalid order, should be rejected
                      order_book.add(&order2);
                      BOOST_CHECK_EQUAL(0, listener.changes_.size());  // NO CHANGE
                      listener.reset();
                      // Cancel only valid order, should be cancelled
                      order_book.cancel(&order1);
                      BOOST_CHECK_EQUAL(1, listener.changes_.size());
                      listener.reset();
                      // Cancel filled order, should be rejected
                      order_book.cancel(&order0);
                      BOOST_CHECK_EQUAL(0, listener.changes_.size());  // NO CHANGE
                      listener.reset();
                      // Add a new order and replace it, should be replaced
                      order_book.add(&order3);
                      order_book.replace(&order3, 0, 3250);
                      BOOST_CHECK_EQUAL(2, listener.changes_.size());
                      listener.reset();
                      // Add matching order, should be accepted, followed by a fill
                      order_book.add(&order4);
                      BOOST_CHECK_EQUAL(1, listener.changes_.size());
                      listener.reset();
                      // Replace matched order, with too large of a size decrease, replace
                      // should be rejected
                      order_book.replace(&order3, -500);
                      BOOST_CHECK_EQUAL(0, listener.changes_.size());  // NO CHANGE
                    }
                    
                    class DepthCbListener 
                          : public TypedDepthOrderBook::TypedDepthListener
                    {
                    public:
                      virtual void on_depth_change(const TypedDepthOrderBook* book,
                                                   const DepthTracker* ) // depth
                      {
                        changes_.push_back(book);
                      }
                    
                      void reset()
                      {
                        changes_.clear();
                    
                      }
                      typedef std::vector<const TypedDepthOrderBook*> OrderBooks;
                      OrderBooks changes_;
                    };
                    
                    BOOST_AUTO_TEST_CASE(TestDepthCallbacks)
                    {
                      SimpleOrder buy0(true, 3250, 100);
                      SimpleOrder buy1(true, 3249, 800);
                      SimpleOrder buy2(true, 3248, 300);
                      SimpleOrder buy3(true, 3247, 200);
                      SimpleOrder buy4(true, 3246, 600);
                      SimpleOrder buy5(true, 3245, 300);
                      SimpleOrder buy6(true, 3244, 100);
                      SimpleOrder sell0(false, 3250, 300);
                      SimpleOrder sell1(false, 3251, 200);
                      SimpleOrder sell2(false, 3252, 200);
                      SimpleOrder sell3(false, 3253, 400);
                      SimpleOrder sell4(false, 3254, 300);
                      SimpleOrder sell5(false, 3255, 100);
                      SimpleOrder sell6(false, 3255, 100);
                    
                      DepthCbListener listener;
                      TypedDepthOrderBook order_book;
                      order_book.set_depth_listener(&listener);
                      // Add buy orders, should be accepted
                      order_book.add(&buy0);
                      order_book.add(&buy1);
                      order_book.add(&buy2);
                      order_book.add(&buy3);
                      order_book.add(&buy4);
                      BOOST_CHECK_EQUAL(5, listener.changes_.size());
                      listener.reset();
                    
                      // Add buy orders past end, should be accepted, but not affect depth
                      order_book.add(&buy5);
                      order_book.add(&buy6);
                      BOOST_CHECK_EQUAL(0, listener.changes_.size());
                      listener.reset();
                    
                      // Add sell orders, should be accepted and affect depth
                      order_book.add(&sell5);
                      order_book.add(&sell4);
                      order_book.add(&sell3);
                      order_book.add(&sell2);
                      order_book.add(&sell1);
                      order_book.add(&sell0);
                      BOOST_CHECK_EQUAL(6, listener.changes_.size());
                      listener.reset();
                    
                      // Add sell order past end, should be accepted, but not affect depth
                      order_book.add(&sell6);
                      BOOST_CHECK_EQUAL(0, listener.changes_.size());
                      listener.reset();
                    }
                    
                    class BboCbListener 
                          : public TypedDepthOrderBook::TypedBboListener
                    {
                      public:
                      virtual void on_bbo_change(const TypedDepthOrderBook* book,
                                                 const DepthTracker* ) // depth
                      {
                        changes_.push_back(book);
                      }
                    
                      void reset()
                      {
                        changes_.clear();
                      }
                    
                      typedef std::vector<const TypedDepthOrderBook*> OrderBooks;
                      OrderBooks changes_;
                    };
                    
                    BOOST_AUTO_TEST_CASE(TestBboCallbacks)
                    {
                      SimpleOrder buy0(true, 3250, 100);
                      SimpleOrder buy1(true, 3249, 800);
                      SimpleOrder buy2(true, 3248, 300);
                      SimpleOrder buy3(true, 3247, 200);
                      SimpleOrder buy4(true, 3246, 600);
                      SimpleOrder buy5(true, 3245, 300);
                      SimpleOrder buy6(true, 3244, 100);
                      SimpleOrder sell0(false, 3250, 300);
                      SimpleOrder sell1(false, 3251, 200);
                      SimpleOrder sell2(false, 3252, 200);
                      SimpleOrder sell3(false, 3253, 400);
                      SimpleOrder sell4(false, 3254, 300);
                      SimpleOrder sell5(false, 3255, 100);
                      SimpleOrder sell6(false, 3255, 100);
                    
                      BboCbListener listener;
                      TypedDepthOrderBook order_book;
                      order_book.set_bbo_listener(&listener);
                      // Add buy orders, should be accepted
                      order_book.add(&buy0);
                      BOOST_CHECK_EQUAL(1, listener.changes_.size());
                      listener.reset();
                      order_book.add(&buy1);
                      BOOST_CHECK_EQUAL(0, listener.changes_.size());
                      listener.reset();
                      order_book.add(&buy2);
                      BOOST_CHECK_EQUAL(0, listener.changes_.size());
                      listener.reset();
                      order_book.add(&buy3);
                      BOOST_CHECK_EQUAL(0, listener.changes_.size());
                      listener.reset();
                      order_book.add(&buy4);
                      BOOST_CHECK_EQUAL(0, listener.changes_.size());
                      listener.reset();
                    
                      // Add buy orders past end, should be accepted, but not affect depth
                      order_book.add(&buy5);
                      BOOST_CHECK_EQUAL(0, listener.changes_.size());
                      listener.reset();
                      order_book.add(&buy6);
                      BOOST_CHECK_EQUAL(0, listener.changes_.size());
                      listener.reset();
                    
                      // Add sell orders, should be accepted and affect bbo
                      order_book.add(&sell2);
                      BOOST_CHECK_EQUAL(1, listener.changes_.size());
                      listener.reset();
                      order_book.add(&sell1);
                      BOOST_CHECK_EQUAL(1, listener.changes_.size());
                      listener.reset();
                      order_book.add(&sell0);
                      BOOST_CHECK_EQUAL(1, listener.changes_.size());
                      listener.reset();
                      // Add sell orders worse than best bid, should not effect bbo
                      order_book.add(&sell5);
                      BOOST_CHECK_EQUAL(0, listener.changes_.size());
                      listener.reset();
                      order_book.add(&sell4);
                      BOOST_CHECK_EQUAL(0, listener.changes_.size());
                      listener.reset();
                      order_book.add(&sell3);
                      BOOST_CHECK_EQUAL(0, listener.changes_.size());
                      listener.reset();
                    
                      // Add sell order past end, should be accepted, but not affect depth
                      order_book.add(&sell6);
                      BOOST_CHECK_EQUAL(0, listener.changes_.size());
                      listener.reset();
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestTradeCallbacks) 
                    {
                      SimpleOrder order0(false, 3250, 100);
                      SimpleOrder order1(true,  3250, 800);
                      SimpleOrder order2(false, 3230, 0);
                      SimpleOrder order3(false, 3240, 200);
                      SimpleOrder order4(true,  3250, 600);
                    
                      TradeCbListener listener;
                      TypedOrderBook order_book;
                      order_book.set_trade_listener(&listener);
                      // Add order, should be accepted
                      order_book.add(&order0);
                      BOOST_CHECK_EQUAL(0, listener.quantities_.size());
                      listener.reset();
                      // Add matching order, should result in a trade
                      order_book.add(&order1);
                      BOOST_CHECK_EQUAL(1, listener.quantities_.size());
                      BOOST_CHECK_EQUAL(1, listener.costs_.size());
                      BOOST_CHECK_EQUAL(100, listener.quantities_[0]);
                      BOOST_CHECK_EQUAL(100 * 3250, listener.costs_[0]);
                      listener.reset();
                      // Add invalid order, should be rejected
                      order_book.add(&order2);
                      BOOST_CHECK_EQUAL(0, listener.quantities_.size());
                      listener.reset();
                      // Cancel only valid order, should be cancelled
                      order_book.cancel(&order1);
                      BOOST_CHECK_EQUAL(0, listener.quantities_.size());
                      listener.reset();
                      // Cancel filled order, should be rejected
                      order_book.cancel(&order0);
                      BOOST_CHECK_EQUAL(0, listener.quantities_.size());
                      listener.reset();
                      // Add a new order and replace it, should be replaced
                      order_book.add(&order3);
                      order_book.replace(&order3, 0, 3250);
                      BOOST_CHECK_EQUAL(0, listener.quantities_.size());
                      listener.reset();
                      // Add matching order, should be accepted, followed by a fill
                      order_book.add(&order4);
                      BOOST_CHECK_EQUAL(1, listener.quantities_.size());
                      BOOST_CHECK_EQUAL(1, listener.costs_.size());
                      listener.reset();
                      // Replace matched order, with too large of a size decrease, replace
                      // should be rejected
                      order_book.replace(&order3, -500);
                      BOOST_CHECK_EQUAL(0, listener.quantities_.size());
                    }
                    
                    } // namespace liquibook
                </[ut_listeners.cpp]>
                <[ut_stop_orders.cpp]>
                    // Copyright (c) 2012 - 2017 Object Computing, Inc.
                    // All rights reserved.
                    // See the file license.txt for licensing information.
                    
                    #define BOOST_TEST_NO_MAIN LiquibookTest
                    #include <boost/test/unit_test.hpp>
                    
                    #include "ut_utils.h"
                    #include "changed_checker.h"
                    #include <book/order_book.h>
                    #include <simple/simple_order.h>
                    
                    namespace liquibook {
                    
                    using book::DepthLevel;
                    using book::OrderBook;
                    using book::OrderTracker;
                    using simple::SimpleOrder;
                    
                    namespace
                    {
                      const bool sideBuy = true;
                      const bool sideSell = false;
                    
                      const Price prcMkt = 0;
                      const Price prc53 = 53;
                      const Price prc54 = 54;
                      const Price prc55 = 55;
                      const Price prc56 = 56;
                      const Price prc57 = 57;
                    
                      const Quantity q100 = 100;
                      const Quantity q1000 = 1000;
                    
                      const bool expectMatch = true;
                      const bool expectNoMatch = false;
                    
                      const bool expectComplete = true;
                      const bool expectNoComplete = false;
                    }
                    
                    typedef OrderTracker<SimpleOrder*> SimpleTracker;
                    typedef test::ChangedChecker<5> ChangedChecker;
                    
                    typedef FillCheck<SimpleOrder*> SimpleFillCheck;
                    
                    BOOST_AUTO_TEST_CASE(TestStopOrdersOffMarketNoTrade)
                    {
                      SimpleOrderBook book;
                      SimpleOrder order0(sideBuy, prc55, q100);
                      SimpleOrder order1(sideSell, prcMkt, q100);
                    
                      // Enter order to generate a trade establishing market price
                      BOOST_CHECK(add_and_verify(book, &order0, expectNoMatch));
                      BOOST_CHECK(add_and_verify(book, &order1, expectMatch, expectComplete));
                    
                      BOOST_CHECK_EQUAL(prc55, book.market_price());
                    
                      SimpleOrder order2(sideBuy, prcMkt, q100, prc56);
                      SimpleOrder order3(sideSell, prcMkt, q100, prc54);
                      BOOST_CHECK(add_and_verify(book, &order2, expectNoMatch));
                      BOOST_CHECK(add_and_verify(book, &order3, expectNoMatch));
                      
                      // Orders were accepted, but not traded
                      BOOST_CHECK_EQUAL(simple::os_accepted, order2.state());
                      BOOST_CHECK_EQUAL(simple::os_accepted, order3.state());
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestStopMarketOrdersOnMarketTradeImmediately)
                    {
                      SimpleOrderBook book;
                      SimpleOrder order0(sideBuy, prc55, q100);
                      SimpleOrder order1(sideSell, prcMkt, q100);
                    
                      // Enter order to generate a trade establishing market price
                      BOOST_CHECK(add_and_verify(book, &order0, expectNoMatch));
                      BOOST_CHECK(add_and_verify(book, &order1, expectMatch, expectComplete));
                    
                      BOOST_CHECK_EQUAL(prc55, book.market_price());
                    
                      SimpleOrder order2(sideBuy, prcMkt, q100, prc55);
                      SimpleOrder order3(sideSell, prcMkt, q100, prc55);
                      BOOST_CHECK(add_and_verify(book, &order2, expectNoMatch));
                      BOOST_CHECK(add_and_verify(book, &order3, expectMatch, expectComplete));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestStopMarketOrdersTradeWhenStopPriceReached)
                    {
                      SimpleOrderBook book;
                      SimpleOrder order0(sideBuy, prc53, q100);
                      SimpleOrder order1(sideSell, prc57, q100);
                      book.set_market_price(prc55);
                    
                      // Enter seed orders and be sure they don't trade with each other.
                      BOOST_CHECK(add_and_verify(book, &order0, expectNoMatch));
                      BOOST_CHECK(add_and_verify(book, &order1, expectNoMatch));
                    
                      // enter stop orders.  Be sure they don't trade yet
                      SimpleOrder order2(sideBuy, prcMkt, q100, prc56);
                      SimpleOrder order3(sideSell, prcMkt, q100, prc54);
                      BOOST_CHECK(add_and_verify(book, &order2, expectNoMatch));
                      BOOST_CHECK(add_and_verify(book, &order3, expectNoMatch));
                    
                      SimpleOrder order4(sideBuy, prc56, q1000, 0, book::oc_all_or_none);
                      SimpleOrder order5(sideSell, prc56, q1000, 0, book::oc_all_or_none);
                    
                      // Scope for fill checks
                      {
                        SimpleFillCheck fc0(&order0, 0, 0);
                        SimpleFillCheck fc1(&order1, q100, q100 * prc57);
                        SimpleFillCheck fc2(&order2, q100, q100 * prc57);
                        // Trade at 56 which should trigger order2 which should trade with order 1 at order 1's price
                        BOOST_CHECK(add_and_verify(book, &order4, expectNoMatch, expectNoComplete, book::oc_all_or_none));
                        BOOST_CHECK(add_and_verify(book, &order5, expectMatch, expectComplete, book::oc_all_or_none));
                      }
                      BOOST_CHECK_EQUAL(prc57, book.market_price());
                    
                      SimpleOrder order6(sideBuy, prc54, q1000, 0, book::oc_all_or_none);
                      SimpleOrder order7(sideSell, prc54, q1000, 0, book::oc_all_or_none);
                    
                      // Scope for fill checks
                      {
                        SimpleFillCheck fc0(&order0, q100, q100 * prc53);
                        SimpleFillCheck fc3(&order3, q100, q100 * prc53);
                        // Trade at 54 which should trigger order3 which should trade with order 0 at order 0's price
                        BOOST_CHECK(add_and_verify(book, &order6, expectNoMatch, expectNoComplete, book::oc_all_or_none));
                        BOOST_CHECK(add_and_verify(book, &order7, expectMatch, expectComplete, book::oc_all_or_none));
                      }
                      BOOST_CHECK_EQUAL(prc53, book.market_price());
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestStopOrdersCancelBeforeTrigger)
                    {
                      SimpleOrderBook book;
                      book.set_market_price(prc55);
                    
                      SimpleOrder bid(sideBuy, prcMkt, q100, prc56);
                      SimpleOrder ask(sideSell, prcMkt, q100, prc54);
                      BOOST_CHECK(add_and_verify(book, &bid, expectNoMatch));
                      BOOST_CHECK(add_and_verify(book, &ask, expectNoMatch));
                      
                      // Orders were accepted, but not traded
                      BOOST_CHECK_EQUAL(simple::os_accepted, bid.state());
                      BOOST_CHECK_EQUAL(simple::os_accepted, ask.state());
                      // Cancel bid and ask
                      BOOST_CHECK(cancel_and_verify(book, &bid, simple::os_cancelled));
                      BOOST_CHECK(cancel_and_verify(book, &ask, simple::os_cancelled));
                    }
                    
                    } // namespace
                </[ut_stop_orders.cpp]>
                <[ut_main.cpp]>
                    // Copyright (c) 2017, Object Computing, Inc.
                    // All rights reserved.
                    // See the file license.txt for licensing information.
                    #define BOOST_TEST_MODULE LiquibookTest
                    #include <boost/test/unit_test.hpp>
                </[ut_main.cpp]>
                <[ut_order_book.cpp]>
                    // Copyright (c) 2012 - 2017 Object Computing, Inc.
                    // All rights reserved.
                    // See the file license.txt for licensing information.
                    
                    #define BOOST_TEST_NO_MAIN LiquibookTest
                    #include <boost/test/unit_test.hpp>
                    
                    #include "ut_utils.h"
                    #include "changed_checker.h"
                    #include <book/order_book.h>
                    #include <simple/simple_order.h>
                    
                    namespace liquibook {
                    
                    using book::DepthLevel;
                    using book::OrderBook;
                    using book::OrderTracker;
                    using simple::SimpleOrder;
                    
                    typedef OrderTracker<SimpleOrder*> SimpleTracker;
                    typedef test::ChangedChecker<5> ChangedChecker;
                    
                    typedef FillCheck<SimpleOrder*> SimpleFillCheck;
                    
                    BOOST_AUTO_TEST_CASE(TestBidsMultimapSortCorrect)
                    {
                      SimpleOrderBook::Bids bids;
                      SimpleOrder order0(true, 1250, 100);
                      SimpleOrder order1(true, 1255, 100);
                      SimpleOrder order2(true, 1240, 100);
                      SimpleOrder order3(true, MARKET_ORDER_PRICE, 100);
                      SimpleOrder order4(true, 1245, 100);
                    
                      // Insert out of price order
                      bids.insert(std::make_pair(book::ComparablePrice(true, order0.price()), SimpleTracker(&order0)));
                      bids.insert(std::make_pair(book::ComparablePrice(true, order1.price()), SimpleTracker(&order1)));
                      bids.insert(std::make_pair(book::ComparablePrice(true, order2.price()), SimpleTracker(&order2)));
                      bids.insert(std::make_pair(book::ComparablePrice(true, order3.price()), SimpleTracker(&order3)));
                      bids.insert(std::make_pair(book::ComparablePrice(true, order4.price()), SimpleTracker(&order4)));
                      
                      // Should access in price order
                      SimpleOrder* expected_order[] = {
                        &order3, &order1, &order0, &order4, &order2
                      };
                    
                      SimpleOrderBook::Bids::iterator bid;
                      int index = 0;
                    
                      for (bid = bids.begin(); bid != bids.end(); ++bid, ++index) {
                        BOOST_CHECK_EQUAL(expected_order[index]->price(), bid->first);
                        BOOST_CHECK_EQUAL(expected_order[index], bid->second.ptr());
                      }
                    
                      // Should be able to search and find
                      BOOST_CHECK((bids.upper_bound(book::ComparablePrice(true, 1245)))->second.ptr()->price() == 1240);
                      BOOST_CHECK((bids.lower_bound(book::ComparablePrice(true, 1245)))->second.ptr()->price() == 1245);
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestAsksMultimapSortCorrect)
                    {
                      SimpleOrderBook::Asks asks;
                      SimpleOrder order0(false, 3250, 100);
                      SimpleOrder order1(false, 3235, 800);
                      SimpleOrder order2(false, 3230, 200);
                      SimpleOrder order3(false,    0, 200);
                      SimpleOrder order4(false, 3245, 100);
                      SimpleOrder order5(false, 3265, 200);
                    
                      // Insert out of price order
                      asks.insert(std::make_pair(book::ComparablePrice(false, order0.price()), SimpleTracker(&order0)));
                      asks.insert(std::make_pair(book::ComparablePrice(false, order1.price()), SimpleTracker(&order1)));
                      asks.insert(std::make_pair(book::ComparablePrice(false, order2.price()), SimpleTracker(&order2)));
                      asks.insert(std::make_pair(book::ComparablePrice(false, MARKET_ORDER_PRICE), 
                                                 SimpleTracker(&order3)));
                      asks.insert(std::make_pair(book::ComparablePrice(false, order4.price()), SimpleTracker(&order4)));
                      asks.insert(std::make_pair(book::ComparablePrice(false, order5.price()), SimpleTracker(&order5)));
                      
                      // Should access in price order
                      SimpleOrder* expected_order[] = {
                        &order3, &order2, &order1, &order4, &order0, &order5
                      };
                    
                      SimpleOrderBook::Asks::iterator ask;
                      int index = 0;
                    
                      for (ask = asks.begin(); ask != asks.end(); ++ask, ++index) {
                        BOOST_CHECK_EQUAL(expected_order[index]->price(), ask->first);
                        BOOST_CHECK_EQUAL(expected_order[index], ask->second.ptr());
                      }
                    
                      BOOST_CHECK((asks.upper_bound(book::ComparablePrice(false, 3235)))->second.ptr()->price() == 3245);
                      BOOST_CHECK((asks.lower_bound(book::ComparablePrice(false, 3235)))->second.ptr()->price() == 3235);
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestAddCompleteBid)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask1(false, 1252, 100);
                      SimpleOrder ask0(false, 1251, 100);
                      SimpleOrder bid1(true,  1251, 100);
                      SimpleOrder bid0(true,  1250, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    
                      // Match - complete
                      {
                        SimpleFillCheck fc1(&bid1, 100, 125100);
                        SimpleFillCheck fc2(&ask0, 100, 125100);
                        BOOST_CHECK(add_and_verify(order_book, &bid1, true, true));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    }
                    namespace
                    {
                      bool isBuy = true;
                      bool isSell = false;
                      bool expectMatch = true;
                      bool expectNoMatch = false;
                      bool expectComplete = true;
                      bool expectNoComplete = false;
                    
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestAddCompleteAsk)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask0(isSell, 1251, 100);
                      SimpleOrder ask1(isSell, 1250, 100);
                      SimpleOrder bid0(isBuy,  1250, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 100));
                    
                      // Match - complete
                      //Scope for fill checks
                      {
                        SimpleFillCheck fc1(&ask1, 100, 125000);
                        SimpleFillCheck fc2(&bid0, 100, 125000);
                        BOOST_CHECK(add_and_verify(order_book, &ask1, true, true));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(   0, 0,   0));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 100));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(0, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestAddMultiMatchBid)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask1(false, 1252, 100);
                      SimpleOrder ask0(false, 1251, 300);
                      SimpleOrder ask2(false, 1251, 200);
                      SimpleOrder bid1(true,  1251, 500);
                      SimpleOrder bid0(true,  1250, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask2, false));
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1251, 2, 500));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(3, order_book.asks().size());
                    
                      // Match - complete
                      {
                        SimpleFillCheck fc1(&bid1, 500, 1251 * 500);
                        SimpleFillCheck fc2(&ask2, 200, 1251 * 200);
                        SimpleFillCheck fc3(&ask0, 300, 1251 * 300);
                        BOOST_CHECK(add_and_verify(order_book, &bid1, true, true));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    
                      // Verify remaining
                      BOOST_CHECK_EQUAL(&ask1, order_book.asks().begin()->second.ptr());
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestAddMultiMatchAsk)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask1(false, 9252, 100);
                      SimpleOrder ask0(false, 9251, 300);
                      SimpleOrder ask2(false, 9251, 200);
                      SimpleOrder ask3(false, 9250, 600);
                      SimpleOrder bid0(true,  9250, 100);
                      SimpleOrder bid1(true,  9250, 500);
                      SimpleOrder bid2(true,  9248, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid2, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask2, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(3, order_book.bids().size());
                      BOOST_CHECK_EQUAL(3, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(9250, 2, 600));
                      BOOST_CHECK(dc.verify_bid(9248, 1, 100));
                      BOOST_CHECK(dc.verify_ask(9251, 2, 500));
                      BOOST_CHECK(dc.verify_ask(9252, 1, 100));
                    
                      // Match - complete
                      {
                        SimpleFillCheck fc1(&ask3, 600, 9250 * 600);
                        SimpleFillCheck fc2(&bid0, 100, 9250 * 100);
                        SimpleFillCheck fc3(&bid1, 500, 9250 * 500);
                        BOOST_CHECK(add_and_verify(order_book, &ask3, true, true));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(9248, 1, 100));
                      BOOST_CHECK(dc.verify_ask(9251, 2, 500));
                      BOOST_CHECK(dc.verify_ask(9252, 1, 100));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(3, order_book.asks().size());
                    
                      // Verify remaining
                      BOOST_CHECK_EQUAL(&bid2, order_book.bids().begin()->second.ptr());
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestAddPartialMatchBid)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask0(false, 7253, 300);
                      SimpleOrder ask1(false, 7252, 100);
                      SimpleOrder ask2(false, 7251, 200);
                      SimpleOrder bid1(true,  7251, 350);
                      SimpleOrder bid0(true,  7250, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask2, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(3, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(7250, 1, 100));
                      BOOST_CHECK(dc.verify_ask(7251, 1, 200));
                      BOOST_CHECK(dc.verify_ask(7252, 1, 100));
                      BOOST_CHECK(dc.verify_ask(7253, 1, 300));
                    
                      // Match - partial
                      {
                        SimpleFillCheck fc1(&bid1, 200, 7251 * 200);
                        SimpleFillCheck fc2(&ask2, 200, 7251 * 200);
                        BOOST_CHECK(add_and_verify(order_book, &bid1, true, false));
                      }
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(2, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(7251, 1, 150));
                      BOOST_CHECK(dc.verify_bid(7250, 1, 100));
                      BOOST_CHECK(dc.verify_ask(7252, 1, 100));
                      BOOST_CHECK(dc.verify_ask(7253, 1, 300));
                    
                      // Verify remaining
                      BOOST_CHECK_EQUAL(&ask1, order_book.asks().begin()->second.ptr());
                      BOOST_CHECK_EQUAL(&bid1, order_book.bids().begin()->second.ptr());
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestAddPartialMatchAsk)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask0(false, 1253, 300);
                      SimpleOrder ask1(false, 1251, 400);
                      SimpleOrder bid1(true,  1251, 350);
                      SimpleOrder bid0(true,  1250, 100);
                      SimpleOrder bid2(true,  1250, 200);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid2, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(3, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1251, 1, 350));
                      BOOST_CHECK(dc.verify_bid(1250, 2, 300));
                      BOOST_CHECK(dc.verify_ask(1253, 1, 300));
                    
                      // Match - partial
                      {
                        SimpleFillCheck fc1(&ask1, 350, 1251 * 350);
                        SimpleFillCheck fc2(&bid1, 350, 1251 * 350);
                        BOOST_CHECK(add_and_verify(order_book, &ask1,  true, false));
                      }
                    
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(2, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1250, 2, 300));
                      BOOST_CHECK(dc.verify_ask(1251, 1,  50));
                      BOOST_CHECK(dc.verify_ask(1253, 1, 300));
                    
                      // Verify remaining
                      BOOST_CHECK_EQUAL(&bid0, order_book.bids().begin()->second.ptr());
                      BOOST_CHECK_EQUAL(&ask1, order_book.asks().begin()->second.ptr());
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestAddMultiPartialMatchBid)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask1(false, 1252, 100);
                      SimpleOrder ask2(false, 1251, 200);
                      SimpleOrder ask0(false, 1251, 300);
                      SimpleOrder bid1(true,  1251, 750);
                      SimpleOrder bid0(true,  1250, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask2, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(3, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1251, 2, 500));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    
                      // Match - partial
                      {
                        SimpleFillCheck fc1(&bid1, 500, 1251 * 500);
                        SimpleFillCheck fc2(&ask0, 300, 1251 * 300);
                        SimpleFillCheck fc3(&ask2, 200, 1251 * 200);
                        BOOST_CHECK(add_and_verify(order_book, &bid1, true, false));
                      }
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(2, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1251, 1, 250));
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    
                      // Verify remaining
                      BOOST_CHECK_EQUAL(&ask1, order_book.asks().begin()->second.ptr());
                      BOOST_CHECK_EQUAL(&bid1, order_book.bids().begin()->second.ptr());
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestAddMultiPartialMatchAsk)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask0(false, 1253, 300);
                      SimpleOrder ask1(false, 1251, 700);
                      SimpleOrder bid1(true,  1251, 370);
                      SimpleOrder bid2(true,  1251, 200);
                      SimpleOrder bid0(true,  1250, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid2, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(3, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1251, 2, 570));
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1253, 1, 300));
                    
                      // Match - partial
                      {
                        SimpleFillCheck fc1(&ask1, 570, 1251 * 570);
                        SimpleFillCheck fc2(&bid1, 370, 1251 * 370);
                        SimpleFillCheck fc3(&bid2, 200, 1251 * 200);
                        BOOST_CHECK(add_and_verify(order_book, &ask1,  true, false));
                      }
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 130));
                      BOOST_CHECK(dc.verify_ask(1253, 1, 300));
                    
                      // Verify remaining
                      BOOST_CHECK_EQUAL(&bid0, order_book.bids().begin()->second.ptr());
                      BOOST_CHECK_EQUAL(100, order_book.bids().begin()->second.open_qty());
                      BOOST_CHECK_EQUAL(&ask1, order_book.asks().begin()->second.ptr());
                      BOOST_CHECK_EQUAL(130, order_book.asks().begin()->second.open_qty());
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestRepeatMatchBid)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask3(false, 1251, 400);
                      SimpleOrder ask2(false, 1251, 200);
                      SimpleOrder ask1(false, 1251, 300);
                      SimpleOrder ask0(false, 1251, 100);
                      SimpleOrder bid1(true,  1251, 900);
                      SimpleOrder bid0(true,  1250, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, false));
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1251, 1, 900));
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                    
                      // Match - repeated
                      {
                        SimpleFillCheck fc1(&bid1, 100, 125100);
                        SimpleFillCheck fc2(&ask0, 100, 125100);
                        BOOST_CHECK(add_and_verify(order_book, &ask0, true, true));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1251, 1, 800));
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                    
                      {
                        SimpleFillCheck fc1(&bid1, 300, 1251 * 300);
                        SimpleFillCheck fc2(&ask1, 300, 1251 * 300);
                        BOOST_CHECK(add_and_verify(order_book, &ask1, true, true));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1251, 1, 500));
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                    
                      {
                        SimpleFillCheck fc1(&bid1, 200, 1251 * 200);
                        SimpleFillCheck fc2(&ask2, 200, 1251 * 200);
                        BOOST_CHECK(add_and_verify(order_book, &ask2, true, true));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1251, 1, 300));
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                    
                      {
                        SimpleFillCheck fc1(&bid1, 300, 1251 * 300);
                        SimpleFillCheck fc2(&ask3, 300, 1251 * 300);
                        BOOST_CHECK(add_and_verify(order_book, &ask3, true));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 100));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestRepeatMatchAsk)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask0(false,  1252, 100);
                      SimpleOrder ask1(false,  1251, 900);
                      SimpleOrder bid0(true, 1251, 100);
                      SimpleOrder bid1(true, 1251, 300);
                      SimpleOrder bid2(true, 1251, 200);
                      SimpleOrder bid3(true, 1251, 400);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_ask(1251, 1, 900));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    
                      BOOST_CHECK_EQUAL(&ask1, order_book.asks().begin()->second.ptr());
                    
                      // Match - repeated
                      {
                        SimpleFillCheck fc1(&ask1, 100, 125100);
                        SimpleFillCheck fc2(&bid0, 100, 125100);
                        BOOST_CHECK(add_and_verify(order_book, &bid0, true, true));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_ask(1251, 1, 800));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    
                      {
                        SimpleFillCheck fc1(&ask1, 300, 1251 * 300);
                        SimpleFillCheck fc2(&bid1, 300, 1251 * 300);
                        BOOST_CHECK(add_and_verify(order_book, &bid1, true, true));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_ask(1251, 1, 500));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    
                      {
                        SimpleFillCheck fc1(&ask1, 200, 1251 * 200);
                        SimpleFillCheck fc2(&bid2, 200, 1251 * 200);
                        BOOST_CHECK(add_and_verify(order_book, &bid2, true, true));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_ask(1251, 1, 300));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    
                      {
                        SimpleFillCheck fc1(&ask1, 300, 1251 * 300);
                        SimpleFillCheck fc2(&bid3, 300, 1251 * 300);
                        BOOST_CHECK(add_and_verify(order_book, &bid3, true));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1251, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestAddMarketOrderBid)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask1(false, 1252, 100);
                      SimpleOrder ask0(false, 1251, 100);
                      SimpleOrder bid1(true,     0, 100);
                      SimpleOrder bid0(true,  1250, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    
                      // Match - complete
                      {
                        SimpleFillCheck fc1(&bid1, 100, 125100);
                        SimpleFillCheck fc2(&ask0, 100, 125100);
                        BOOST_CHECK(add_and_verify(order_book, &bid1, true, true));
                      }
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestAddMarketOrderAsk)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask0(false, 1252, 100);
                      SimpleOrder ask1(false,    0, 100);
                      SimpleOrder bid1(true,  1251, 100);
                      SimpleOrder bid0(true,  1250, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(2, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1251, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    
                      // Match - complete
                      { 
                        //ASSERT_NO_THROW(
                          SimpleFillCheck fc1(&bid1, 100, 125100);
                          SimpleFillCheck fc2(&ask1, 100, 125100);
                          BOOST_CHECK(add_and_verify(order_book, &ask1, true, true));
                       // ); 
                      }
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestAddMarketOrderBidMultipleMatch)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask1(false, 12520, 300);
                      SimpleOrder ask0(false, 12510, 200);
                      SimpleOrder bid1(true,      0, 500);
                      SimpleOrder bid0(true,  12500, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(12500, 1, 100));
                      BOOST_CHECK(dc.verify_ask(12510, 1, 200));
                      BOOST_CHECK(dc.verify_ask(12520, 1, 300));
                    
                      // Match - complete
                      {
                        SimpleFillCheck fc1(&bid1, 500, 12510 * 200 + 12520 * 300);
                        SimpleFillCheck fc2(&ask0, 200, 12510 * 200);
                        SimpleFillCheck fc3(&ask1, 300, 12520 * 300);
                        BOOST_CHECK(add_and_verify(order_book, &bid1, true, true));
                      }
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(0, order_book.asks().size());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(12500, 1, 100));
                      BOOST_CHECK(dc.verify_ask(    0, 0,   0));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestAddMarketOrderAskMultipleMatch)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask0(false, 12520, 100);
                      SimpleOrder ask1(false,     0, 600);
                      SimpleOrder bid1(true,  12510, 200);
                      SimpleOrder bid0(true,  12500, 400);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(2, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(12510, 1, 200));
                      BOOST_CHECK(dc.verify_bid(12500, 1, 400));
                      BOOST_CHECK(dc.verify_ask(12520, 1, 100));
                    
                      // Match - complete
                      {
                        SimpleFillCheck fc1(&bid0, 400, 12500 * 400);
                        SimpleFillCheck fc2(&bid1, 200, 12510 * 200);
                        SimpleFillCheck fc3(&ask1, 600, 12500 * 400 + 12510 * 200);
                        BOOST_CHECK(add_and_verify(order_book, &ask1, true, true));
                      }
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(0, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(    0, 0,   0));
                      BOOST_CHECK(dc.verify_ask(12520, 1, 100));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestMatchMarketOrderBid)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask0(false, 1253, 100);
                      SimpleOrder bid1(true,     0, 100);
                      SimpleOrder bid0(true,  1250, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(2, order_book.bids().size());
                      BOOST_CHECK_EQUAL(0, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_bid(   0, 0,   0));
                      BOOST_CHECK(dc.verify_ask(   0, 0,   0));
                    
                      // Match - complete
                      {
                        SimpleFillCheck fc1(&bid1, 100, 125300);
                        SimpleFillCheck fc2(&ask0, 100, 125300);
                        BOOST_CHECK(add_and_verify(order_book, &ask0, true, true));
                      }
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(0, order_book.asks().size());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_ask(   0, 0,   0));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestMatchMarketOrderAsk)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask0(false, 1252, 100);
                      SimpleOrder ask1(false,    0, 100);
                      SimpleOrder bid0(true,  1250, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(0, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                      BOOST_CHECK(dc.verify_ask(   0, 0,   0));
                      BOOST_CHECK(dc.verify_bid(   0, 0,   0));
                    
                      // Match - complete
                      {
                        SimpleFillCheck fc1(&bid0, 100, 125000);
                        SimpleFillCheck fc2(&ask1, 100, 125000);
                        BOOST_CHECK(add_and_verify(order_book, &bid0, true, true));
                      }
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(0, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                      BOOST_CHECK(dc.verify_ask(   0, 0,   0));
                      BOOST_CHECK(dc.verify_bid(   0, 0,   0));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestMatchMultipleMarketOrderBid)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask0(false, 1253, 400);
                      SimpleOrder bid1(true,     0, 100);
                      SimpleOrder bid2(true,     0, 200);
                      SimpleOrder bid0(true,  1250, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid2, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(3, order_book.bids().size());
                      BOOST_CHECK_EQUAL(0, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_ask(   0, 0,   0));
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_bid(   0, 0,   0));
                    
                      // Match - complete
                      {
                        SimpleFillCheck fc1(&bid1, 100, 1253 * 100);
                        SimpleFillCheck fc2(&bid2, 200, 1253 * 200);
                        SimpleFillCheck fc3(&ask0, 300, 1253 * 300);
                        BOOST_CHECK(add_and_verify(order_book, &ask0, true, false));
                      }
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_ask(1253, 1, 100));
                      BOOST_CHECK(dc.verify_ask(   0, 0,   0));
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_bid(   0, 0,   0));
                    }
                    
                    
                    BOOST_AUTO_TEST_CASE(TestMatchMultipleMarketOrderAsk)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask0(false, 1252, 100);
                      SimpleOrder ask2(false,    0, 400);
                      SimpleOrder ask1(false,    0, 100);
                      SimpleOrder bid0(true,  1250, 300);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask2, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(0, order_book.bids().size());
                      BOOST_CHECK_EQUAL(3, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                      BOOST_CHECK(dc.verify_ask(   0, 0,   0));
                      BOOST_CHECK(dc.verify_bid(   0, 0,   0));
                    
                      // Match - partiaL
                      {
                        SimpleFillCheck fc1(&bid0, 300, 1250 * 300);
                        SimpleFillCheck fc2(&ask1, 100, 1250 * 100);
                        SimpleFillCheck fc3(&ask2, 200, 1250 * 200);
                        BOOST_CHECK(add_and_verify(order_book, &bid0, true, true));
                      }
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(0, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                      BOOST_CHECK(dc.verify_ask(   0, 0,   0));
                      BOOST_CHECK(dc.verify_bid(   0, 0,   0));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestCancelBid)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask2(false, 1252, 100);
                      SimpleOrder ask1(false, 1251, 100);
                      SimpleOrder ask0(false, 1251, 100);
                      SimpleOrder bid0(true,  1250, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask2, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(3, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1251, 2, 200));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    
                      // Cancel bid
                      BOOST_CHECK(cancel_and_verify(order_book, &bid0, simple::os_cancelled));
                    
                      // Cancel correctness
                      BOOST_CHECK(cancel_and_verify(order_book, &ask1, simple::os_cancelled));
                      BOOST_CHECK(cancel_and_verify(order_book, &ask1, simple::os_cancelled));
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(0,    0,   0));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(0, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestCancelAskAndMatch)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask1(false, 1252, 100);
                      SimpleOrder ask0(false, 1251, 100);
                      SimpleOrder bid2(true,  1252, 100);
                      SimpleOrder bid0(true,  1250, 100);
                      SimpleOrder bid1(true,  1250, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(2, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1250, 2, 200));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                    
                      // Cancel bid
                      BOOST_CHECK(cancel_and_verify(order_book, &ask0, simple::os_cancelled));
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1250, 2, 200));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                      BOOST_CHECK(dc.verify_ask(   0, 0,   0));
                    
                      // Match - partiaL
                      {
                        SimpleFillCheck fc1(&bid2, 100, 1252 * 100);
                        SimpleFillCheck fc2(&ask1, 100, 1252 * 100);
                        BOOST_CHECK(add_and_verify(order_book, &bid2, true, true));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1250, 2, 200));
                      BOOST_CHECK(dc.verify_ask(   0, 0,   0));
                    
                      // Cancel bid
                      BOOST_CHECK(cancel_and_verify(order_book, &bid0, simple::os_cancelled));
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_ask(   0, 0,   0));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(0, order_book.asks().size());
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestCancelBidFail)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask0(false, 1251, 100);
                      SimpleOrder ask1(false, 1250, 100);
                      SimpleOrder bid0(true,  1250, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_ask(1251, 1, 100));
                      BOOST_CHECK(dc.verify_ask(   0, 0,   0));
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_bid(   0, 0,   0));
                    
                      // Match - complete
                      {
                        SimpleFillCheck fc1(&ask1, 100, 125000);
                        SimpleFillCheck fc2(&bid0, 100, 125000);
                        BOOST_CHECK(add_and_verify(order_book, &ask1, true, true));
                      }
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(0, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_ask(1251, 1, 100));
                      BOOST_CHECK(dc.verify_ask(   0, 0,   0));
                      BOOST_CHECK(dc.verify_bid(   0, 0,   0));
                    
                      // Cancel a filled order
                      BOOST_CHECK(cancel_and_verify(order_book, &bid0, simple::os_complete));
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_ask(1251, 1, 100));
                      BOOST_CHECK(dc.verify_ask(   0, 0,   0));
                      BOOST_CHECK(dc.verify_bid(   0, 0,   0));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestCancelAskFail)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask1(false, 1252, 100);
                      SimpleOrder ask0(false, 1251, 100);
                      SimpleOrder bid1(true,  1251, 100);
                      SimpleOrder bid0(true,  1250, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(2, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_ask(1251, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                      BOOST_CHECK(dc.verify_ask(   0, 0,   0));
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_bid(   0, 0,   0));
                    
                      // Match - complete
                      {
                        SimpleFillCheck fc1(&bid1, 100, 125100);
                        SimpleFillCheck fc2(&ask0, 100, 125100);
                        BOOST_CHECK(add_and_verify(order_book, &bid1, true, true));
                      }
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                      BOOST_CHECK(dc.verify_ask(   0, 0,   0));
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_bid(   0, 0,   0));
                    
                      // Cancel a filled order
                      BOOST_CHECK(cancel_and_verify(order_book, &ask0, simple::os_complete));
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                      BOOST_CHECK(dc.verify_ask(   0, 0,   0));
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_bid(   0, 0,   0));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestCancelBidRestore)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask10(false, 1258, 600);
                      SimpleOrder ask9(false,  1257, 700);
                      SimpleOrder ask8(false,  1256, 100);
                      SimpleOrder ask7(false,  1256, 100);
                      SimpleOrder ask6(false,  1255, 500);
                      SimpleOrder ask5(false,  1255, 200);
                      SimpleOrder ask4(false,  1254, 300);
                      SimpleOrder ask3(false,  1252, 200);
                      SimpleOrder ask2(false,  1252, 100);
                      SimpleOrder ask1(false,  1251, 400);
                      SimpleOrder ask0(false,  1250, 500);
                    
                      SimpleOrder bid0(true,   1249, 100);
                      SimpleOrder bid1(true,   1249, 200);
                      SimpleOrder bid2(true,   1249, 200);
                      SimpleOrder bid3(true,   1248, 400);
                      SimpleOrder bid4(true,   1246, 600);
                      SimpleOrder bid5(true,   1246, 500);
                      SimpleOrder bid6(true,   1245, 200);
                      SimpleOrder bid7(true,   1245, 100);
                      SimpleOrder bid8(true,   1245, 200);
                      SimpleOrder bid9(true,   1244, 700);
                      SimpleOrder bid10(true,  1244, 300);
                      SimpleOrder bid11(true,  1242, 300);
                      SimpleOrder bid12(true,  1241, 400);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &ask0,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask2,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask3,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask4,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask5,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask6,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask7,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask8,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask9,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask10, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid0,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid2,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid3,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid4,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid5,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid6,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid7,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid8,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid9,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid10, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid11, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid12, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(13, order_book.bids().size());
                      BOOST_CHECK_EQUAL(11, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1249, 3,  500));
                      BOOST_CHECK(dc.verify_bid(1248, 1,  400));
                      BOOST_CHECK(dc.verify_bid(1246, 2, 1100));
                      BOOST_CHECK(dc.verify_bid(1245, 3,  500));
                      BOOST_CHECK(dc.verify_bid(1244, 2, 1000));
                      BOOST_CHECK(dc.verify_ask(1250, 1,  500));
                      BOOST_CHECK(dc.verify_ask(1251, 1,  400));
                      BOOST_CHECK(dc.verify_ask(1252, 2,  300));
                      BOOST_CHECK(dc.verify_ask(1254, 1,  300));
                      BOOST_CHECK(dc.verify_ask(1255, 2,  700));
                    
                      // Cancel a bid level (erase)
                      BOOST_CHECK(cancel_and_verify(order_book, &bid3, simple::os_cancelled));
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1249, 3,  500));
                      BOOST_CHECK(dc.verify_bid(1246, 2, 1100));
                      BOOST_CHECK(dc.verify_bid(1245, 3,  500));
                      BOOST_CHECK(dc.verify_bid(1244, 2, 1000));
                      BOOST_CHECK(dc.verify_bid(1242, 1,  300)); // Restored
                      BOOST_CHECK(dc.verify_ask(1250, 1,  500));
                      BOOST_CHECK(dc.verify_ask(1251, 1,  400));
                      BOOST_CHECK(dc.verify_ask(1252, 2,  300));
                      BOOST_CHECK(dc.verify_ask(1254, 1,  300));
                      BOOST_CHECK(dc.verify_ask(1255, 2,  700));
                      
                      // Cancel common bid levels (not erased)
                      BOOST_CHECK(cancel_and_verify(order_book, &bid7, simple::os_cancelled));
                      BOOST_CHECK(cancel_and_verify(order_book, &bid4, simple::os_cancelled));
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1249, 3,  500));
                      BOOST_CHECK(dc.verify_bid(1246, 1,  500)); // Cxl 600
                      BOOST_CHECK(dc.verify_bid(1245, 2,  400)); // Cxl 100
                      BOOST_CHECK(dc.verify_bid(1244, 2, 1000));
                      BOOST_CHECK(dc.verify_bid(1242, 1,  300));
                      BOOST_CHECK(dc.verify_ask(1250, 1,  500));
                      BOOST_CHECK(dc.verify_ask(1251, 1,  400));
                      BOOST_CHECK(dc.verify_ask(1252, 2,  300));
                      BOOST_CHECK(dc.verify_ask(1254, 1,  300));
                      BOOST_CHECK(dc.verify_ask(1255, 2,  700));
                    
                      // Cancel the best bid level (erased)
                      BOOST_CHECK(cancel_and_verify(order_book, &bid1, simple::os_cancelled));
                      BOOST_CHECK(cancel_and_verify(order_book, &bid0, simple::os_cancelled));
                      BOOST_CHECK(cancel_and_verify(order_book, &bid2, simple::os_cancelled));
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1246, 1,  500));
                      BOOST_CHECK(dc.verify_bid(1245, 2,  400));
                      BOOST_CHECK(dc.verify_bid(1244, 2, 1000));
                      BOOST_CHECK(dc.verify_bid(1242, 1,  300));
                      BOOST_CHECK(dc.verify_bid(1241, 1,  400));
                      BOOST_CHECK(dc.verify_ask(1250, 1,  500));
                      BOOST_CHECK(dc.verify_ask(1251, 1,  400));
                      BOOST_CHECK(dc.verify_ask(1252, 2,  300));
                      BOOST_CHECK(dc.verify_ask(1254, 1,  300));
                      BOOST_CHECK(dc.verify_ask(1255, 2,  700));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestCancelAskRestore)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask10(false, 1258, 600);
                      SimpleOrder ask9(false,  1257, 700);
                      SimpleOrder ask8(false,  1256, 100);
                      SimpleOrder ask7(false,  1256, 100);
                      SimpleOrder ask6(false,  1255, 500);
                      SimpleOrder ask5(false,  1255, 200);
                      SimpleOrder ask4(false,  1254, 300);
                      SimpleOrder ask3(false,  1252, 200);
                      SimpleOrder ask2(false,  1252, 100);
                      SimpleOrder ask1(false,  1251, 400);
                      SimpleOrder ask0(false,  1250, 500);
                    
                      SimpleOrder bid0(true,   1249, 100);
                      SimpleOrder bid1(true,   1249, 200);
                      SimpleOrder bid2(true,   1249, 200);
                      SimpleOrder bid3(true,   1248, 400);
                      SimpleOrder bid4(true,   1246, 600);
                      SimpleOrder bid5(true,   1246, 500);
                      SimpleOrder bid6(true,   1245, 200);
                      SimpleOrder bid7(true,   1245, 100);
                      SimpleOrder bid8(true,   1245, 200);
                      SimpleOrder bid9(true,   1244, 700);
                      SimpleOrder bid10(true,  1244, 300);
                      SimpleOrder bid11(true,  1242, 300);
                      SimpleOrder bid12(true,  1241, 400);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &ask0,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask2,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask3,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask4,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask5,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask6,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask7,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask8,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask9,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask10, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid0,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid2,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid3,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid4,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid5,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid6,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid7,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid8,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid9,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid10, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid11, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid12, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(13, order_book.bids().size());
                      BOOST_CHECK_EQUAL(11, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1249, 3,  500));
                      BOOST_CHECK(dc.verify_bid(1248, 1,  400));
                      BOOST_CHECK(dc.verify_bid(1246, 2, 1100));
                      BOOST_CHECK(dc.verify_bid(1245, 3,  500));
                      BOOST_CHECK(dc.verify_bid(1244, 2, 1000));
                      BOOST_CHECK(dc.verify_ask(1250, 1,  500));
                      BOOST_CHECK(dc.verify_ask(1251, 1,  400));
                      BOOST_CHECK(dc.verify_ask(1252, 2,  300));
                      BOOST_CHECK(dc.verify_ask(1254, 1,  300));
                      BOOST_CHECK(dc.verify_ask(1255, 2,  700));
                    
                      // Cancel an ask level (erase)
                      BOOST_CHECK(cancel_and_verify(order_book, &ask1, simple::os_cancelled));
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1249, 3,  500));
                      BOOST_CHECK(dc.verify_bid(1248, 1,  400));
                      BOOST_CHECK(dc.verify_bid(1246, 2, 1100));
                      BOOST_CHECK(dc.verify_bid(1245, 3,  500));
                      BOOST_CHECK(dc.verify_bid(1244, 2, 1000));
                      BOOST_CHECK(dc.verify_ask(1250, 1,  500));
                      BOOST_CHECK(dc.verify_ask(1252, 2,  300));
                      BOOST_CHECK(dc.verify_ask(1254, 1,  300));
                      BOOST_CHECK(dc.verify_ask(1255, 2,  700));
                      BOOST_CHECK(dc.verify_ask(1256, 2,  200)); // Restored
                    
                      // Cancel common ask levels (not erased)
                      BOOST_CHECK(cancel_and_verify(order_book, &ask2, simple::os_cancelled));
                      BOOST_CHECK(cancel_and_verify(order_book, &ask6, simple::os_cancelled));
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1249, 3,  500));
                      BOOST_CHECK(dc.verify_bid(1248, 1,  400));
                      BOOST_CHECK(dc.verify_bid(1246, 2, 1100));
                      BOOST_CHECK(dc.verify_bid(1245, 3,  500));
                      BOOST_CHECK(dc.verify_bid(1244, 2, 1000));
                      BOOST_CHECK(dc.verify_ask(1250, 1,  500));
                      BOOST_CHECK(dc.verify_ask(1252, 1,  200)); // Cxl 100
                      BOOST_CHECK(dc.verify_ask(1254, 1,  300));
                      BOOST_CHECK(dc.verify_ask(1255, 1,  200)); // Cxl 500
                      BOOST_CHECK(dc.verify_ask(1256, 2,  200));
                    
                      // Cancel the best ask level (erased)
                      BOOST_CHECK(cancel_and_verify(order_book, &ask0, simple::os_cancelled));
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1249, 3,  500));
                      BOOST_CHECK(dc.verify_bid(1248, 1,  400));
                      BOOST_CHECK(dc.verify_bid(1246, 2, 1100));
                      BOOST_CHECK(dc.verify_bid(1245, 3,  500));
                      BOOST_CHECK(dc.verify_bid(1244, 2, 1000));
                      BOOST_CHECK(dc.verify_ask(1252, 1,  200));
                      BOOST_CHECK(dc.verify_ask(1254, 1,  300));
                      BOOST_CHECK(dc.verify_ask(1255, 1,  200));
                      BOOST_CHECK(dc.verify_ask(1256, 2,  200));
                      BOOST_CHECK(dc.verify_ask(1257, 1,  700)); // Restored
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestFillCompleteBidRestoreDepth)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask10(false, 1258, 600);
                      SimpleOrder ask9(false,  1257, 700);
                      SimpleOrder ask8(false,  1256, 100);
                      SimpleOrder ask7(false,  1256, 100);
                      SimpleOrder ask6(false,  1255, 500);
                      SimpleOrder ask5(false,  1255, 200);
                      SimpleOrder ask4(false,  1254, 300);
                      SimpleOrder ask3(false,  1252, 200);
                      SimpleOrder ask2(false,  1252, 100);
                      SimpleOrder ask1(false,  1251, 400);
                      SimpleOrder ask0(false,  1250, 500);
                    
                      SimpleOrder bid0(true,   1249, 100);
                      SimpleOrder bid1(true,   1249, 200);
                      SimpleOrder bid2(true,   1249, 200);
                      SimpleOrder bid3(true,   1248, 400);
                      SimpleOrder bid4(true,   1246, 600);
                      SimpleOrder bid5(true,   1246, 500);
                      SimpleOrder bid6(true,   1245, 200);
                      SimpleOrder bid7(true,   1245, 100);
                      SimpleOrder bid8(true,   1245, 200);
                      SimpleOrder bid9(true,   1244, 700);
                      SimpleOrder bid10(true,  1244, 300);
                      SimpleOrder bid11(true,  1242, 300);
                      SimpleOrder bid12(true,  1241, 400);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &ask0,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask2,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask3,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask4,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask5,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask6,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask7,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask8,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask9,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask10, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid0,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid2,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid3,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid4,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid5,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid6,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid7,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid8,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid9,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid10, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid11, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid12, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(13, order_book.bids().size());
                      BOOST_CHECK_EQUAL(11, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1249, 3,  500));
                      BOOST_CHECK(dc.verify_bid(1248, 1,  400));
                      BOOST_CHECK(dc.verify_bid(1246, 2, 1100));
                      BOOST_CHECK(dc.verify_bid(1245, 3,  500));
                      BOOST_CHECK(dc.verify_bid(1244, 2, 1000));
                      BOOST_CHECK(dc.verify_ask(1250, 1,  500));
                      BOOST_CHECK(dc.verify_ask(1251, 1,  400));
                      BOOST_CHECK(dc.verify_ask(1252, 2,  300));
                      BOOST_CHECK(dc.verify_ask(1254, 1,  300));
                      BOOST_CHECK(dc.verify_ask(1255, 2,  700));
                    
                      // Fill the top bid level (erase) and add an ask level (insert)
                      SimpleOrder cross_ask(false,  1249, 800);
                      {
                        SimpleFillCheck fc1(&bid0,      100, 1249 * 100);
                        SimpleFillCheck fc2(&bid1,      200, 1249 * 200);
                        SimpleFillCheck fc3(&bid2,      200, 1249 * 200);
                        SimpleFillCheck fc4(&cross_ask, 500, 1249 * 500);
                        BOOST_CHECK(add_and_verify(order_book, &cross_ask, true, false));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1248, 1,  400));
                      BOOST_CHECK(dc.verify_bid(1246, 2, 1100));
                      BOOST_CHECK(dc.verify_bid(1245, 3,  500));
                      BOOST_CHECK(dc.verify_bid(1244, 2, 1000));
                      BOOST_CHECK(dc.verify_bid(1242, 1,  300)); // Restored
                      BOOST_CHECK(dc.verify_ask(1249, 1,  300)); // Inserted
                      BOOST_CHECK(dc.verify_ask(1250, 1,  500));
                      BOOST_CHECK(dc.verify_ask(1251, 1,  400));
                      BOOST_CHECK(dc.verify_ask(1252, 2,  300));
                      BOOST_CHECK(dc.verify_ask(1254, 1,  300));
                      
                      // Fill the top bid level (erase) but do not add an ask level (no insert)
                      SimpleOrder cross_ask2(false,  1248, 400);
                      {
                        SimpleFillCheck fc1(&bid3,       400, 1248 * 400);
                        SimpleFillCheck fc4(&cross_ask2, 400, 1248 * 400);
                        BOOST_CHECK(add_and_verify(order_book, &cross_ask2, true, true));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1246, 2, 1100));
                      BOOST_CHECK(dc.verify_bid(1245, 3,  500));
                      BOOST_CHECK(dc.verify_bid(1244, 2, 1000));
                      BOOST_CHECK(dc.verify_bid(1242, 1,  300));
                      BOOST_CHECK(dc.verify_bid(1241, 1,  400)); // Restored
                      BOOST_CHECK(dc.verify_ask(1249, 1,  300));
                      BOOST_CHECK(dc.verify_ask(1250, 1,  500));
                      BOOST_CHECK(dc.verify_ask(1251, 1,  400));
                      BOOST_CHECK(dc.verify_ask(1252, 2,  300));
                      BOOST_CHECK(dc.verify_ask(1254, 1,  300));
                    
                      // Fill the top bid level (erase) and add ask level (insert),
                      //    but nothing to restore
                      SimpleOrder cross_ask3(false,  1246, 2400);
                      {
                        SimpleFillCheck fc1(&bid4,        600, 1246 * 600);
                        SimpleFillCheck fc2(&bid5,        500, 1246 * 500);
                        SimpleFillCheck fc3(&cross_ask3, 1100, 1246 * 1100);
                        BOOST_CHECK(add_and_verify(order_book, &cross_ask3, true, false));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1245, 3,  500));
                      BOOST_CHECK(dc.verify_bid(1244, 2, 1000));
                      BOOST_CHECK(dc.verify_bid(1242, 1,  300));
                      BOOST_CHECK(dc.verify_bid(1241, 1,  400));
                      BOOST_CHECK(dc.verify_bid(   0, 0,    0)); // Nothing to restore
                      BOOST_CHECK(dc.verify_ask(1246, 1, 1300));
                      BOOST_CHECK(dc.verify_ask(1249, 1,  300));
                      BOOST_CHECK(dc.verify_ask(1250, 1,  500));
                      BOOST_CHECK(dc.verify_ask(1251, 1,  400));
                      BOOST_CHECK(dc.verify_ask(1252, 2,  300));
                    
                      // Partial fill the top bid level (reduce) 
                      SimpleOrder cross_ask4(false,  1245, 250);
                      {
                        SimpleFillCheck fc1(&bid6,        200, 1245 * 200);
                        SimpleFillCheck fc2(&bid7,         50, 1245 *  50);
                        SimpleFillCheck fc3(&cross_ask4,  250, 1245 * 250);
                        BOOST_CHECK(add_and_verify(order_book, &cross_ask4, true, true));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1245, 2,  250)); // 1 filled, 1 reduced
                      BOOST_CHECK(dc.verify_bid(1244, 2, 1000));
                      BOOST_CHECK(dc.verify_bid(1242, 1,  300));
                      BOOST_CHECK(dc.verify_bid(1241, 1,  400));
                      BOOST_CHECK(dc.verify_bid(   0, 0,    0));
                      BOOST_CHECK(dc.verify_ask(1246, 1, 1300));
                      BOOST_CHECK(dc.verify_ask(1249, 1,  300));
                      BOOST_CHECK(dc.verify_ask(1250, 1,  500));
                      BOOST_CHECK(dc.verify_ask(1251, 1,  400));
                      BOOST_CHECK(dc.verify_ask(1252, 2,  300));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestFillCompleteAskRestoreDepth)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask10(false, 1258, 600);
                      SimpleOrder ask9(false,  1257, 700);
                      SimpleOrder ask8(false,  1256, 100);
                      SimpleOrder ask7(false,  1256, 100);
                      SimpleOrder ask6(false,  1255, 500);
                      SimpleOrder ask5(false,  1255, 200);
                      SimpleOrder ask4(false,  1254, 300);
                      SimpleOrder ask3(false,  1252, 200);
                      SimpleOrder ask2(false,  1252, 100);
                      SimpleOrder ask1(false,  1251, 400);
                      SimpleOrder ask0(false,  1250, 500);
                    
                      SimpleOrder bid0(true,   1249, 100);
                      SimpleOrder bid1(true,   1249, 200);
                      SimpleOrder bid2(true,   1249, 200);
                      SimpleOrder bid3(true,   1248, 400);
                      SimpleOrder bid4(true,   1246, 600);
                      SimpleOrder bid5(true,   1246, 500);
                      SimpleOrder bid6(true,   1245, 200);
                      SimpleOrder bid7(true,   1245, 100);
                      SimpleOrder bid8(true,   1245, 200);
                      SimpleOrder bid9(true,   1244, 700);
                      SimpleOrder bid10(true,  1244, 300);
                      SimpleOrder bid11(true,  1242, 300);
                      SimpleOrder bid12(true,  1241, 400);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &ask0,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask2,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask3,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask4,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask5,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask6,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask7,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask8,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask9,  false));
                      BOOST_CHECK(add_and_verify(order_book, &ask10, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid0,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid2,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid3,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid4,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid5,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid6,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid7,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid8,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid9,  false));
                      BOOST_CHECK(add_and_verify(order_book, &bid10, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid11, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid12, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(13, order_book.bids().size());
                      BOOST_CHECK_EQUAL(11, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1249, 3,  500));
                      BOOST_CHECK(dc.verify_bid(1248, 1,  400));
                      BOOST_CHECK(dc.verify_bid(1246, 2, 1100));
                      BOOST_CHECK(dc.verify_bid(1245, 3,  500));
                      BOOST_CHECK(dc.verify_bid(1244, 2, 1000));
                      BOOST_CHECK(dc.verify_ask(1250, 1,  500));
                      BOOST_CHECK(dc.verify_ask(1251, 1,  400));
                      BOOST_CHECK(dc.verify_ask(1252, 2,  300));
                      BOOST_CHECK(dc.verify_ask(1254, 1,  300));
                      BOOST_CHECK(dc.verify_ask(1255, 2,  700));
                    
                      // Fill the top ask level (erase) and add a bid level (insert)
                      SimpleOrder cross_bid(true,  1250, 800);
                      {
                        SimpleFillCheck fc1(&ask0,      500, 1250 * 500);
                        SimpleFillCheck fc4(&cross_bid, 500, 1250 * 500);
                        BOOST_CHECK(add_and_verify(order_book, &cross_bid, true, false));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1250, 1,  300));
                      BOOST_CHECK(dc.verify_bid(1249, 3,  500));
                      BOOST_CHECK(dc.verify_bid(1248, 1,  400));
                      BOOST_CHECK(dc.verify_bid(1246, 2, 1100));
                      BOOST_CHECK(dc.verify_bid(1245, 3,  500));
                      BOOST_CHECK(dc.verify_ask(1251, 1,  400));
                      BOOST_CHECK(dc.verify_ask(1252, 2,  300));
                      BOOST_CHECK(dc.verify_ask(1254, 1,  300));
                      BOOST_CHECK(dc.verify_ask(1255, 2,  700));
                      BOOST_CHECK(dc.verify_ask(1256, 2,  200)); // Restored
                    
                      // Fill the top ask level (erase) but do not add an bid level (no insert)
                      SimpleOrder cross_bid2(true,  1251, 400);
                      {
                        SimpleFillCheck fc1(&ask1,       400, 1251 * 400);
                        SimpleFillCheck fc4(&cross_bid2, 400, 1251 * 400);
                        BOOST_CHECK(add_and_verify(order_book, &cross_bid2, true, true));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1250, 1,  300));
                      BOOST_CHECK(dc.verify_bid(1249, 3,  500));
                      BOOST_CHECK(dc.verify_bid(1248, 1,  400));
                      BOOST_CHECK(dc.verify_bid(1246, 2, 1100));
                      BOOST_CHECK(dc.verify_bid(1245, 3,  500));
                      BOOST_CHECK(dc.verify_ask(1252, 2,  300));
                      BOOST_CHECK(dc.verify_ask(1254, 1,  300));
                      BOOST_CHECK(dc.verify_ask(1255, 2,  700));
                      BOOST_CHECK(dc.verify_ask(1256, 2,  200));
                      BOOST_CHECK(dc.verify_ask(1257, 1,  700)); // Restored
                    
                      // Fill the top ask level (erase) and add bid level (insert),
                      //    but nothing to restore
                      SimpleOrder cross_bid3(true,  1252, 2400);
                      {
                        SimpleFillCheck fc1(&ask2,        100, 1252 * 100);
                        SimpleFillCheck fc2(&ask3,        200, 1252 * 200);
                        SimpleFillCheck fc3(&cross_bid3,  300, 1252 * 300);
                        BOOST_CHECK(add_and_verify(order_book, &cross_bid3, true, false));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1252, 1, 2100)); // Insert
                      BOOST_CHECK(dc.verify_bid(1250, 1,  300));
                      BOOST_CHECK(dc.verify_bid(1249, 3,  500));
                      BOOST_CHECK(dc.verify_bid(1248, 1,  400));
                      BOOST_CHECK(dc.verify_bid(1246, 2, 1100));
                      BOOST_CHECK(dc.verify_ask(1254, 1,  300));
                      BOOST_CHECK(dc.verify_ask(1255, 2,  700));
                      BOOST_CHECK(dc.verify_ask(1256, 2,  200));
                      BOOST_CHECK(dc.verify_ask(1257, 1,  700));
                      BOOST_CHECK(dc.verify_ask(1258, 1,  600)); // Restored
                    
                      // Fill the top ask level (erase) but nothing to restore
                      SimpleOrder cross_bid4(true,  1254, 300);
                      {
                        SimpleFillCheck fc2(&ask4,        300, 1254 * 300);
                        SimpleFillCheck fc3(&cross_bid4,  300, 1254 * 300);
                        BOOST_CHECK(add_and_verify(order_book, &cross_bid4, true, true));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1252, 1, 2100));
                      BOOST_CHECK(dc.verify_bid(1250, 1,  300));
                      BOOST_CHECK(dc.verify_bid(1249, 3,  500));
                      BOOST_CHECK(dc.verify_bid(1248, 1,  400));
                      BOOST_CHECK(dc.verify_bid(1246, 2, 1100));
                      BOOST_CHECK(dc.verify_ask(1255, 2,  700));
                      BOOST_CHECK(dc.verify_ask(1256, 2,  200));
                      BOOST_CHECK(dc.verify_ask(1257, 1,  700));
                      BOOST_CHECK(dc.verify_ask(1258, 1,  600));
                      BOOST_CHECK(dc.verify_ask(   0, 0,    0)); // Nothing to restore
                    
                      // Partial fill the top ask level (reduce) 
                      SimpleOrder cross_bid5(true,  1255, 550);
                      {
                        SimpleFillCheck fc1(&ask5,        200, 1255 * 200);
                        SimpleFillCheck fc2(&ask6,        350, 1255 * 350);
                        SimpleFillCheck fc3(&cross_bid5,  550, 1255 * 550);
                        BOOST_CHECK(add_and_verify(order_book, &cross_bid5, true, true));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1252, 1, 2100));
                      BOOST_CHECK(dc.verify_bid(1250, 1,  300));
                      BOOST_CHECK(dc.verify_bid(1249, 3,  500));
                      BOOST_CHECK(dc.verify_bid(1248, 1,  400));
                      BOOST_CHECK(dc.verify_bid(1246, 2, 1100));
                      BOOST_CHECK(dc.verify_ask(1255, 1,  150)); // 1 filled, 1 reduced
                      BOOST_CHECK(dc.verify_ask(1256, 2,  200));
                      BOOST_CHECK(dc.verify_ask(1257, 1,  700));
                      BOOST_CHECK(dc.verify_ask(1258, 1,  600));
                      BOOST_CHECK(dc.verify_ask(   0, 0,    0));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestReplaceSizeIncrease)
                    {
                      SimpleOrderBook order_book;
                      ChangedChecker cc(order_book.depth());
                      SimpleOrder ask0(false, 1252, 300);
                      SimpleOrder ask1(false, 1251, 200);
                      SimpleOrder bid0(true,  1250, 100);
                      SimpleOrder bid1(true,  1249, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1249, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 200));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 300));
                    
                      // Verify changed stamps
                      BOOST_CHECK(cc.verify_bid_changed(true, true, false, false, false));
                      BOOST_CHECK(cc.verify_ask_changed(true, true, false, false, false));
                      cc.reset();
                    
                      // Replace size
                      BOOST_CHECK(replace_and_verify(order_book, &bid0, 25));
                      BOOST_CHECK(replace_and_verify(order_book, &ask0, 50));
                    
                      // Verify changed stamps
                      BOOST_CHECK(cc.verify_bid_changed(true, false, false, false, false));
                      BOOST_CHECK(cc.verify_ask_changed(false, true, false, false, false));
                      cc.reset();
                    
                      // Verify orders
                      BOOST_CHECK_EQUAL(125, bid0.order_qty());
                      BOOST_CHECK_EQUAL(350, ask0.order_qty());
                      
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1250, 1, 125));
                      BOOST_CHECK(dc.verify_bid(1249, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 200));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 350));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestReplaceSizeDecrease)
                    {
                      SimpleOrderBook order_book;
                      ChangedChecker cc(order_book.depth());
                      SimpleOrder ask1(false, 1252, 200);
                      SimpleOrder ask0(false, 1252, 300);
                      SimpleOrder bid1(true,  1251, 100);
                      SimpleOrder bid0(true,  1250, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1251, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 2, 500));
                    
                      // Verify changed stamps
                      BOOST_CHECK(cc.verify_bid_changed(true, true,false, false, false));
                      BOOST_CHECK(cc.verify_ask_changed(true, false, false, false, false));
                      cc.reset();
                    
                      // Replace size
                      BOOST_CHECK(replace_and_verify(order_book, &bid0, -60));
                      BOOST_CHECK(replace_and_verify(order_book, &ask0, -150));
                    
                      // Verify orders
                      BOOST_CHECK_EQUAL(40, bid0.order_qty());
                      BOOST_CHECK_EQUAL(150, ask0.order_qty());
                      
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1251, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1250, 1,  40));
                      BOOST_CHECK(dc.verify_ask(1252, 2, 350));
                    
                      // Verify changed stamps
                      BOOST_CHECK(cc.verify_bid_changed(false, true, false, false, false));
                      BOOST_CHECK(cc.verify_ask_changed(true,false, false, false, false));
                      cc.reset();
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestReplaceSizeDecreaseCancel)
                    {
                      SimpleOrderBook order_book;
                      ChangedChecker cc(order_book.depth());
                      SimpleOrder ask1(false, 1252, 200);
                      SimpleOrder ask0(false, 1252, 300);
                      SimpleOrder bid1(true,  1251, 400);
                      SimpleOrder bid0(true,  1250, 100);
                      SimpleOrder bid2(true,  1249, 700);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid2, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_ask(1252, 2, 500));
                      BOOST_CHECK(dc.verify_bid(1251, 1, 400));
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1249, 1, 700));
                    
                      // Verify changed stamps
                      BOOST_CHECK(cc.verify_bid_changed(true, true, true, false, false));
                      BOOST_CHECK(cc.verify_ask_changed(true, false, false, false, false));
                      cc.reset();
                    
                      // Partial Fill existing book
                      SimpleOrder cross_bid(true,  1252, 125);
                      SimpleOrder cross_ask(false, 1251, 100);
                      
                      // Bid matching best ask
                      {
                        SimpleFillCheck fc1(&cross_bid, 125, 1252 * 125);
                        SimpleFillCheck fc2(&ask0,      125, 1252 * 125);
                        BOOST_CHECK(add_and_verify(order_book, &cross_bid, true, true));
                      }
                    
                      BOOST_CHECK(cc.verify_bid_changed(false, false, false, false, false));
                      BOOST_CHECK(cc.verify_ask_changed(true, false, false, false, false));
                      cc.reset();
                    
                      // Ask matching best bid
                      {
                        SimpleFillCheck fc1(&cross_ask, 100, 1251 * 100);
                        SimpleFillCheck fc2(&bid1,      100, 1251 * 100);
                        BOOST_CHECK(add_and_verify(order_book, &cross_ask, true, true));
                      }
                    
                      BOOST_CHECK(cc.verify_bid_changed(true, false, false, false, false));
                      BOOST_CHECK(cc.verify_ask_changed(false, false, false, false, false));
                    
                      // Verify quantity
                      BOOST_CHECK_EQUAL(175, ask0.open_qty());
                      BOOST_CHECK_EQUAL(300, bid1.open_qty());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1251, 1, 300));
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1249, 1, 700));
                      BOOST_CHECK(dc.verify_ask(1252, 2, 375));
                    
                      // Replace size - cancel
                      BOOST_CHECK(replace_and_verify(
                          order_book, &ask0, -175, PRICE_UNCHANGED, simple::os_cancelled)); 
                    
                      // Verify orders
                      BOOST_CHECK_EQUAL(125, ask0.order_qty());
                      BOOST_CHECK_EQUAL(0, ask0.open_qty());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1251, 1, 300));
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1249, 1, 700));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 200));
                    
                      // Replace size - reduce level
                      BOOST_CHECK(replace_and_verify(
                          order_book, &bid1, -100, PRICE_UNCHANGED, simple::os_accepted)); 
                    
                      // Verify orders
                      BOOST_CHECK_EQUAL(300, bid1.order_qty());
                      BOOST_CHECK_EQUAL(200, bid1.open_qty());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1251, 1, 200));
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1249, 1, 700));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 200));
                    
                      // Replace size - cancel and erase level
                      BOOST_CHECK(replace_and_verify(
                          order_book, &bid1, -200, PRICE_UNCHANGED, simple::os_cancelled)); 
                    
                      // Verify orders
                      BOOST_CHECK_EQUAL(100, bid1.order_qty());
                      BOOST_CHECK_EQUAL(0, bid1.open_qty());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1249, 1, 700));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 200));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestReplaceSizeDecreaseTooMuch)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask1(false, 1252, 200);
                      SimpleOrder ask0(false, 1252, 300);
                      SimpleOrder bid1(true,  1251, 100);
                      SimpleOrder bid0(true,  1250, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1251, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 2, 500));
                    
                      SimpleOrder cross_bid(true,  1252, 200);
                      // Partial fill existing order
                      {
                        SimpleFillCheck fc1(&cross_bid, 200, 1252 * 200);
                        SimpleFillCheck fc2(&ask0,      200, 1252 * 200);
                        BOOST_CHECK(add_and_verify(order_book, &cross_bid, true, true));
                      }
                    
                      // Verify open quantity
                      BOOST_CHECK_EQUAL(100, ask0.open_qty());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1251, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 2, 300));
                    
                      // Replace size - not enough left
                      BOOST_CHECK( ! order_book.replace(&ask0, -150, PRICE_UNCHANGED));
                    
                      // Verify change
                      BOOST_CHECK_EQUAL(simple::os_cancelled, ask0.state());
                      BOOST_CHECK_EQUAL(200U, ask0.order_qty());
                      BOOST_CHECK_EQUAL(0U, ask0.open_qty());
                    
                      // Verify depth unchanged
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1251, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 200));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestReplaceSizeIncreaseDecrease)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask1(false, 1252, 200);
                      SimpleOrder ask0(false, 1251, 300);
                      SimpleOrder bid1(true,  1251, 100);
                      SimpleOrder bid0(true,  1250, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1250, 1, 100));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 300));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 200));
                    
                      // Replace size
                      BOOST_CHECK(replace_and_verify(order_book, &ask0, 50));
                      BOOST_CHECK(replace_and_verify(order_book, &bid0, 25));
                    
                      BOOST_CHECK(replace_and_verify(order_book, &ask0, -100));
                      BOOST_CHECK(replace_and_verify(order_book, &bid0, 25));
                    
                      BOOST_CHECK(replace_and_verify(order_book, &ask0, 300));
                      BOOST_CHECK(replace_and_verify(order_book, &bid0, -75));
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1250, 1, 75));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 550));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 200));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestReplaceBidPriceChange)
                    {
                      SimpleOrderBook order_book;
                      ChangedChecker cc(order_book.depth());
                      SimpleOrder ask0(false, 1253, 300);
                      SimpleOrder ask1(false, 1252, 200);
                      SimpleOrder bid1(true,  1251, 140);
                      SimpleOrder bid0(true,  1250, 120);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1251, 1, 140));
                      BOOST_CHECK(dc.verify_bid(1250, 1, 120));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 200));
                      BOOST_CHECK(dc.verify_ask(1253, 1, 300));
                    
                      // Verify changed stamps
                      BOOST_CHECK(cc.verify_bid_changed(true, true, false, false, false));
                      BOOST_CHECK(cc.verify_ask_changed(true, true, false, false, false));
                      cc.reset();
                    
                      // Replace price increase 1250 -> 1251
                      BOOST_CHECK(replace_and_verify(order_book, &bid0, SIZE_UNCHANGED, 1251));
                    
                      // Verify price change in book
                      SimpleOrderBook::Bids::const_iterator bid = order_book.bids().begin();
                      BOOST_CHECK_EQUAL(1251, bid->first);
                      BOOST_CHECK_EQUAL(&bid1, bid->second.ptr());
                      BOOST_CHECK_EQUAL(1251, (++bid)->first);
                      BOOST_CHECK_EQUAL(&bid0, bid->second.ptr());
                      BOOST_CHECK(order_book.bids().end() == ++bid);
                    
                      // Verify order
                      BOOST_CHECK_EQUAL(1251, bid0.price());
                      BOOST_CHECK_EQUAL(120, bid0.order_qty());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1251, 2, 260));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 200));
                      BOOST_CHECK(dc.verify_ask(1253, 1, 300));
                    
                      // Verify changed stamps
                      BOOST_CHECK(cc.verify_bid_changed(true, true, false, false, false));
                      BOOST_CHECK(cc.verify_ask_changed(false, false, false, false, false));
                      cc.reset();
                    
                      // Replace price decrease 1251 -> 1250
                      BOOST_CHECK(replace_and_verify(order_book, &bid1, SIZE_UNCHANGED, 1250));
                    
                      // Verify price change in book
                      bid = order_book.bids().begin();
                      BOOST_CHECK_EQUAL(1251, bid->first);
                      BOOST_CHECK_EQUAL(&bid0, bid->second.ptr());
                      BOOST_CHECK_EQUAL(1250, (++bid)->first);
                      BOOST_CHECK_EQUAL(&bid1, bid->second.ptr());
                      BOOST_CHECK(order_book.bids().end() == ++bid);
                    
                      // Verify order
                      BOOST_CHECK_EQUAL(1250, bid1.price());
                      BOOST_CHECK_EQUAL(140, bid1.order_qty());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1251, 1, 120));
                      BOOST_CHECK(dc.verify_bid(1250, 1, 140));
                      BOOST_CHECK(dc.verify_bid(   0, 0,   0));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 200));
                      BOOST_CHECK(dc.verify_ask(1253, 1, 300));
                    
                      // Verify changed stamps
                      BOOST_CHECK(cc.verify_bid_changed(true, true, false, false, false));
                      BOOST_CHECK(cc.verify_ask_changed(false, false, false, false, false));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestReplaceAskPriceChange)
                    {
                      SimpleOrderBook order_book;
                      ChangedChecker cc(order_book.depth());
                    
                      SimpleOrder ask0(false, 1253, 300);
                      SimpleOrder ask1(false, 1252, 200);
                      SimpleOrder bid1(true,  1251, 140);
                      SimpleOrder bid0(true,  1250, 120);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                    
                      // Verify changed stamps
                      BOOST_CHECK(cc.verify_bid_changed(true, true, false, false, false));
                      BOOST_CHECK(cc.verify_ask_changed(true, true, false, false, false));
                      cc.reset();
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1251, 1, 140));
                      BOOST_CHECK(dc.verify_bid(1250, 1, 120));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 200));
                      BOOST_CHECK(dc.verify_ask(1253, 1, 300));
                    
                      // Replace price increase 1252 -> 1253
                      BOOST_CHECK(replace_and_verify(order_book, &ask1, SIZE_UNCHANGED, 1253));
                    
                      // Verify changed stamps
                      BOOST_CHECK(cc.verify_bid_changed(false, false, false, false, false));
                      BOOST_CHECK(cc.verify_ask_changed(true, true, false, false, false));
                      cc.reset();
                    
                      // Verify price change in book
                      SimpleOrderBook::Asks::const_iterator ask = order_book.asks().begin();
                      BOOST_CHECK_EQUAL(1253, ask->first);
                      BOOST_CHECK_EQUAL(&ask0, ask->second.ptr());
                      BOOST_CHECK_EQUAL(1253, (++ask)->first);
                      BOOST_CHECK_EQUAL(&ask1, ask->second.ptr());
                      BOOST_CHECK(order_book.asks().end() == ++ask);
                    
                      // Verify order
                      BOOST_CHECK_EQUAL(1253, ask1.price());
                      BOOST_CHECK_EQUAL(200, ask1.order_qty());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1251, 1, 140));
                      BOOST_CHECK(dc.verify_bid(1250, 1, 120));
                      BOOST_CHECK(dc.verify_ask(1253, 2, 500));
                    
                      // Replace price decrease 1253 -> 1252
                      BOOST_CHECK(replace_and_verify(order_book, &ask0, SIZE_UNCHANGED, 1252));
                    
                      // Verify price change in book
                      ask = order_book.asks().begin();
                      BOOST_CHECK_EQUAL(1252, ask->first);
                      BOOST_CHECK_EQUAL(&ask0, ask->second.ptr());
                      BOOST_CHECK_EQUAL(1253, (++ask)->first);
                      BOOST_CHECK_EQUAL(&ask1, ask->second.ptr());
                      BOOST_CHECK(order_book.asks().end() == ++ask);
                    
                      // Verify order
                      BOOST_CHECK_EQUAL(1252, ask0.price());
                      BOOST_CHECK_EQUAL(300, ask0.order_qty());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1251, 1, 140));
                      BOOST_CHECK(dc.verify_bid(1250, 1, 120));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 300));
                      BOOST_CHECK(dc.verify_ask(1253, 1, 200));
                      BOOST_CHECK(dc.verify_ask(   0, 0,   0));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestReplaceBidPriceChangeErase)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask0(false, 1253, 300);
                      SimpleOrder ask1(false, 1252, 200);
                      SimpleOrder bid1(true,  1251, 140);
                      SimpleOrder bid0(true,  1250, 120);
                      SimpleOrder bid2(true,  1249, 100);
                      SimpleOrder bid3(true,  1248, 200);
                      SimpleOrder bid4(true,  1247, 400);
                      SimpleOrder bid5(true,  1246, 800);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid2, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid3, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid4, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid5, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1251, 1, 140));
                      BOOST_CHECK(dc.verify_bid(1250, 1, 120));
                      BOOST_CHECK(dc.verify_bid(1249, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1248, 1, 200));
                      BOOST_CHECK(dc.verify_bid(1247, 1, 400));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 200));
                      BOOST_CHECK(dc.verify_ask(1253, 1, 300));
                    
                      // Replace price increase 1250 -> 1251
                      BOOST_CHECK(replace_and_verify(order_book, &bid0, SIZE_UNCHANGED, 1251));
                    
                      // Verify price change in book
                      SimpleOrderBook::Bids::const_iterator bid = order_book.bids().begin();
                      BOOST_CHECK_EQUAL(1251, bid->first);
                      BOOST_CHECK_EQUAL(&bid1, bid->second.ptr());
                      BOOST_CHECK_EQUAL(1251, (++bid)->first);
                      BOOST_CHECK_EQUAL(&bid0, bid->second.ptr());
                      BOOST_CHECK_EQUAL(1249, (++bid)->first);
                      BOOST_CHECK_EQUAL(&bid2, bid->second.ptr());
                    
                      // Verify order
                      BOOST_CHECK_EQUAL(1251, bid0.price());
                      BOOST_CHECK_EQUAL(120, bid0.order_qty());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1251, 2, 260));
                      BOOST_CHECK(dc.verify_bid(1249, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1248, 1, 200));
                      BOOST_CHECK(dc.verify_bid(1247, 1, 400));
                      BOOST_CHECK(dc.verify_bid(1246, 1, 800));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 200));
                      BOOST_CHECK(dc.verify_ask(1253, 1, 300));
                    
                      // Replace price decrease 1251 -> 1250
                      BOOST_CHECK(replace_and_verify(order_book, &bid1, SIZE_UNCHANGED, 1250));
                    
                      // Verify price change in book
                      bid = order_book.bids().begin();
                      BOOST_CHECK_EQUAL(1251, bid->first);
                      BOOST_CHECK_EQUAL(&bid0, bid->second.ptr());
                      BOOST_CHECK_EQUAL(1250, (++bid)->first);
                      BOOST_CHECK_EQUAL(&bid1, bid->second.ptr());
                      BOOST_CHECK_EQUAL(1249, (++bid)->first);
                      BOOST_CHECK_EQUAL(&bid2, bid->second.ptr());
                    
                      // Verify order
                      BOOST_CHECK_EQUAL(1250, bid1.price());
                      BOOST_CHECK_EQUAL(140, bid1.order_qty());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1251, 1, 120));
                      BOOST_CHECK(dc.verify_bid(1250, 1, 140));
                      BOOST_CHECK(dc.verify_bid(1249, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1248, 1, 200));
                      BOOST_CHECK(dc.verify_bid(1247, 1, 400));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 200));
                      BOOST_CHECK(dc.verify_ask(1253, 1, 300));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestReplaceAskPriceChangeErase)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask5(false, 1258, 304);
                      SimpleOrder ask4(false, 1256, 330);
                      SimpleOrder ask3(false, 1255, 302);
                      SimpleOrder ask2(false, 1254, 310);
                      SimpleOrder ask0(false, 1253, 300);
                      SimpleOrder ask1(false, 1252, 200);
                      SimpleOrder bid1(true,  1251, 140);
                      SimpleOrder bid0(true,  1250, 120);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask2, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask3, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask4, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask5, false));
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1251, 1, 140));
                      BOOST_CHECK(dc.verify_bid(1250, 1, 120));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 200));
                      BOOST_CHECK(dc.verify_ask(1253, 1, 300));
                      BOOST_CHECK(dc.verify_ask(1254, 1, 310));
                      BOOST_CHECK(dc.verify_ask(1255, 1, 302));
                      BOOST_CHECK(dc.verify_ask(1256, 1, 330));
                    
                      // Replace price increase 1252 -> 1253
                      BOOST_CHECK(replace_and_verify(order_book, &ask1, SIZE_UNCHANGED, 1253));
                    
                      // Verify price change in book
                      SimpleOrderBook::Asks::const_iterator ask = order_book.asks().begin();
                      BOOST_CHECK_EQUAL(1253, ask->first);
                      BOOST_CHECK_EQUAL(&ask0, ask->second.ptr());
                      BOOST_CHECK_EQUAL(1253, (++ask)->first);
                      BOOST_CHECK_EQUAL(&ask1, ask->second.ptr());
                      BOOST_CHECK_EQUAL(1254, (++ask)->first);
                      BOOST_CHECK_EQUAL(&ask2, ask->second.ptr());
                    
                      // Verify order
                      BOOST_CHECK_EQUAL(1253, ask1.price());
                      BOOST_CHECK_EQUAL(200, ask1.order_qty());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1251, 1, 140));
                      BOOST_CHECK(dc.verify_bid(1250, 1, 120));
                      BOOST_CHECK(dc.verify_ask(1253, 2, 500));
                      BOOST_CHECK(dc.verify_ask(1254, 1, 310));
                      BOOST_CHECK(dc.verify_ask(1255, 1, 302));
                      BOOST_CHECK(dc.verify_ask(1256, 1, 330));
                      BOOST_CHECK(dc.verify_ask(1258, 1, 304));
                    
                      // Replace price decrease 1253 -> 1252
                      BOOST_CHECK(replace_and_verify(order_book, &ask0, SIZE_UNCHANGED, 1252));
                    
                      // Verify price change in book
                      ask = order_book.asks().begin();
                      BOOST_CHECK_EQUAL(1252, ask->first);
                      BOOST_CHECK_EQUAL(&ask0, ask->second.ptr());
                      BOOST_CHECK_EQUAL(1253, (++ask)->first);
                      BOOST_CHECK_EQUAL(&ask1, ask->second.ptr());
                      BOOST_CHECK_EQUAL(1254, (++ask)->first);
                      BOOST_CHECK_EQUAL(&ask2, ask->second.ptr());
                    
                      // Verify order
                      BOOST_CHECK_EQUAL(1252, ask0.price());
                      BOOST_CHECK_EQUAL(300, ask0.order_qty());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1251, 1, 140));
                      BOOST_CHECK(dc.verify_bid(1250, 1, 120));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 300));
                      BOOST_CHECK(dc.verify_ask(1253, 1, 200));
                      BOOST_CHECK(dc.verify_ask(1254, 1, 310));
                      BOOST_CHECK(dc.verify_ask(1255, 1, 302));
                      BOOST_CHECK(dc.verify_ask(1256, 1, 330));
                    }
                    
                    // A potential problem
                    // When restroing a level into the depth, the orders (and thus the restored
                    // level already reflect the post-fill quantity, but the fill callback has 
                    // yet to be processed.  As such, a multilevel fill can have fills at the 
                    // restoration price double-counted
                    // but the 
                    BOOST_AUTO_TEST_CASE(TestBidMultiLevelFillRestore)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask1(false, 0, 1300);
                      SimpleOrder ask0(false, 1252, 100);
                      SimpleOrder bid0(true,  1251, 200);
                      SimpleOrder bid1(true,  1250, 200);
                      SimpleOrder bid2(true,  1250, 200);
                      SimpleOrder bid3(true,  1248, 200);
                      SimpleOrder bid4(true,  1247, 200);
                      SimpleOrder bid5(true,  1246, 200);
                      SimpleOrder bid6(true,  1245, 200); // Partial match
                      SimpleOrder bid7(true,  1244, 200);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid2, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid3, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid4, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid5, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid6, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid7, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(8, order_book.bids().size());
                      BOOST_CHECK_EQUAL(1, order_book.asks().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1251, 1, 200));
                      BOOST_CHECK(dc.verify_bid(1250, 2, 400));
                      BOOST_CHECK(dc.verify_bid(1248, 1, 200));
                      BOOST_CHECK(dc.verify_bid(1247, 1, 200));
                      BOOST_CHECK(dc.verify_bid(1246, 1, 200));
                    
                      // Match - complete
                      {
                        SimpleFillCheck fc0(&bid0,  200,  250200);
                        SimpleFillCheck fc1(&bid1,  200,  250000);
                        SimpleFillCheck fc2(&bid2,  200,  250000);
                        SimpleFillCheck fc3(&bid3,  200,  249600);
                        SimpleFillCheck fc4(&bid4,  200,  249400);
                        SimpleFillCheck fc5(&bid5,  200,  249200);
                        SimpleFillCheck fc6(&bid6,  100,  124500);
                        SimpleFillCheck fc7(&ask1, 1300, 1622900);
                        BOOST_CHECK(add_and_verify(order_book, &ask1, true, true));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_ask(1252, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1245, 1, 100));
                      BOOST_CHECK(dc.verify_bid(1244, 1, 200));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestAskMultiLevelFillRestore)
                    {
                      SimpleOrderBook order_book;
                      SimpleOrder ask0(false,  1251, 200); // Partial match
                      SimpleOrder ask1(false,  1250, 200);
                      SimpleOrder ask2(false,  1250, 300);
                      SimpleOrder ask3(false,  1248, 200);
                      SimpleOrder ask4(false,  1247, 200);
                      SimpleOrder ask5(false,  1245, 200);
                      SimpleOrder ask6(false,  1245, 200);
                      SimpleOrder ask7(false,  1244, 200);
                      SimpleOrder bid1(true, 0, 1550);
                      SimpleOrder bid0(true, 1242, 100);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask2, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask3, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask4, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask5, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask6, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask7, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                    
                      // Verify sizes
                      BOOST_CHECK_EQUAL(8, order_book.asks().size());
                      BOOST_CHECK_EQUAL(1, order_book.bids().size());
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_ask(1244, 1, 200));
                      BOOST_CHECK(dc.verify_ask(1245, 2, 400));
                      BOOST_CHECK(dc.verify_ask(1247, 1, 200));
                      BOOST_CHECK(dc.verify_ask(1248, 1, 200));
                      BOOST_CHECK(dc.verify_ask(1250, 2, 500));
                      BOOST_CHECK(dc.verify_bid(1242, 1, 100));
                    
                      // Match - complete
                      {
                        SimpleFillCheck fc7(&ask7,  200,  248800);
                        SimpleFillCheck fc6(&ask6,  200,  249000);
                        SimpleFillCheck fc5(&ask5,  200,  249000);
                        SimpleFillCheck fc4(&ask4,  200,  249400);
                        SimpleFillCheck fc3(&ask3,  200,  249600);
                        SimpleFillCheck fc2(&ask2,  300,  375000);
                        SimpleFillCheck fc1(&ask1,  200,  250000);
                        SimpleFillCheck fc0(&ask0,   50,   62550);
                        SimpleFillCheck fc8(&bid1, 1550, 1933350);
                        BOOST_CHECK(add_and_verify(order_book, &bid1, true, true));
                      }
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_ask(1251, 1, 150));
                      BOOST_CHECK(dc.verify_bid(1242, 1, 100));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestReplaceBidMatch)
                    {
                      SimpleOrderBook order_book;
                      ChangedChecker cc(order_book.depth());
                      SimpleOrder ask1(false, 1254, 200);
                      SimpleOrder ask0(false, 1253, 300);
                      SimpleOrder bid1(true,  1251, 140);
                      SimpleOrder bid0(true,  1250, 120);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1251, 1, 140));
                      BOOST_CHECK(dc.verify_bid(1250, 1, 120));
                      BOOST_CHECK(dc.verify_ask(1253, 1, 300));
                      BOOST_CHECK(dc.verify_ask(1254, 1, 200));
                    
                      // Verify changed stamps
                      BOOST_CHECK(cc.verify_bid_changed(true, true, false, false, false));
                      BOOST_CHECK(cc.verify_ask_changed(true, true, false, false, false));
                      cc.reset();
                    
                      // Replace price increase new best 1250 -> 1252
                      BOOST_CHECK(replace_and_verify(order_book, &bid0, SIZE_UNCHANGED, 1252));
                    
                      // Verify price change in book
                      SimpleOrderBook::Bids::const_iterator bid = order_book.bids().begin();
                      BOOST_CHECK_EQUAL(1252, bid->first);
                      BOOST_CHECK_EQUAL(&bid0, bid->second.ptr());
                      BOOST_CHECK_EQUAL(1251, (++bid)->first);
                      BOOST_CHECK_EQUAL(&bid1, bid->second.ptr());
                      BOOST_CHECK(order_book.bids().end() == ++bid);
                    
                      // Verify order
                      BOOST_CHECK_EQUAL(1252, bid0.price());
                      BOOST_CHECK_EQUAL(120, bid0.order_qty());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1252, 1, 120));
                      BOOST_CHECK(dc.verify_bid(1251, 1, 140));
                      BOOST_CHECK(dc.verify_ask(1253, 1, 300));
                      BOOST_CHECK(dc.verify_ask(1254, 1, 200));
                    
                      // Verify changed stamps
                      BOOST_CHECK(cc.verify_bid_changed(true, true, true, false, false));
                      BOOST_CHECK(cc.verify_ask_changed(false, false, false, false, false));
                      cc.reset();
                    
                      // Match - complete
                      {
                        SimpleFillCheck fc0(&ask0,  140, 140 * 1253);
                        SimpleFillCheck fc1(&bid1,  140, 140 * 1253);
                        // Replace price increase match 1251 -> 1253
                        BOOST_CHECK(replace_and_verify(order_book, &bid1, SIZE_UNCHANGED, 1253,
                                      simple::os_complete, 140));
                      }
                    
                      // Verify price change in book
                      bid = order_book.bids().begin();
                      BOOST_CHECK_EQUAL(1252, bid->first);
                      BOOST_CHECK_EQUAL(&bid0, bid->second.ptr());
                      BOOST_CHECK(order_book.bids().end() == ++bid);
                    
                      // Verify order
                      BOOST_CHECK_EQUAL(1253, bid1.price());
                      BOOST_CHECK_EQUAL(140, bid1.order_qty());
                      BOOST_CHECK_EQUAL(0, bid1.open_qty());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1252, 1, 120));
                      BOOST_CHECK(dc.verify_bid(   0, 0,   0));
                      BOOST_CHECK(dc.verify_ask(1253, 1, 160));
                      BOOST_CHECK(dc.verify_ask(1254, 1, 200));
                    
                      // Verify changed stamps
                      BOOST_CHECK(cc.verify_bid_changed(true, true, true, false, false));
                      BOOST_CHECK(cc.verify_ask_changed(true, false, false, false, false));
                    }
                    
                    BOOST_AUTO_TEST_CASE(TestReplaceAskMatch)
                    {
                      SimpleOrderBook order_book;
                      ChangedChecker cc(order_book.depth());
                      SimpleOrder ask1(false, 1254, 200);
                      SimpleOrder ask0(false, 1253, 300);
                      SimpleOrder bid1(true,  1251, 140);
                      SimpleOrder bid0(true,  1250, 120);
                    
                      // No match
                      BOOST_CHECK(add_and_verify(order_book, &bid0, false));
                      BOOST_CHECK(add_and_verify(order_book, &bid1, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask0, false));
                      BOOST_CHECK(add_and_verify(order_book, &ask1, false));
                    
                      // Verify depth
                      DepthCheck<SimpleOrderBook> dc(order_book.depth());
                      BOOST_CHECK(dc.verify_bid(1251, 1, 140));
                      BOOST_CHECK(dc.verify_bid(1250, 1, 120));
                      BOOST_CHECK(dc.verify_ask(1253, 1, 300));
                      BOOST_CHECK(dc.verify_ask(1254, 1, 200));
                    
                      // Verify changed stamps
                      BOOST_CHECK(cc.verify_bid_changed(true, true, false, false, false));
                      BOOST_CHECK(cc.verify_ask_changed(true, true, false, false, false));
                      cc.reset();
                    
                      // Replace price decrease new best 1254 -> 1252
                      BOOST_CHECK(replace_and_verify(order_book, &ask1, SIZE_UNCHANGED, 1252));
                    
                      // Verify price change in book
                      SimpleOrderBook::Asks::const_iterator ask = order_book.asks().begin();
                      BOOST_CHECK_EQUAL(1252, ask->first);
                      BOOST_CHECK_EQUAL(&ask1, ask->second.ptr());
                      BOOST_CHECK_EQUAL(1253, (++ask)->first);
                      BOOST_CHECK_EQUAL(&ask0, ask->second.ptr());
                      BOOST_CHECK(order_book.asks().end() == ++ask);
                    
                      // Verify order
                      BOOST_CHECK_EQUAL(1252, ask1.price());
                      BOOST_CHECK_EQUAL(200, ask1.order_qty());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1251, 1, 140));
                      BOOST_CHECK(dc.verify_bid(1250, 1, 120));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 200));
                      BOOST_CHECK(dc.verify_ask(1253, 1, 300));
                    
                      // Verify changed stamps
                      BOOST_CHECK(cc.verify_bid_changed(false, false, false, false, false));
                      BOOST_CHECK(cc.verify_ask_changed(true, true, true, false, false));
                      cc.reset();
                    
                      // Match - complete
                      {
                        SimpleFillCheck fc0(&ask0,  140, 140 * 1251);
                        SimpleFillCheck fc1(&bid1,  140, 140 * 1251);
                        // Replace price decrease match 1253 -> 1251
                        BOOST_CHECK(replace_and_verify(order_book, &ask0, SIZE_UNCHANGED, 1251,
                                      simple::os_accepted, 140));
                      }
                    
                      // Verify price change in book
                      ask = order_book.asks().begin();
                      BOOST_CHECK_EQUAL(1251, ask->first);
                      BOOST_CHECK_EQUAL(&ask0, ask->second.ptr());
                      BOOST_CHECK_EQUAL(1252, (++ask)->first);
                      BOOST_CHECK_EQUAL(&ask1, ask->second.ptr());
                      BOOST_CHECK(order_book.asks().end() == ++ask);
                    
                      // Verify order
                      BOOST_CHECK_EQUAL(1251, ask0.price());
                      BOOST_CHECK_EQUAL(300, ask0.order_qty());
                      BOOST_CHECK_EQUAL(160, ask0.open_qty());
                    
                      // Verify depth
                      dc.reset();
                      BOOST_CHECK(dc.verify_bid(1250, 1, 120));
                      BOOST_CHECK(dc.verify_bid(   0, 0,   0));
                      BOOST_CHECK(dc.verify_ask(1251, 1, 160));
                      BOOST_CHECK(dc.verify_ask(1252, 1, 200));
                    
                      // Verify changed stamps
                      BOOST_CHECK(cc.verify_bid_changed(true, true, false, false, false));
                      BOOST_CHECK(cc.verify_ask_changed(true, true, true, false, false));
                    }
                    
                    } // namespace
                </[ut_order_book.cpp]>
            </external/liquibook/test/unit>
            <external/liquibook/test/latency>
                <[lt_order_book.cpp]>
                    // Copyright (c) 2012, 2013 Object Computing, Inc.
                    // All rights reserved.
                    // See the file license.txt for licensing information.
                    #include <simple/simple_order_book.h>
                    #include <book/types.h>
                    #include "clock_gettime.h"
                    
                    #include <iostream>
                    #include <stdexcept>
                    #include <stdlib.h>
                    
                    using namespace liquibook;
                    using namespace liquibook::book;
                    
                    typedef simple::SimpleOrderBook<5> FullDepthOrderBook;
                    typedef simple::SimpleOrderBook<1> BboOrderBook;
                    typedef book::OrderBook<simple::SimpleOrder*> NoDepthOrderBook;
                    
                    void build_histogram(timespec* timestamps, int count) {
                      timespec* prev = nullptr;
                      std::cout << "Latency (ns) " << std::endl;
                    
                      for (timespec* timestamp = timestamps;
                           (timestamp - timestamps) <= count;
                           ++timestamp)
                      {
                        if (prev) {
                          timespec elapsed;
                          if (timestamp->tv_sec == prev->tv_sec) {
                            elapsed.tv_sec = 0;
                            elapsed.tv_nsec = timestamp->tv_nsec - prev->tv_nsec;
                          } else {
                            // Second changed
                            elapsed.tv_sec = timestamp->tv_sec - prev->tv_sec;
                            // Borrow from sec if necessary
                            if (prev->tv_nsec > timestamp->tv_nsec) {
                              --elapsed.tv_sec;
                              elapsed.tv_nsec = 1000000000 + timestamp->tv_nsec - prev->tv_nsec;
                            } else {
                              elapsed.tv_nsec = timestamp->tv_nsec - prev->tv_nsec;
                            }
                          }
                          if (elapsed.tv_sec) {
                            std::cout << elapsed.tv_sec * 1000000000 + elapsed.tv_nsec << std::endl;
                          } else {
                            std::cout << elapsed.tv_nsec << std::endl;
                          }
                        }
                        prev = timestamp;
                      }
                    }
                    
                    template <class TypedOrderBook, class TypedOrder>
                    int run_test(TypedOrderBook& order_book, TypedOrder** orders,
                                 timespec* timestamps) {
                      int count = 0;
                      TypedOrder** pp_order = orders;
                      timespec* timestamp = timestamps;
                      do {
                        // Take timestamp at start of each order
                        int status = clock_gettime(CLOCK_REALTIME, timestamp);
                        if (status) {
                          throw std::runtime_error("clock_gettime() failed");
                        }
                        order_book.add(*pp_order);
                        ++pp_order;
                        ++timestamp;
                        if (*pp_order == nullptr) {
                          break;
                        }
                        ++count;
                      } while (true);
                      // Take timestamp at end
                      int status = clock_gettime(CLOCK_REALTIME, timestamp);
                      if (status) {
                        throw std::runtime_error("clock_gettime() failed");
                      }
                      return int(pp_order - orders);
                    }
                    
                    template <class TypedOrderBook>
                    bool build_and_run_test(uint32_t num_to_try, bool dry_run = false) {
                      TypedOrderBook order_book;
                      simple::SimpleOrder** orders = new simple::SimpleOrder*[num_to_try + 1];
                      timespec* timestamps = new timespec[num_to_try + 1];
                      
                      for (uint32_t i = 0; i < num_to_try; ++i) {
                        bool is_buy((i % 2) == 0);
                        uint32_t delta = is_buy ? 1880 : 1884;
                        // AsSK 1893
                        // ASK 1892
                        // ASK 1891
                        // ASK 1890
                        // ASK 1889 crossable
                        // ASK 1888 crossable
                        // ASK 1887 crossable
                        // ASK 1886 crossable
                        // ASK 1885 crossable
                        // ASK 1884 crossable
                    
                        // BID 1889 crossable
                        // BID 1888 crossable
                        // BID 1887 crossable
                        // BID 1886 crossable
                        // BID 1885 crossable
                        // BID 1884 crossable
                        // BID 1883
                        // BID 1882
                        // BID 1881
                        // BID 1880
                    
                        Price price = (rand() % 10) + delta;
                        
                        Quantity qty = ((rand() % 10) + 1) * 100;
                        orders[i] = new simple::SimpleOrder(is_buy, price, qty);
                      }
                      orders[num_to_try] = nullptr; // Final null
                      
                      run_test(order_book, orders, timestamps);
                      for (uint32_t i = 0; i <= num_to_try; ++i) {
                        delete orders[i];
                      }
                      delete [] orders;
                      std::cout << " - complete!" << std::endl;
                      uint32_t remain = uint32_t(order_book.bids().size() + order_book.asks().size());
                      if (!dry_run) {
                        std::cout << "Building histogram" << std::endl;
                        build_histogram(timestamps, num_to_try);
                      }
                      delete [] timestamps;
                    
                      return true;
                    }
                    
                    int main(int argc, const char* argv[])
                    {
                      uint32_t num_to_try = 10000;
                      if (argc > 1) {
                        num_to_try = atoi(argv[1]);
                        if (!num_to_try) { 
                          num_to_try = 10000;
                        }
                      }
                      std::cout << num_to_try << " order latency test of order book" << std::endl;
                      srand(num_to_try);
                    
                      {
                        std::cout << "starting dry run" << std::endl;
                        build_and_run_test<FullDepthOrderBook>(num_to_try, true);
                      }
                    
                      {
                        std::cout << "testing order book with depth" << std::endl;
                        build_and_run_test<FullDepthOrderBook>(num_to_try);
                      }
                    
                      {
                        std::cout << "testing order book with bbo" << std::endl;
                        build_and_run_test<BboOrderBook>(num_to_try);
                      }
                    
                      {
                        std::cout << "testing order book without depth" << std::endl;
                        build_and_run_test<NoDepthOrderBook>(num_to_try);
                      }
                    }
                    
                </[lt_order_book.cpp]>
            </external/liquibook/test/latency>
<include>
    <[MBOParsed.hpp]>
        #pragma once
        #include <string>
        #include <cstdint>
        
        struct MBOParsed {
            std::string ts_event_str;
            uint8_t  rtype;
            uint16_t publisher_id;
            uint32_t instrument_id;
            char     action;
            char     side;
            double   price;
            uint32_t size;
            uint8_t  channel_id;
            uint64_t order_id;
            uint8_t  flags;
            int32_t  ts_in_delta;
            uint32_t sequence;
            std::string symbol;
            std::string datetime;
        };
    </[MBOParsed.hpp]>
    <[MBOSubscriber.hpp]>
        #pragma once
        
        #include <fastdds/dds/domain/DomainParticipant.hpp>
        #include <fastdds/dds/subscriber/Subscriber.hpp>
        #include <fastdds/dds/topic/Topic.hpp>
        #include <fastdds/dds/subscriber/DataReader.hpp>
        #include <fastdds/dds/subscriber/DataReaderListener.hpp>
        #include <fastdds/dds/core/status/SubscriptionMatchedStatus.hpp>
        #include <memory>
        #include "MBOParsed.hpp"
        #include "OrderBookManager.hpp"
        
        class MBOSubscriber : public eprosima::fastdds::dds::DataReaderListener {
        private:
            eprosima::fastdds::dds::DomainParticipant* participant;
            eprosima::fastdds::dds::Subscriber* subscriber;
            eprosima::fastdds::dds::Topic* topic;
            eprosima::fastdds::dds::DataReader* reader;
            eprosima::fastdds::dds::TypeSupport type;
            
            int matched_publishers;
            int samples_received;
            
            // OrderBook manager
            std::unique_ptr<OrderBookManager> orderbook_mgr_;
        
        public:
            MBOSubscriber();
            ~MBOSubscriber();
            
            bool init();
            void run();
            
            // DataReaderListener callbacks
            void on_data_available(eprosima::fastdds::dds::DataReader* reader) override;
            void on_subscription_matched(
                eprosima::fastdds::dds::DataReader* reader,
                const eprosima::fastdds::dds::SubscriptionMatchedStatus& info) override;
            
        private:
            MBOParsed parseCSVString(const std::string& csv_line);
            void printRecord(const MBOParsed& r);
        };
    </[MBOSubscriber.hpp]>
    <[OrderBookManager.hpp]>
        #pragma once
        
        #include <string>
        #include <unordered_map>
        #include <memory>
        #include <iostream>
        #include "MBOParsed.hpp"
        
        // Forward declarations for Liquibook
        namespace book {
            template <typename OrderPtr>
            class OrderBook;
            
            class Order;
            
            enum Side {
                BUY = 0,
                SELL = 1
            };
        }
        
        class OrderBookManager {
        private:
            // Liquibook orderbook instance
            book::OrderBook<book::Order*>* orderbook_;
            
            // Map external order_id to Liquibook Order pointer
            std::unordered_map<uint64_t, book::Order*> order_map_;
            
            // Track pending cancels for out-of-order messages
            std::unordered_map<uint64_t, MBOParsed> pending_cancels_;
            
        public:
            OrderBookManager();
            ~OrderBookManager();
            
            // Main entry point for processing MBO messages
            void processMessage(const MBOParsed& msg);
            
            // Print current book state to terminal
            void printBookState();
            
        private:
            // Action handlers
            void handleAdd(const MBOParsed& msg);
            void handleCancel(const MBOParsed& msg);
            void handleModify(const MBOParsed& msg);
            void handleTrade(const MBOParsed& msg);
            
            // Helper to find order
            book::Order* findOrder(uint64_t order_id);
            
            // Convert side character to Liquibook enum
            book::Side convertSide(char side);
            
            // Convert price to Liquibook format (scale if needed)
            uint64_t convertPrice(double price);
        };
    </[OrderBookManager.hpp]>
</include>
<src>
    <[main.cpp]>
        #include <iostream>
        #include "MBOSubscriber.hpp"
        
        int main() {
            std::cout << "=== MBO Order Book Subscriber ===" << std::endl;
            
            MBOSubscriber subscriber;
            
            if (!subscriber.init()) {
                std::cerr << "Failed to initialize subscriber" << std::endl;
                return 1;
            }
            
            std::cout << "Subscriber ready. Listening for MBO data..." << std::endl;
            
            try {
                subscriber.run();
            } catch (const std::exception& e) {
                std::cerr << "Error: " << e.what() << std::endl;
                return 1;
            }
            
            return 0;
        }
    </[main.cpp]>
    <[MBOSubscriber.cpp]>
        #include "MBOSubscriber.hpp"
        #include <fastdds/dds/domain/DomainParticipantFactory.hpp>
        #include <fastdds/dds/topic/TopicDataType.hpp>
        #include <iostream>
        #include <sstream>
        #include <iomanip>
        #include <thread>
        #include <chrono>
        
        // Simple string type for FastDDS (same as publisher)
        class StringType : public eprosima::fastdds::dds::TopicDataType {
        public:
            StringType() {
                setName("StringType");
                m_typeSize = 4096;
                m_isGetKeyDefined = false;
            }
        
            bool serialize(void* data, eprosima::fastrtps::rtps::SerializedPayload_t* payload) override {
                std::string* str = static_cast<std::string*>(data);
                payload->length = static_cast<uint32_t>(str->size());
                memcpy(payload->data, str->data(), str->size());
                return true;
            }
        
            bool deserialize(eprosima::fastrtps::rtps::SerializedPayload_t* payload, void* data) override {
                std::string* str = static_cast<std::string*>(data);
                str->assign(reinterpret_cast<char*>(payload->data), payload->length);
                return true;
            }
        
            std::function<uint32_t()> getSerializedSizeProvider(void* data) override {
                return [data]() -> uint32_t {
                    return static_cast<uint32_t>(static_cast<std::string*>(data)->size());
                };
            }
        
            void* createData() override {
                return new std::string();
            }
        
            void deleteData(void* data) override {
                delete static_cast<std::string*>(data);
            }
        
            bool getKey(void*, eprosima::fastrtps::rtps::InstanceHandle_t*, bool) override {
                return false;
            }
        };
        
        MBOSubscriber::MBOSubscriber()
            : participant(nullptr), subscriber(nullptr), topic(nullptr), reader(nullptr),
              matched_publishers(0), samples_received(0) 
        {
            type.reset(new StringType());
            orderbook_mgr_ = std::make_unique<OrderBookManager>();
        }
        
        MBOSubscriber::~MBOSubscriber() {
            if (reader) subscriber->delete_datareader(reader);
            if (topic) participant->delete_topic(topic);
            if (subscriber) participant->delete_subscriber(subscriber);
            if (participant) {
                eprosima::fastdds::dds::DomainParticipantFactory::get_instance()->delete_participant(participant);
            }
        }
        
        bool MBOSubscriber::init() {
            using namespace eprosima::fastdds::dds;
        
            DomainParticipantQos pqos;
            pqos.name("MBOSubscriber_Participant");
            
            participant = DomainParticipantFactory::get_instance()->create_participant(0, pqos);
            if (!participant) {
                std::cerr << "Failed to create participant" << std::endl;
                return false;
            }
        
            // Register the type
            type.register_type(participant);
        
            subscriber = participant->create_subscriber(SUBSCRIBER_QOS_DEFAULT, nullptr);
            if (!subscriber) {
                std::cerr << "Failed to create subscriber" << std::endl;
                return false;
            }
        
            TopicQos tqos = TOPIC_QOS_DEFAULT;
            topic = participant->create_topic("MBOTopic", type.get_type_name(), tqos);
            if (!topic) {
                std::cerr << "Failed to create topic" << std::endl;
                return false;
            }
        
            DataReaderQos rqos = DATAREADER_QOS_DEFAULT;
            rqos.reliability().kind = RELIABLE_RELIABILITY_QOS;
            
            reader = subscriber->create_datareader(topic, rqos, this);
            if (!reader) {
                std::cerr << "Failed to create datareader" << std::endl;
                return false;
            }
        
            std::cout << "DDS Subscriber initialized successfully" << std::endl;
            return true;
        }
        
        void MBOSubscriber::on_subscription_matched(
            eprosima::fastdds::dds::DataReader* reader,
            const eprosima::fastdds::dds::SubscriptionMatchedStatus& info) 
        {
            if (info.current_count_change == 1) {
                matched_publishers++;
                std::cout << "Publisher matched. Total publishers: " << matched_publishers << std::endl;
            } else if (info.current_count_change == -1) {
                matched_publishers--;
                std::cout << "Publisher unmatched. Total publishers: " << matched_publishers << std::endl;
            }
        }
        
        void MBOSubscriber::on_data_available(eprosima::fastdds::dds::DataReader* reader) {
            eprosima::fastdds::dds::SampleInfo info;
            std::string message;
            
            while (reader->take_next_sample(&message, &info) == ReturnCode_t::RETCODE_OK) {
                if (info.valid_data) {
                    samples_received++;
                    
                    // Parse the CSV string back to MBOParsed
                    MBOParsed record = parseCSVString(message);
                    
                    // Print the record
                    printRecord(record);
                    
                    // Process through OrderBook
                    orderbook_mgr_->processMessage(record);
                    
                    // Print book state every 100 messages (adjust as needed)
                    if (samples_received % 100 == 0) {
                        orderbook_mgr_->printBookState();
                    }
                    
                    std::cout << "[Sample #" << samples_received << "]" << std::endl;
                }
            }
        }
        
        MBOParsed MBOSubscriber::parseCSVString(const std::string& csv_line) {
            MBOParsed record{};
            std::stringstream ss(csv_line);
            std::string field;
            std::vector<std::string> fields;
            
            while (std::getline(ss, field, ',')) {
                fields.push_back(field);
            }
            
            if (fields.size() >= 15) {
                record.ts_event_str = fields[0];
                record.rtype = static_cast<uint8_t>(std::stoi(fields[1]));
                record.publisher_id = static_cast<uint16_t>(std::stoi(fields[2]));
                record.instrument_id = static_cast<uint32_t>(std::stoul(fields[3]));
                record.action = fields[4][0];
                record.side = fields[5][0];
                record.price = std::stod(fields[6]);
                record.size = static_cast<uint32_t>(std::stoul(fields[7]));
                record.channel_id = static_cast<uint8_t>(std::stoi(fields[8]));
                record.order_id = std::stoull(fields[9]);
                record.flags = static_cast<uint8_t>(std::stoi(fields[10]));
                record.ts_in_delta = std::stoi(fields[11]);
                record.sequence = static_cast<uint32_t>(std::stoul(fields[12]));
                record.symbol = fields[13];
                record.datetime = fields[14];
            }
            
            return record;
        }
        
        void MBOSubscriber::printRecord(const MBOParsed& r) {
            std::cout << std::fixed << std::setprecision(2)
                      << "ts_event=" << r.ts_event_str
                      << " rtype=" << int(r.rtype)
                      << " publisher_id=" << r.publisher_id
                      << " instrument_id=" << r.instrument_id
                      << " action=" << r.action
                      << " side=" << r.side
                      << " price=" << r.price
                      << " size=" << r.size
                      << " channel_id=" << int(r.channel_id)
                      << " order_id=" << r.order_id
                      << " flags=" << int(r.flags)
                      << " ts_in_delta=" << r.ts_in_delta
                      << " sequence=" << r.sequence
                      << " symbol=" << r.symbol
                      << " datetime=" << r.datetime
                      << std::endl;
        }
        
        void MBOSubscriber::run() {
            std::cout << "Waiting for samples... Press Ctrl+C to exit." << std::endl;
            
            // Keep running until user stops
            while (true) {
                std::this_thread::sleep_for(std::chrono::seconds(1));
            }
        }
    </[MBOSubscriber.cpp]>
    <[OrderBookManager.cpp]>
        #include "OrderBookManager.hpp"
        #include <book/depth_order_book.h>
        #include <iostream>
        #include <iomanip>
        
        OrderBookManager::OrderBookManager() {
            // Create Liquibook depth order book
            orderbook_ = new book::DepthOrderBook<book::Order*>();
            std::cout << "OrderBookManager initialized" << std::endl;
        }
        
        OrderBookManager::~OrderBookManager() {
            // Clean up all orders
            for (auto& pair : order_map_) {
                delete pair.second;
            }
            order_map_.clear();
            
            delete orderbook_;
        }
        
        void OrderBookManager::processMessage(const MBOParsed& msg) {
            switch (msg.action) {
                case 'A':
                    handleAdd(msg);
                    break;
                case 'C':
                    handleCancel(msg);
                    break;
                case 'M':
                case 'R':
                    handleModify(msg);
                    break;
                case 'T':
                    handleTrade(msg);
                    break;
                default:
                    std::cerr << "Unknown action: " << msg.action << std::endl;
            }
        }
        
        void OrderBookManager::handleAdd(const MBOParsed& msg) {
            // Check for duplicate
            if (order_map_.find(msg.order_id) != order_map_.end()) {
                std::cerr << "Duplicate add for order_id: " << msg.order_id << std::endl;
                return;
            }
            
            // Create Liquibook order
            bool is_buy = convertSide(msg.side) == book::Side::BUY;
            uint64_t price = convertPrice(msg.price);
            uint32_t qty = msg.size;
            
            book::Order* order = new book::Order(is_buy, price, qty);
            
            // Add to Liquibook
            orderbook_->add(order, price, qty, 0); // 0 = no stop price
            
            // Store in map
            order_map_[msg.order_id] = order;
            
            std::cout << "ADD: order_id=" << msg.order_id 
                      << " side=" << msg.side 
                      << " price=" << msg.price 
                      << " size=" << msg.size << std::endl;
            
            // Check if there was a pending cancel
            auto pending = pending_cancels_.find(msg.order_id);
            if (pending != pending_cancels_.end()) {
                std::cout << "Applying pending cancel for order_id=" << msg.order_id << std::endl;
                handleCancel(pending->second);
                pending_cancels_.erase(pending);
            }
        }
        
        void OrderBookManager::handleCancel(const MBOParsed& msg) {
            book::Order* order = findOrder(msg.order_id);
            
            if (!order) {
                // Order not found - might be out of order message
                std::cerr << "Cancel for non-existent order_id: " << msg.order_id 
                          << " (buffering)" << std::endl;
                pending_cancels_[msg.order_id] = msg;
                return;
            }
            
            // Cancel in Liquibook
            orderbook_->cancel(order);
            
            std::cout << "CANCEL: order_id=" << msg.order_id << std::endl;
            
            // Remove from map
            order_map_.erase(msg.order_id);
            
            // Clean up memory
            delete order;
        }
        
        void OrderBookManager::handleModify(const MBOParsed& msg) {
            book::Order* order = findOrder(msg.order_id);
            
            if (!order) {
                std::cerr << "Modify for non-existent order_id: " << msg.order_id << std::endl;
                return;
            }
            
            // Liquibook doesn't have native modify - do cancel + add
            bool is_buy = order->is_buy();
            
            // Cancel old order
            orderbook_->cancel(order);
            order_map_.erase(msg.order_id);
            delete order;
            
            // Add new order with modified parameters
            uint64_t new_price = convertPrice(msg.price);
            uint32_t new_qty = msg.size;
            
            book::Order* new_order = new book::Order(is_buy, new_price, new_qty);
            orderbook_->add(new_order, new_price, new_qty, 0);
            order_map_[msg.order_id] = new_order;
            
            std::cout << "MODIFY: order_id=" << msg.order_id 
                      << " new_price=" << msg.price 
                      << " new_size=" << msg.size << std::endl;
        }
        
        void OrderBookManager::handleTrade(const MBOParsed& msg) {
            book::Order* order = findOrder(msg.order_id);
            
            if (!order) {
                std::cerr << "Trade for non-existent order_id: " << msg.order_id << std::endl;
                return;
            }
            
            // For trade, we need to reduce the order quantity
            // Liquibook handles this internally when fills occur
            // Here we just log it
            std::cout << "TRADE: order_id=" << msg.order_id 
                      << " qty=" << msg.size 
                      << " price=" << msg.price << std::endl;
            
            // Note: Actual fill reduction should be handled by Liquibook callbacks
            // For this minimal version, we'll let Liquibook manage it
        }
        
        book::Order* OrderBookManager::findOrder(uint64_t order_id) {
            auto it = order_map_.find(order_id);
            if (it != order_map_.end()) {
                return it->second;
            }
            return nullptr;
        }
        
        book::Side OrderBookManager::convertSide(char side) {
            return (side == 'B' || side == 'b') ? book::Side::BUY : book::Side::SELL;
        }
        
        uint64_t OrderBookManager::convertPrice(double price) {
            // Scale price to avoid floating point (e.g., $123.45 -> 12345)
            // Assuming 2 decimal places for stocks
            return static_cast<uint64_t>(price * 100.0);
        }
        
        void OrderBookManager::printBookState() {
            std::cout << "\n========== ORDER BOOK STATE ==========" << std::endl;
            std::cout << "Total orders in book: " << order_map_.size() << std::endl;
            
            // Access the depth (bids and asks)
            const book::DepthOrderBook<book::Order*>* depth_book = 
                dynamic_cast<const book::DepthOrderBook<book::Order*>*>(orderbook_);
            
            if (depth_book) {
                // Print asks (sells) - top to bottom
                std::cout << "\n--- ASKS (SELL) ---" << std::endl;
                auto& asks = depth_book->asks();
                for (auto it = asks.rbegin(); it != asks.rend(); ++it) {
                    double price = it->first / 100.0; // unscale price
                    uint32_t qty = it->second.aggregate_qty();
                    std::cout << std::fixed << std::setprecision(2)
                              << "  " << std::setw(8) << price 
                              << " | " << std::setw(8) << qty << std::endl;
                }
                
                std::cout << "   --------+--------" << std::endl;
                
                // Print bids (buys) - top to bottom
                std::cout << "--- BIDS (BUY) ---" << std::endl;
                auto& bids = depth_book->bids();
                for (auto it = bids.begin(); it != bids.end(); ++it) {
                    double price = it->first / 100.0; // unscale price
                    uint32_t qty = it->second.aggregate_qty();
                    std::cout << std::fixed << std::setprecision(2)
                              << "  " << std::setw(8) << price 
                              << " | " << std::setw(8) << qty << std::endl;
                }
            }
            
            std::cout << "======================================\n" << std::endl;
        }
    </[OrderBookManager.cpp]>
</src>
</project_structure>
